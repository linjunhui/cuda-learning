/*
 * SHA256 暴力破解工具 - CPU 版本
 * 
 * 项目需求：
 * ==========
 * 
 * 1. 密码加密与存储
 *    - 使用 SHA256 算法对密码进行哈希加密
 *    - SHA256 是一种单向哈希函数，将任意长度的输入转换为固定长度（256位/32字节）的输出
 *    - 加密后的哈希值通常以十六进制字符串形式存储（64个字符）
 *    - 实际应用中，密码通常不会以明文形式存储，而是存储其 SHA256 哈希值
 * 
 * 2. SHA256 算法说明
 *    - SHA256（Secure Hash Algorithm 256-bit）是 SHA-2 系列哈希函数之一
 *    - 算法特点：
 *      * 单向性：无法从哈希值反推出原始密码
 *      * 雪崩效应：输入微小变化会导致输出巨大变化
 *      * 确定性：相同输入总是产生相同输出
 *      * 抗碰撞性：很难找到两个不同的输入产生相同的哈希值
 * 
 *    SHA256 加密流程详解：
 *    ====================
 * 
 *    步骤1：消息预处理（Message Preprocessing）
 *    -------------------------------------------
 *    1.1 将输入消息转换为二进制格式
 *        - 对于字符串输入，将每个字符转换为对应的 ASCII 码（8位）
 *        - 例如："abc" → 01100001 01100010 01100011
 * 
 *    1.2 添加填充位（Padding）
 *        - 在消息末尾添加一个 '1' 位（0x80）
 *        - 然后添加 k 个 '0' 位，使得消息长度满足：
 *          消息长度 + 1 + k + 64 ≡ 0 (mod 512)
 *        - 其中 64 是为原始消息长度预留的位数
 *        - 示例：如果消息是 "abc"（24位），则：
 *          * 添加 1 位：24 + 1 = 25
 *          * 需要填充到 512 - 64 = 448 位：添加 423 个 '0'
 *          * 最后添加 64 位的原始消息长度（24）
 * 
 *    1.3 添加消息长度
 *        - 在填充后的消息末尾添加 64 位的原始消息长度（以位为单位）
 *        - 使用大端序（Big-Endian）存储
 *        - 最终消息长度必须是 512 位的倍数
 * 
 *    步骤2：消息分块（Message Blocking）
 *    -----------------------------------
 *    2.1 将填充后的消息分成 N 个 512 位的块：M[0], M[1], ..., M[N-1]
 *    2.2 每个块进一步分成 16 个 32 位的字：M[i] = W[0..15]
 *    2.3 使用消息调度算法扩展为 64 个 32 位字：W[0..63]
 *        for t from 16 to 63:
 *            W[t] = σ1(W[t-2]) + W[t-7] + σ0(W[t-15]) + W[t-16]
 *        其中：
 *        σ0(x) = ROTR(x, 7) ⊕ ROTR(x, 18) ⊕ SHR(x, 3)
 *        σ1(x) = ROTR(x, 17) ⊕ ROTR(x, 19) ⊕ SHR(x, 10)
 *        ROTR = 循环右移，SHR = 逻辑右移，⊕ = 异或
 * 
 *    步骤3：初始化哈希值（Initialize Hash Values）
 *    ---------------------------------------------
 *    3.1 初始化 8 个 32 位的工作变量（h0 到 h7），使用前 8 个素数的平方根的小数部分：
 *        h0 = 0x6a09e667
 *        h1 = 0xbb67ae85
 *        h2 = 0x3c6ef372
 *        h3 = 0xa54ff53a
 *        h4 = 0x510e527f
 *        h5 = 0x9b05688c
 *        h6 = 0x1f83d9ab
 *        h7 = 0x5be0cd19
 * 
 *    步骤4：主循环处理（Main Loop）
 *    ------------------------------
 *    对每个 512 位块执行以下操作：
 * 
 *    4.1 初始化工作变量 a, b, c, d, e, f, g, h
 *        a = h0, b = h1, c = h2, d = h3
 *        e = h4, f = h5, g = h6, h = h7
 * 
 *    4.2 执行 64 轮压缩函数（Compression Function）
 *        for t from 0 to 63:
 *            T1 = h + Σ1(e) + Ch(e, f, g) + K[t] + W[t]
 *            T2 = Σ0(a) + Maj(a, b, c)
 *            h = g
 *            g = f
 *            f = e
 *            e = d + T1
 *            d = c
 *            c = b
 *            b = a
 *            a = T1 + T2
 * 
 *        其中：
 *        - K[t] 是 64 个常量（前 64 个素数的立方根的小数部分）
 *        - Ch(e, f, g) = (e ∧ f) ⊕ (¬e ∧ g)  // 选择函数
 *        - Maj(a, b, c) = (a ∧ b) ⊕ (a ∧ c) ⊕ (b ∧ c)  // 多数函数
 *        - Σ0(x) = ROTR(x, 2) ⊕ ROTR(x, 13) ⊕ ROTR(x, 22)
 *        - Σ1(x) = ROTR(x, 6) ⊕ ROTR(x, 11) ⊕ ROTR(x, 25)
 *        - ∧ = 与，⊕ = 异或，¬ = 非
 * 
 *    4.3 更新哈希值
 *        h0 = h0 + a
 *        h1 = h1 + b
 *        h2 = h2 + c
 *        h3 = h3 + d
 *        h4 = h4 + e
 *        h5 = h5 + f
 *        h6 = h6 + g
 *        h7 = h7 + h
 * 
 *    步骤5：输出最终哈希值（Final Hash Value）
 *    -----------------------------------------
 *    5.1 将所有块的哈希值连接起来
 *    5.2 将 h0, h1, h2, h3, h4, h5, h6, h7 按大端序连接
 *    5.3 转换为十六进制字符串（每个 32 位字转换为 8 个十六进制字符）
 *    5.4 最终输出：256 位（32 字节）的哈希值，表示为 64 个十六进制字符
 * 
 *    示例：
 *    -----
 *    输入："abc"
 *    输出："ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
 * 
 *    伪代码总结：
 *    ----------
 *    function sha256(message):
 *        // 1. 预处理
 *        padded_message = pad_message(message)
 *        blocks = split_into_512bit_blocks(padded_message)
 *        
 *        // 2. 初始化
 *        h[0..7] = initial_hash_values
 *        
 *        // 3. 处理每个块
 *        for each block in blocks:
 *            W[0..63] = expand_block(block)
 *            a, b, c, d, e, f, g, h = h[0..7]
 *            
 *            for t = 0 to 63:
 *                T1 = h + Σ1(e) + Ch(e, f, g) + K[t] + W[t]
 *                T2 = Σ0(a) + Maj(a, b, c)
 *                h = g; g = f; f = e; e = d + T1
 *                d = c; c = b; b = a; a = T1 + T2
 *            
 *            h[0..7] += a, b, c, d, e, f, g, h
 *        
 *        // 4. 输出
 *        return concatenate(h[0..7]) as hex_string
 * 
 * 3. 暴力破解原理
 *    - 目标：给定一个 SHA256 哈希值，通过尝试所有可能的密码组合来找到原始密码
 *    - 方法：
 *      * 生成候选密码：按照字符集（如小写字母、大写字母、数字、特殊字符）生成所有可能的密码组合
 *      * 计算哈希值：对每个候选密码计算其 SHA256 哈希值
 *      * 比对匹配：将计算出的哈希值与目标哈希值进行比较
 *      * 找到密码：如果匹配成功，则找到了原始密码
 *    - 搜索策略：
 *      * 按长度递增：先尝试短密码，再尝试长密码（如 1位 → 2位 → 3位 → ...）
 *      * 按字符集顺序：按照预定义的字符集顺序生成密码（如 a, b, c, ..., z, 0, 1, ..., 9）
 *      * 字典攻击：使用常见密码字典进行尝试（不在本项目的暴力破解范围内）
 * 
 * 4. 实现要求
 *    - CPU 版本实现：
 *      * 使用标准 C++ 实现 SHA256 算法
 *      * 使用多线程并行计算以提高破解速度
 *      * 支持自定义字符集（如仅小写字母、字母+数字、包含特殊字符等）
 *      * 支持设置最大密码长度限制
 *      * 提供进度显示和性能统计（尝试次数、速度等）
 *    - 性能优化：
 *      * 使用多线程充分利用多核 CPU
 *      * 优化 SHA256 计算实现
 *      * 减少不必要的内存分配和拷贝
 * 
 * 5. 使用场景
 *    - 密码恢复：忘记密码时尝试恢复（仅限合法用途）
 *    - 安全测试：测试系统密码强度，评估安全性
 *    - 学习研究：理解哈希函数和密码学原理
 *    - 性能对比：作为基准，与 GPU（CUDA）版本进行性能对比
 * 
 * 6. 注意事项
 *    - 仅用于合法用途：不得用于未经授权的密码破解
 *    - 性能限制：CPU 版本的破解速度较慢，适合短密码或作为基准测试
 *    - 字符集影响：字符集越大，搜索空间呈指数增长，破解时间急剧增加
 *    - 密码长度影响：密码长度每增加1位，搜索空间增加约字符集大小的倍数
 *    - 实际应用：对于强密码（长密码+复杂字符集），暴力破解几乎不可行
 * 
 * 7. 后续扩展
 *    - GPU（CUDA）版本：利用 GPU 的并行计算能力大幅提升破解速度
 *    - 分布式版本：在多台机器上分布式计算
 *    - 字典攻击：结合常见密码字典进行混合攻击
 *    - 规则引擎：支持密码生成规则（如首字母大写、末尾加数字等）
 */

/*
 * ========== 编译说明 ==========
 * 
 * 基本编译命令：
 * g++ -o sha256_cracker_cpu sha256_cracker_cpu.cpp -lssl -lcrypto
 * 
 * 详细说明：
 * - g++：GNU C++ 编译器
 * - -o sha256_cracker_cpu：指定输出可执行文件名为 sha256_cracker_cpu
 * - sha256_cracker_cpu.cpp：源文件
 * - -lssl：链接 OpenSSL 的 SSL 库（虽然本程序不使用 SSL，但某些系统需要）
 * - -lcrypto：链接 OpenSSL 的加密库（必需，用于 SHA256 函数）
 * 
 * 优化编译（推荐）：
 * g++ -O2 -o sha256_cracker_cpu sha256_cracker_cpu.cpp -lssl -lcrypto
 * 
 * 调试编译：
 * g++ -g -Wall -o sha256_cracker_cpu sha256_cracker_cpu.cpp -lssl -lcrypto
 * 
 * 完整优化编译（生产环境）：
 * g++ -O3 -march=native -o sha256_cracker_cpu sha256_cracker_cpu.cpp -lssl -lcrypto
 * 
 * 编译选项说明：
 * - -O2：优化级别2，平衡编译时间和运行性能
 * - -O3：优化级别3，最大化运行性能（编译时间更长）
 * - -g：生成调试信息
 * - -Wall：显示所有警告信息
 * - -march=native：针对当前 CPU 架构优化
 * 
 * 依赖库安装（Ubuntu/Debian）：
 * sudo apt-get install libssl-dev
 * 
 * 依赖库安装（CentOS/RHEL）：
 * sudo yum install openssl-devel
 * 
 * 依赖库安装（macOS）：
 * brew install openssl
 * # 如果使用 Homebrew 安装的 OpenSSL，可能需要指定路径：
 * # g++ -I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib \
 * #     -o sha256_cracker_cpu sha256_cracker_cpu.cpp -lssl -lcrypto
 * 
 * 使用方法：
 * ./sha256_cracker_cpu <64位十六进制哈希值>
 * 例如：
 * ./sha256_cracker_cpu ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
 * 
 * 测试哈希值生成（用于测试程序）：
 * echo -n "abc" | sha256sum
 * # 输出：ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
 */

// ========== 头文件包含 ==========
#include <math.h>          // 数学函数，用于计算密码组合总数（powl）
#include <openssl/sha.h>   // OpenSSL 库，提供 SHA256 哈希函数实现
#include <stdio.h>         // 标准输入输出，用于打印结果
#include <string.h>        // 字符串处理函数（strlen, memcmp）
#include <sys/time.h>      // 时间相关函数（当前未使用，可用于性能统计）

// ========== 常量定义 ==========
#define HASH_LENGTH 32              // SHA256 哈希值长度：256位 = 32字节
#define MAX_PASSWORD_LENGTH 10      // 最大密码长度限制（防止搜索空间过大）
#define LOG_INTERVAL 10000          // 日志输出间隔：每尝试10000个密码输出一次进度

// ========== 字符集定义 ==========
// 定义用于生成可能密码的字符集
// 当前字符集：小写字母 a-z (26个) + 数字 0-9 (10个) = 36个字符
// 可以根据需要扩展：添加大写字母、特殊字符等
char CHARSET[] = "abcdefghijklmnopqrstuvwxyz0123456789";
#define CHARSET_LENGTH (sizeof(CHARSET) - 1)  // 字符集长度：36（减1是因为字符串末尾的'\0'）

// ========== 函数实现 ==========

/**
 * 根据索引生成密码字符串
 * 
 * ========== 索引与SHA256的关系详解 ==========
 * 
 * 暴力破解的核心流程：
 * ┌─────────┐      ┌──────────┐      ┌─────────────┐      ┌──────────┐
 * │  索引   │  →   │   密码   │  →   │  SHA256计算  │  →   │  哈希值   │
 * │ (index) │      │(password)│      │  (计算过程)  │      │  (hash)   │
 * └─────────┘      └──────────┘      └─────────────┘      └──────────┘
 *     0        →       "a"       →    SHA256("a")    →    [32字节哈希]
 *     1        →       "b"       →    SHA256("b")    →    [32字节哈希]
 *     2        →       "c"       →    SHA256("c")    →    [32字节哈希]
 *    ...       →       ...       →       ...         →       ...
 *    36        →       "aa"      →    SHA256("aa")   →    [32字节哈希]
 *    37        →       "ab"      →    SHA256("ab")   →    [32字节哈希]
 * 
 * 关键理解：
 * 1. 索引是"密码的编号"：每个可能的密码都有一个唯一的索引号
 * 2. 索引 → 密码：通过进制转换将索引转换为对应的密码字符串
 * 3. 密码 → SHA256：对密码计算哈希值
 * 4. 哈希值比对：将计算出的哈希值与目标哈希值比较
 * 
 * 为什么需要索引？
 * - 我们需要系统地遍历所有可能的密码
 * - 索引提供了一种有序的方式来生成所有密码组合
 * - 类似于：索引0=第一个密码，索引1=第二个密码，...
 * 
 * 完整示例（字符集="abc"，长度=2）：
 * ┌───────┬────────┬──────────────────────────────────────────────┬──────────────────────────────┐
 * │ 索引  │  密码  │            SHA256计算过程                    │        哈希值（前16位）      │
 * ├───────┼────────┼──────────────────────────────────────────────┼──────────────────────────────┤
 * │   0   │  "aa"  │ SHA256_Init → SHA256_Update("aa") → Final   │ 961b6dd3...                 │
 * │   1   │  "ab"  │ SHA256_Init → SHA256_Update("ab") → Final   │ fb8e20fc...                 │
 * │   2   │  "ac"  │ SHA256_Init → SHA256_Update("ac") → Final   │ 3d5c0c62...                 │
 * │   3   │  "ba"  │ SHA256_Init → SHA256_Update("ba") → Final   │ 8c6976e5...                 │
 * │   4   │  "bb"  │ SHA256_Init → SHA256_Update("bb") → Final   │ 61e9c06e...                 │
 * │   5   │  "bc"  │ SHA256_Init → SHA256_Update("bc") → Final   │ 84af6031...                 │
 * │   6   │  "ca"  │ SHA256_Init → SHA256_Update("ca") → Final   │ 2d711642...                 │
 * │   7   │  "cb"  │ SHA256_Init → SHA256_Update("cb") → Final   │ 9f86d081...                 │
 * │   8   │  "cc"  │ SHA256_Init → SHA256_Update("cc") → Final   │ 4a202b3f...                 │
 * └───────┴────────┴──────────────────────────────────────────────┴──────────────────────────────┘
 * 
 * 实际破解过程（假设目标哈希是"ab"的哈希值）：
 * 1. index=0 → password="aa" → hash=961b6dd3... → 不匹配，继续
 * 2. index=1 → password="ab" → hash=fb8e20fc... → 匹配！找到密码"ab"
 * 
 * 功能说明：
 * 将数字索引转换为对应字符集的密码字符串，类似于将数字转换为指定进制的表示
 * 例如：索引0对应"a"，索引1对应"b"，...，索引35对应"9"，索引36对应"aa"
 * 
 * 算法原理：
 * 使用类似进制转换的方法，从低位到高位依次确定每个字符
 * - 索引对字符集长度取模，得到当前位的字符索引
 * - 索引除以字符集长度，得到更高位的索引
 * - 重复直到所有位都确定
 * 
 * 详细示例（字符集="abc"，长度=2）：
 * - 索引=0, 长度=2 → "aa" 
 *   计算：0 % 3 = 0 → 'a', 0 / 3 = 0, 0 % 3 = 0 → 'a'
 * - 索引=1, 长度=2 → "ab"
 *   计算：1 % 3 = 1 → 'b', 1 / 3 = 0, 0 % 3 = 0 → 'a'（注意顺序：从右到左）
 * - 索引=2, 长度=2 → "ac"
 *   计算：2 % 3 = 2 → 'c', 2 / 3 = 0, 0 % 3 = 0 → 'a'
 * - 索引=3, 长度=2 → "ba"
 *   计算：3 % 3 = 0 → 'a', 3 / 3 = 1, 1 % 3 = 1 → 'b'
 * 
 * @param password 输出参数，用于存储生成的密码字符串（必须预先分配足够空间）
 * @param index 密码的索引值（从0开始）
 * @param password_length 密码长度（字符数）
 */
static void index_to_password(char *password, unsigned long long index,
                              int password_length) {
  // 从最低位（最右边）开始生成密码字符
  // 例如：对于长度为3的密码，先确定第2位，再确定第1位，最后确定第0位
  for (int i = password_length - 1; i >= 0; --i) {
    // 当前位的字符 = 字符集[索引 % 字符集长度]
    // 例如：index=37, CHARSET_LENGTH=36
    // i=1: password[1] = CHARSET[37%36] = CHARSET[1] = 'b'
    // i=0: password[0] = CHARSET[1%36] = CHARSET[1] = 'a'
    password[i] = CHARSET[index % CHARSET_LENGTH];
    
    // 将索引除以字符集长度，得到更高位的索引值
    // 继续处理下一位
    index /= CHARSET_LENGTH;
  }
  
  // 在字符串末尾添加结束符
  password[password_length] = '\0';
}

// ========== 主函数 ==========

/**
 * 主函数：SHA256 暴力破解程序入口
 * 
 * 程序流程：
 * 1. 从命令行参数读取目标哈希值（64位十六进制字符串）
 * 2. 按密码长度递增遍历（1位 → 2位 → ... → MAX_PASSWORD_LENGTH位）
 * 3. 对每个长度，遍历所有可能的密码组合
 * 4. 对每个候选密码计算 SHA256 哈希值
 * 5. 将计算出的哈希值与目标哈希值比较
 * 6. 如果匹配，输出密码并退出；否则继续尝试
 * 
 * 使用方法：
 * ./sha256_cracker_cpu <64位十六进制哈希值>
 * 例如：./sha256_cracker_cpu ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
 * 
 * @param argc 命令行参数个数（应该为2：程序名 + 哈希值）
 * @param argv 命令行参数数组
 * @return 0 表示成功找到密码或正常结束，非0表示错误
 */
int main(int argc, char **argv) {
  // ========== 步骤1：解析命令行参数，读取目标哈希值 ==========
  // 目标哈希值以64位十六进制字符串形式传入（例如："ba7816bf..."）
  // 需要将其转换为32字节的二进制格式存储在 input_hash 数组中
  unsigned char input_hash[HASH_LENGTH];
  
  // 将十六进制字符串转换为字节数组
  // 每2个十六进制字符对应1个字节
  // 例如："ba" → 0xba, "78" → 0x78, ...
  for (int i = 0; i < HASH_LENGTH; i++) {
    // sscanf 从 argv[1] 的第 i*2 个字符开始读取2个十六进制字符
    // "%2hhx" 表示读取2个字符作为十六进制数，存储到 unsigned char 类型
    // &argv[1][i * 2] 是字符串中第 i*2 个字符的地址
    sscanf(&argv[1][i * 2], "%2hhx", &input_hash[i]);
  }

  // ========== 步骤2：按密码长度递增遍历 ==========
  // 暴力破解策略：先尝试短密码，再尝试长密码
  // 这样可以更快找到短密码（如果存在）
  for (int password_length = 1; password_length <= MAX_PASSWORD_LENGTH;
       password_length++) {

    // ========== 步骤3：计算当前长度的密码组合总数 ==========
    // 对于长度为 n 的密码，使用字符集大小为 m 的情况：
    // 总组合数 = m^n
    // 例如：长度=1, 字符集=36 → 36^1 = 36 种组合
    //      长度=2, 字符集=36 → 36^2 = 1296 种组合
    //      长度=3, 字符集=36 → 36^3 = 46656 种组合
    // 注意：随着长度增加，搜索空间呈指数增长！
    unsigned long long password_count = powl(CHARSET_LENGTH, password_length);
    
    // ========== 步骤4：遍历当前长度的所有密码组合 ==========
    // 使用索引从 0 到 password_count-1 来生成所有可能的密码
    // 
    // 核心流程：索引 → 密码 → SHA256哈希 → 比对
    // 
    // 示例流程（假设字符集="abc"，长度=2，目标哈希是"ab"的哈希）：
    // ┌─────────────────────────────────────────────────────────────────┐
    // │ 循环迭代  │  索引  │  生成密码  │  计算SHA256  │  比对结果  │
    // ├─────────────────────────────────────────────────────────────────┤
    // │  第1次    │   0    │   "aa"    │  hash_aa     │  不匹配    │
    // │  第2次    │   1    │   "ab"    │  hash_ab     │  匹配！✓   │
    // │  第3次    │   2    │   "ac"    │  hash_ac     │  (已退出)  │
    // └─────────────────────────────────────────────────────────────────┘
    //
    for (long long index = 0; index < password_count; index++) {
      // ========== 4.1：索引 → 密码（索引转换为密码字符串）==========
      // 这一步将数字索引转换为对应的密码字符串
      // 例如：index=1, length=2, charset="abc" → password="ab"
      char password[MAX_PASSWORD_LENGTH + 1];
      index_to_password(password, index, password_length);
      
      // ========== 4.2：输出进度信息 ==========
      // 每 LOG_INTERVAL 次尝试输出一次，帮助用户了解程序运行状态
      if (index % LOG_INTERVAL == 0) {
        printf("Testing \"%s\" (index=%lld)\n", password, index);
      }

      // ========== 步骤5：密码 → SHA256哈希（计算密码的哈希值）==========
      // 这一步对生成的密码计算SHA256哈希值
      // 输入：password（例如："ab"）
      // 输出：hash（32字节的哈希值，例如：fb8e20fc2b4a6b5a...）
      unsigned char hash[HASH_LENGTH];  // 存储计算出的哈希值（32字节）
      SHA256_CTX sha256;                // SHA256 上下文结构体（保存计算状态）
      
      // 5.1 初始化 SHA256 上下文
      // 设置初始哈希值（h0-h7）和内部状态
      // 这相当于重置计算器，准备开始新的哈希计算
      SHA256_Init(&sha256);
      
      // 5.2 更新哈希计算
      // 将密码字符串添加到哈希计算中
      // 这一步执行SHA256算法的核心计算：填充、分块、压缩等
      // 输入：password（例如："ab"）
      // 过程：SHA256算法内部处理（详见文件头部的SHA256算法说明）
      // 可以多次调用 SHA256_Update 来处理长消息（分块处理）
      SHA256_Update(&sha256, password, strlen(password));
      
      // 5.3 完成哈希计算
      // 执行最终的填充和压缩，得到最终的256位哈希值
      // 输出：hash（32字节的二进制哈希值）
      // 例如：password="ab" → hash=[0xfb, 0x8e, 0x20, 0xfc, ...]（32个字节）
      SHA256_Final(hash, &sha256);

      // ========== 步骤6：SHA256哈希 → 比对结果（比较哈希值）==========
      // 将计算出的哈希值与目标哈希值进行逐字节比较
      // memcmp 返回0表示两个内存区域完全相同（即找到了匹配的密码）
      // 
      // 比对过程：
      // input_hash: [0xba, 0x78, 0x16, ...]  (目标哈希，32字节)
      // hash:       [0xfb, 0x8e, 0x20, ...]  (当前密码的哈希，32字节)
      // 逐字节比较：如果完全相同 → 找到密码！
      //
      if (memcmp(hash, input_hash, HASH_LENGTH) == 0) {
        // 找到匹配的密码！
        // 这意味着：SHA256(当前密码) == 目标哈希值
        // 因此：当前密码就是我们要找的原始密码
        printf("Password found: %s\n", password);
        printf("Hash: ");
        for (int i = 0; i < HASH_LENGTH; i++) {
          printf("%02x", hash[i]);
        }
        printf("\n");
        return 0;  // 成功找到密码，退出程序
      }
      // 如果不匹配，继续尝试下一个密码（index++）
      // 循环继续，直到找到匹配或遍历完所有可能的密码
    }
    // 当前长度的所有密码都尝试完毕，继续尝试下一个长度
  }

  // 所有可能的密码组合都已尝试，但未找到匹配
  // 可能原因：密码长度超过 MAX_PASSWORD_LENGTH，或使用了字符集外的字符
  return 0;
}