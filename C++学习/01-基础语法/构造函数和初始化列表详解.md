# C++构造函数和初始化列表详解

## 概述

构造函数是C++类中用于初始化对象的特殊成员函数。初始化列表是构造函数中用于高效初始化成员变量的语法特性。

## 1. 构造函数基础

### 1.1 构造函数的定义
```cpp
class MyClass {
private:
    int value;
    std::string name;
    
public:
    // 默认构造函数
    MyClass() : value(0), name("default") {}
    
    // 参数化构造函数
    MyClass(int v, const std::string& n) : value(v), name(n) {}
    
    // 析构函数
    ~MyClass() {
        std::cout << "MyClass destroyed" << std::endl;
    }
};
```

### 1.2 构造函数的调用时机
```cpp
int main() {
    MyClass obj1;                    // 调用默认构造函数
    MyClass obj2(42, "Hello");       // 调用参数化构造函数
    MyClass obj3 = MyClass(10, "World"); // 临时对象构造
    return 0;  // 析构函数自动调用
}
```

## 2. 初始化列表详解

### 2.1 初始化列表语法
```cpp
class Rectangle {
private:
    double width;
    double height;
    std::string name;
    
public:
    // 初始化列表语法：[成员变量](参数)
    Rectangle(double w, double h, const std::string& n) 
        : width(w), height(h), name(n) {
        // 构造函数体
        std::cout << "Rectangle created: " << name << std::endl;
    }
};
```

### 2.2 初始化列表 vs 赋值
```cpp
class Example {
private:
    int value;
    std::string text;
    
public:
    // ❌ 错误方式：先默认构造，再赋值
    Example(int v, const std::string& t) {
        value = v;  // 赋值，不是初始化
        text = t;   // 赋值，不是初始化
    }
    
    // ✅ 正确方式：使用初始化列表
    Example(int v, const std::string& t) : value(v), text(t) {
        // 直接初始化，效率更高
    }
};
```

### 2.3 初始化列表的优势
```cpp
class PerformanceTest {
private:
    std::vector<int> data;
    std::string name;
    
public:
    // 使用初始化列表：只构造一次
    PerformanceTest(int size, const std::string& n) 
        : data(size), name(n) {
        // data直接构造为size大小的vector
        // name直接构造为n的副本
    }
    
    // 不使用初始化列表：构造两次
    PerformanceTest(int size, const std::string& n) {
        data = std::vector<int>(size);  // 先默认构造，再赋值
        name = n;                       // 先默认构造，再赋值
    }
};
```

## 3. 复制构造函数

### 3.1 复制构造函数的定义
```cpp
class Student {
private:
    std::string name;
    int age;
    double* scores;  // 动态分配的内存
    
public:
    // 构造函数
    Student(const std::string& n, int a) : name(n), age(a) {
        scores = new double[3];
        for(int i = 0; i < 3; ++i) {
            scores[i] = 0.0;
        }
    }
    
    // 复制构造函数
    Student(const Student& other) : name(other.name), age(other.age) {
        // 深拷贝：分配新的内存
        scores = new double[3];
        for(int i = 0; i < 3; ++i) {
            scores[i] = other.scores[i];
        }
        std::cout << "Copy constructor called" << std::endl;
    }
    
    // 析构函数
    ~Student() {
        delete[] scores;
        std::cout << "Student destroyed" << std::endl;
    }
    
    // 赋值操作符
    Student& operator=(const Student& other) {
        if(this != &other) {  // 避免自赋值
            name = other.name;
            age = other.age;
            
            // 释放原有内存
            delete[] scores;
            
            // 分配新内存并复制
            scores = new double[3];
            for(int i = 0; i < 3; ++i) {
                scores[i] = other.scores[i];
            }
        }
        return *this;
    }
};
```

### 3.2 复制构造函数的调用时机
```cpp
int main() {
    Student s1("Alice", 20);
    
    // 以下情况会调用复制构造函数：
    Student s2 = s1;           // 1. 对象初始化
    Student s3(s1);            // 2. 直接初始化
    Student s4{s1};            // 3. 列表初始化
    Student s5 = Student(s1);  // 4. 临时对象
    
    // 函数参数传递
    void processStudent(Student s);  // 按值传递会调用复制构造函数
    processStudent(s1);
    
    // 函数返回值
    Student createStudent() {
        Student temp("Bob", 21);
        return temp;  // 可能调用复制构造函数
    }
    
    return 0;
}
```

## 4. 移动构造函数（C++11）

### 4.1 移动构造函数的定义
```cpp
class ModernStudent {
private:
    std::string name;
    int age;
    std::vector<double> scores;
    
public:
    // 构造函数
    ModernStudent(const std::string& n, int a) : name(n), age(a) {
        scores.resize(3, 0.0);
    }
    
    // 移动构造函数
    ModernStudent(ModernStudent&& other) noexcept 
        : name(std::move(other.name)), 
          age(other.age), 
          scores(std::move(other.scores)) {
        // 将other的资源移动到当前对象
        other.age = 0;  // 重置other的状态
        std::cout << "Move constructor called" << std::endl;
    }
    
    // 移动赋值操作符
    ModernStudent& operator=(ModernStudent&& other) noexcept {
        if(this != &other) {
            name = std::move(other.name);
            age = other.age;
            scores = std::move(other.scores);
            other.age = 0;
        }
        return *this;
    }
};
```

## 5. 完整的类示例

### 5.1 完整的Rectangle类
```cpp
#include <iostream>
#include <string>

class Rectangle {
private:
    double width;
    double height;
    std::string name;
    static int objectCount;  // 静态成员变量
    
public:
    // 默认构造函数
    Rectangle() : width(0), height(0), name("Default") {
        objectCount++;
        std::cout << "Default constructor called for " << name << std::endl;
    }
    
    // 参数化构造函数
    Rectangle(double w, double h, const std::string& n) 
        : width(w), height(h), name(n) {
        objectCount++;
        std::cout << "Parameterized constructor called for " << name << std::endl;
    }
    
    // 复制构造函数
    Rectangle(const Rectangle& other) 
        : width(other.width), height(other.height), name(other.name + "_copy") {
        objectCount++;
        std::cout << "Copy constructor called for " << name << std::endl;
    }
    
    // 移动构造函数
    Rectangle(Rectangle&& other) noexcept 
        : width(other.width), height(other.height), name(std::move(other.name)) {
        objectCount++;
        other.width = 0;
        other.height = 0;
        other.name = "Moved";
        std::cout << "Move constructor called for " << name << std::endl;
    }
    
    // 析构函数
    ~Rectangle() {
        objectCount--;
        std::cout << "Destructor called for " << name << std::endl;
    }
    
    // 赋值操作符
    Rectangle& operator=(const Rectangle& other) {
        if(this != &other) {
            width = other.width;
            height = other.height;
            name = other.name + "_assigned";
            std::cout << "Assignment operator called for " << name << std::endl;
        }
        return *this;
    }
    
    // 移动赋值操作符
    Rectangle& operator=(Rectangle&& other) noexcept {
        if(this != &other) {
            width = other.width;
            height = other.height;
            name = std::move(other.name);
            other.width = 0;
            other.height = 0;
            other.name = "Moved";
            std::cout << "Move assignment operator called for " << name << std::endl;
        }
        return *this;
    }
    
    // 成员函数
    double getArea() const {
        return width * height;
    }
    
    double getPerimeter() const {
        return 2 * (width + height);
    }
    
    void setDimensions(double w, double h) {
        width = w;
        height = h;
    }
    
    // 访问器函数
    double getWidth() const { return width; }
    double getHeight() const { return height; }
    const std::string& getName() const { return name; }
    
    // 静态成员函数
    static int getObjectCount() {
        return objectCount;
    }
};

// 静态成员变量定义
int Rectangle::objectCount = 0;
```

### 5.2 使用示例
```cpp
int main() {
    std::cout << "=== 构造函数和初始化列表演示 ===" << std::endl;
    
    // 1. 默认构造函数
    std::cout << "\n1. 默认构造函数:" << std::endl;
    Rectangle rect1;
    std::cout << "Rectangle 1: " << rect1.getName() 
              << ", Area: " << rect1.getArea() << std::endl;
    
    // 2. 参数化构造函数
    std::cout << "\n2. 参数化构造函数:" << std::endl;
    Rectangle rect2(5.0, 3.0, "Rect2");
    std::cout << "Rectangle 2: " << rect2.getName() 
              << ", Area: " << rect2.getArea() << std::endl;
    
    // 3. 复制构造函数
    std::cout << "\n3. 复制构造函数:" << std::endl;
    Rectangle rect3 = rect2;  // 调用复制构造函数
    std::cout << "Rectangle 3: " << rect3.getName() 
              << ", Area: " << rect3.getArea() << std::endl;
    
    // 4. 移动构造函数
    std::cout << "\n4. 移动构造函数:" << std::endl;
    Rectangle rect4 = std::move(Rectangle(4.0, 6.0, "Temp"));
    std::cout << "Rectangle 4: " << rect4.getName() 
              << ", Area: " << rect4.getArea() << std::endl;
    
    // 5. 赋值操作符
    std::cout << "\n5. 赋值操作符:" << std::endl;
    Rectangle rect5(2.0, 2.0, "Rect5");
    rect5 = rect2;  // 调用赋值操作符
    std::cout << "Rectangle 5: " << rect5.getName() 
              << ", Area: " << rect5.getArea() << std::endl;
    
    // 6. 静态成员函数
    std::cout << "\n6. 静态成员函数:" << std::endl;
    std::cout << "Total objects created: " << Rectangle::getObjectCount() << std::endl;
    
    // 7. 作用域结束，析构函数自动调用
    std::cout << "\n7. 作用域结束，析构函数调用:" << std::endl;
    
    return 0;
}
```

## 6. 最佳实践

### 6.1 初始化列表使用原则
```cpp
class BestPractice {
private:
    const int id;           // const成员必须用初始化列表
    std::string name;       // 引用成员必须用初始化列表
    std::vector<int> data;  // 复杂对象建议用初始化列表
    
public:
    // ✅ 推荐：使用初始化列表
    BestPractice(int i, const std::string& n) 
        : id(i), name(n), data(100) {
        // 构造函数体
    }
    
    // ❌ 不推荐：在构造函数体中赋值
    BestPractice(int i, const std::string& n) {
        // id = i;  // 错误：const成员不能赋值
        // name = n; // 效率低：先默认构造再赋值
        // data = std::vector<int>(100); // 效率低：先默认构造再赋值
    }
};
```

### 6.2 复制构造函数设计原则
```cpp
class CopyConstructorBestPractice {
private:
    int* data;
    size_t size;
    
public:
    // 构造函数
    CopyConstructorBestPractice(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = 0;
        }
    }
    
    // ✅ 正确的复制构造函数
    CopyConstructorBestPractice(const CopyConstructorBestPractice& other) 
        : size(other.size) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = other.data[i];  // 深拷贝
        }
    }
    
    // ✅ 正确的赋值操作符
    CopyConstructorBestPractice& operator=(const CopyConstructorBestPractice& other) {
        if(this != &other) {  // 自赋值检查
            delete[] data;    // 释放原有资源
            
            size = other.size;
            data = new int[size];
            for(size_t i = 0; i < size; ++i) {
                data[i] = other.data[i];
            }
        }
        return *this;
    }
    
    // 析构函数
    ~CopyConstructorBestPractice() {
        delete[] data;
    }
};
```

## 7. 总结

### 7.1 关键要点
1. **初始化列表**：高效初始化成员变量，const和引用成员必须使用
2. **复制构造函数**：处理对象复制，实现深拷贝
3. **移动构造函数**：C++11新特性，提高性能
4. **RAII原则**：资源获取即初始化

### 7.2 使用建议
- 优先使用初始化列表
- 正确处理动态内存分配
- 实现完整的拷贝语义
- 考虑移动语义优化性能
- 遵循RAII原则管理资源

构造函数和初始化列表是C++面向对象编程的基础，掌握这些概念对编写高质量的C++代码至关重要。
