# 第3周：STL标准库 - 训练题目

## 学习目标
通过实践练习熟练掌握STL标准库的使用，包括容器、迭代器、算法库和函数对象。

## 每日训练题目

### 第1天：序列容器

#### 题目1：vector操作练习
**难度**：★☆☆☆☆

编写程序使用vector完成以下任务：
1. 存储学生成绩并计算统计信息
2. 实现动态数组的基本操作
3. 使用vector进行数据排序和搜索

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

class Student {
private:
    std::string name;
    std::vector<double> scores;

public:
    Student(const std::string& n) : name(n) {}
    
    void addScore(double score) {
        if (score >= 0 && score <= 100) {
            scores.push_back(score);
        }
    }
    
    double getAverage() const {
        if (scores.empty()) return 0.0;
        return std::accumulate(scores.begin(), scores.end(), 0.0) / scores.size();
    }
    
    double getHighestScore() const {
        if (scores.empty()) return 0.0;
        return *std::max_element(scores.begin(), scores.end());
    }
    
    double getLowestScore() const {
        if (scores.empty()) return 0.0;
        return *std::min_element(scores.begin(), scores.end());
    }
    
    void display() const {
        std::cout << "Student: " << name << std::endl;
        std::cout << "Scores: ";
        for (double score : scores) {
            std::cout << score << " ";
        }
        std::cout << std::endl;
        std::cout << "Average: " << getAverage() << std::endl;
        std::cout << "Highest: " << getHighestScore() << std::endl;
        std::cout << "Lowest: " << getLowestScore() << std::endl;
    }
};

int main() {
    // 创建学生对象
    Student student("Alice");
    
    // 添加成绩
    std::vector<double> testScores = {85.5, 92.0, 78.5, 95.0, 88.5};
    for (double score : testScores) {
        student.addScore(score);
    }
    
    student.display();
    
    // 使用vector进行数据操作
    std::vector<int> numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    std::cout << "\nOriginal numbers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 排序
    std::sort(numbers.begin(), numbers.end());
    std::cout << "Sorted numbers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 搜索
    auto it = std::find(numbers.begin(), numbers.end(), 5);
    if (it != numbers.end()) {
        std::cout << "Found 5 at position: " << std::distance(numbers.begin(), it) << std::endl;
    }
    
    // 统计
    int count = std::count_if(numbers.begin(), numbers.end(), 
                             [](int x) { return x > 5; });
    std::cout << "Numbers greater than 5: " << count << std::endl;
    
    return 0;
}
```

#### 题目2：list操作练习
**难度**：★★☆☆☆

编写程序使用list完成以下任务：
1. 实现简单的链表操作
2. 使用list进行数据插入和删除
3. 实现链表的合并和分割

**要求**：
```cpp
#include <iostream>
#include <list>
#include <algorithm>

template<typename T>
class LinkedList {
private:
    std::list<T> data;

public:
    void insertAtBeginning(const T& value) {
        data.push_front(value);
    }
    
    void insertAtEnd(const T& value) {
        data.push_back(value);
    }
    
    void insertAtPosition(size_t pos, const T& value) {
        auto it = data.begin();
        std::advance(it, pos);
        data.insert(it, value);
    }
    
    void removeFirst() {
        if (!data.empty()) {
            data.pop_front();
        }
    }
    
    void removeLast() {
        if (!data.empty()) {
            data.pop_back();
        }
    }
    
    void removeValue(const T& value) {
        data.remove(value);
    }
    
    void removeAll(const T& value) {
        data.remove(value);
    }
    
    bool contains(const T& value) const {
        return std::find(data.begin(), data.end(), value) != data.end();
    }
    
    size_t size() const {
        return data.size();
    }
    
    bool empty() const {
        return data.empty();
    }
    
    void display() const {
        std::cout << "List: ";
        for (const auto& element : data) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
    
    void reverse() {
        data.reverse();
    }
    
    void sort() {
        data.sort();
    }
    
    void unique() {
        data.unique();
    }
    
    void merge(LinkedList& other) {
        data.merge(other.data);
    }
    
    void splice(size_t pos, LinkedList& other) {
        auto it = data.begin();
        std::advance(it, pos);
        data.splice(it, other.data);
    }
};

int main() {
    LinkedList<int> list1;
    LinkedList<int> list2;
    
    // 测试基本操作
    std::cout << "Testing basic operations:" << std::endl;
    list1.insertAtEnd(1);
    list1.insertAtEnd(2);
    list1.insertAtEnd(3);
    list1.insertAtBeginning(0);
    list1.insertAtPosition(2, 1.5);
    
    list1.display();
    
    // 测试删除操作
    std::cout << "\nTesting remove operations:" << std::endl;
    list1.removeFirst();
    list1.removeLast();
    list1.removeValue(2);
    
    list1.display();
    
    // 测试查找
    std::cout << "\nTesting search:" << std::endl;
    std::cout << "Contains 1: " << list1.contains(1) << std::endl;
    std::cout << "Contains 5: " << list1.contains(5) << std::endl;
    
    // 测试排序和去重
    std::cout << "\nTesting sort and unique:" << std::endl;
    list1.insertAtEnd(3);
    list1.insertAtEnd(1);
    list1.insertAtEnd(2);
    list1.display();
    
    list1.sort();
    list1.display();
    
    list1.unique();
    list1.display();
    
    // 测试合并
    std::cout << "\nTesting merge:" << std::endl;
    list2.insertAtEnd(4);
    list2.insertAtEnd(5);
    list2.insertAtEnd(6);
    
    std::cout << "List1: ";
    list1.display();
    std::cout << "List2: ";
    list2.display();
    
    list1.merge(list2);
    std::cout << "After merge:" << std::endl;
    list1.display();
    list2.display();
    
    return 0;
}
```

#### 题目3：deque操作练习
**难度**：★★☆☆☆

编写程序使用deque完成以下任务：
1. 实现双端队列的基本操作
2. 使用deque实现滑动窗口
3. 实现队列的批量操作

**要求**：
```cpp
#include <iostream>
#include <deque>
#include <algorithm>

template<typename T>
class DoubleEndedQueue {
private:
    std::deque<T> data;

public:
    void pushFront(const T& value) {
        data.push_front(value);
    }
    
    void pushBack(const T& value) {
        data.push_back(value);
    }
    
    void popFront() {
        if (!data.empty()) {
            data.pop_front();
        }
    }
    
    void popBack() {
        if (!data.empty()) {
            data.pop_back();
        }
    }
    
    T& front() {
        return data.front();
    }
    
    const T& front() const {
        return data.front();
    }
    
    T& back() {
        return data.back();
    }
    
    const T& back() const {
        return data.back();
    }
    
    T& operator[](size_t index) {
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return data.size();
    }
    
    bool empty() const {
        return data.empty();
    }
    
    void display() const {
        std::cout << "Deque: ";
        for (const auto& element : data) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
    
    void clear() {
        data.clear();
    }
    
    void resize(size_t newSize) {
        data.resize(newSize);
    }
    
    void insert(size_t pos, const T& value) {
        auto it = data.begin();
        std::advance(it, pos);
        data.insert(it, value);
    }
    
    void erase(size_t pos) {
        auto it = data.begin();
        std::advance(it, pos);
        data.erase(it);
    }
};

// 滑动窗口类
template<typename T>
class SlidingWindow {
private:
    std::deque<T> window;
    size_t maxSize;

public:
    SlidingWindow(size_t size) : maxSize(size) {}
    
    void add(const T& value) {
        if (window.size() >= maxSize) {
            window.pop_front();
        }
        window.push_back(value);
    }
    
    T getMax() const {
        if (window.empty()) {
            throw std::runtime_error("Window is empty");
        }
        return *std::max_element(window.begin(), window.end());
    }
    
    T getMin() const {
        if (window.empty()) {
            throw std::runtime_error("Window is empty");
        }
        return *std::min_element(window.begin(), window.end());
    }
    
    double getAverage() const {
        if (window.empty()) {
            throw std::runtime_error("Window is empty");
        }
        T sum = std::accumulate(window.begin(), window.end(), T{});
        return static_cast<double>(sum) / window.size();
    }
    
    void display() const {
        std::cout << "Window: ";
        for (const auto& element : window) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
    
    size_t size() const {
        return window.size();
    }
    
    bool empty() const {
        return window.empty();
    }
};

int main() {
    // 测试双端队列
    std::cout << "Testing DoubleEndedQueue:" << std::endl;
    DoubleEndedQueue<int> dq;
    
    dq.pushBack(1);
    dq.pushBack(2);
    dq.pushBack(3);
    dq.pushFront(0);
    dq.pushFront(-1);
    
    dq.display();
    
    std::cout << "Front: " << dq.front() << std::endl;
    std::cout << "Back: " << dq.back() << std::endl;
    std::cout << "Element at index 2: " << dq[2] << std::endl;
    
    dq.popFront();
    dq.popBack();
    dq.display();
    
    // 测试滑动窗口
    std::cout << "\nTesting SlidingWindow:" << std::endl;
    SlidingWindow<int> window(3);
    
    std::vector<int> data = {1, 3, -1, -3, 5, 3, 6, 7};
    
    for (int value : data) {
        window.add(value);
        window.display();
        
        if (window.size() == 3) {
            std::cout << "Max: " << window.getMax() 
                      << ", Min: " << window.getMin()
                      << ", Average: " << window.getAverage() << std::endl;
        }
        std::cout << std::endl;
    }
    
    return 0;
}
```

### 第2天：关联容器

#### 题目4：map操作练习
**难度**：★★☆☆☆

编写程序使用map完成以下任务：
1. 实现单词计数器
2. 使用map存储学生信息
3. 实现map的查找和排序功能

**要求**：
```cpp
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>

class WordCounter {
private:
    std::map<std::string, int> wordCount;

public:
    void addText(const std::string& text) {
        std::istringstream iss(text);
        std::string word;
        
        while (iss >> word) {
            // 转换为小写
            std::transform(word.begin(), word.end(), word.begin(), ::tolower);
            
            // 移除标点符号
            word.erase(std::remove_if(word.begin(), word.end(), 
                                    [](char c) { return !std::isalnum(c); }), 
                      word.end());
            
            if (!word.empty()) {
                wordCount[word]++;
            }
        }
    }
    
    void display() const {
        std::cout << "Word Count:" << std::endl;
        for (const auto& pair : wordCount) {
            std::cout << pair.first << ": " << pair.second << std::endl;
        }
    }
    
    void displaySortedByCount() const {
        std::vector<std::pair<std::string, int>> sortedWords;
        for (const auto& pair : wordCount) {
            sortedWords.push_back(pair);
        }
        
        std::sort(sortedWords.begin(), sortedWords.end(),
                  [](const std::pair<std::string, int>& a, 
                     const std::pair<std::string, int>& b) {
                      return a.second > b.second;
                  });
        
        std::cout << "Words sorted by count:" << std::endl;
        for (const auto& pair : sortedWords) {
            std::cout << pair.first << ": " << pair.second << std::endl;
        }
    }
    
    int getCount(const std::string& word) const {
        auto it = wordCount.find(word);
        return (it != wordCount.end()) ? it->second : 0;
    }
    
    size_t getUniqueWordCount() const {
        return wordCount.size();
    }
};

class StudentDatabase {
private:
    std::map<int, std::string> students;
    std::map<std::string, int> nameToId;

public:
    void addStudent(int id, const std::string& name) {
        students[id] = name;
        nameToId[name] = id;
    }
    
    std::string getStudentName(int id) const {
        auto it = students.find(id);
        return (it != students.end()) ? it->second : "Not found";
    }
    
    int getStudentId(const std::string& name) const {
        auto it = nameToId.find(name);
        return (it != nameToId.end()) ? it->second : -1;
    }
    
    void displayAll() const {
        std::cout << "Student Database:" << std::endl;
        for (const auto& pair : students) {
            std::cout << "ID: " << pair.first << ", Name: " << pair.second << std::endl;
        }
    }
    
    void displaySortedByName() const {
        std::cout << "Students sorted by name:" << std::endl;
        for (const auto& pair : nameToId) {
            std::cout << "Name: " << pair.first << ", ID: " << pair.second << std::endl;
        }
    }
    
    bool removeStudent(int id) {
        auto it = students.find(id);
        if (it != students.end()) {
            nameToId.erase(it->second);
            students.erase(it);
            return true;
        }
        return false;
    }
    
    size_t getStudentCount() const {
        return students.size();
    }
};

int main() {
    // 测试单词计数器
    std::cout << "Testing WordCounter:" << std::endl;
    WordCounter counter;
    
    std::string text = "The quick brown fox jumps over the lazy dog. The fox is quick and brown.";
    counter.addText(text);
    
    counter.display();
    std::cout << std::endl;
    counter.displaySortedByCount();
    
    std::cout << "\nUnique word count: " << counter.getUniqueWordCount() << std::endl;
    std::cout << "Count of 'the': " << counter.getCount("the") << std::endl;
    
    // 测试学生数据库
    std::cout << "\nTesting StudentDatabase:" << std::endl;
    StudentDatabase db;
    
    db.addStudent(1001, "Alice");
    db.addStudent(1002, "Bob");
    db.addStudent(1003, "Charlie");
    db.addStudent(1004, "David");
    
    db.displayAll();
    std::cout << std::endl;
    db.displaySortedByName();
    
    std::cout << "\nStudent with ID 1002: " << db.getStudentName(1002) << std::endl;
    std::cout << "ID of Charlie: " << db.getStudentId("Charlie") << std::endl;
    
    db.removeStudent(1003);
    std::cout << "\nAfter removing student 1003:" << std::endl;
    db.displayAll();
    
    return 0;
}
```

#### 题目5：set操作练习
**难度**：★★☆☆☆

编写程序使用set完成以下任务：
1. 实现集合的基本操作
2. 使用set进行数据去重和排序
3. 实现集合的交集、并集、差集运算

**要求**：
```cpp
#include <iostream>
#include <set>
#include <vector>
#include <algorithm>

template<typename T>
class SetOperations {
private:
    std::set<T> data;

public:
    void insert(const T& value) {
        data.insert(value);
    }
    
    void insert(const std::vector<T>& values) {
        for (const T& value : values) {
            data.insert(value);
        }
    }
    
    bool contains(const T& value) const {
        return data.find(value) != data.end();
    }
    
    void remove(const T& value) {
        data.erase(value);
    }
    
    size_t size() const {
        return data.size();
    }
    
    bool empty() const {
        return data.empty();
    }
    
    void display() const {
        std::cout << "Set: ";
        for (const auto& element : data) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
    
    void clear() {
        data.clear();
    }
    
    // 集合运算
    SetOperations<T> unionWith(const SetOperations<T>& other) const {
        SetOperations<T> result;
        result.data = data;
        result.data.insert(other.data.begin(), other.data.end());
        return result;
    }
    
    SetOperations<T> intersectionWith(const SetOperations<T>& other) const {
        SetOperations<T> result;
        std::set_intersection(data.begin(), data.end(),
                            other.data.begin(), other.data.end(),
                            std::inserter(result.data, result.data.begin()));
        return result;
    }
    
    SetOperations<T> differenceWith(const SetOperations<T>& other) const {
        SetOperations<T> result;
        std::set_difference(data.begin(), data.end(),
                           other.data.begin(), other.data.end(),
                           std::inserter(result.data, result.data.begin()));
        return result;
    }
    
    SetOperations<T> symmetricDifferenceWith(const SetOperations<T>& other) const {
        SetOperations<T> result;
        std::set_symmetric_difference(data.begin(), data.end(),
                                    other.data.begin(), other.data.end(),
                                    std::inserter(result.data, result.data.begin()));
        return result;
    }
    
    bool isSubsetOf(const SetOperations<T>& other) const {
        return std::includes(other.data.begin(), other.data.end(),
                           data.begin(), data.end());
    }
    
    bool isSupersetOf(const SetOperations<T>& other) const {
        return std::includes(data.begin(), data.end(),
                           other.data.begin(), other.data.end());
    }
    
    bool isDisjointWith(const SetOperations<T>& other) const {
        return intersectionWith(other).empty();
    }
};

int main() {
    // 测试集合操作
    std::cout << "Testing SetOperations:" << std::endl;
    
    SetOperations<int> set1;
    SetOperations<int> set2;
    
    // 添加元素
    std::vector<int> data1 = {1, 2, 3, 4, 5};
    std::vector<int> data2 = {4, 5, 6, 7, 8};
    
    set1.insert(data1);
    set2.insert(data2);
    
    std::cout << "Set1: ";
    set1.display();
    std::cout << "Set2: ";
    set2.display();
    
    // 测试集合运算
    std::cout << "\nSet Operations:" << std::endl;
    
    auto unionSet = set1.unionWith(set2);
    std::cout << "Union: ";
    unionSet.display();
    
    auto intersectionSet = set1.intersectionWith(set2);
    std::cout << "Intersection: ";
    intersectionSet.display();
    
    auto differenceSet = set1.differenceWith(set2);
    std::cout << "Set1 - Set2: ";
    differenceSet.display();
    
    auto symmetricDiffSet = set1.symmetricDifferenceWith(set2);
    std::cout << "Symmetric Difference: ";
    symmetricDiffSet.display();
    
    // 测试集合关系
    std::cout << "\nSet Relationships:" << std::endl;
    std::cout << "Set1 is subset of Set2: " << set1.isSubsetOf(set2) << std::endl;
    std::cout << "Set1 is superset of Set2: " << set1.isSupersetOf(set2) << std::endl;
    std::cout << "Set1 is disjoint with Set2: " << set1.isDisjointWith(set2) << std::endl;
    
    // 测试字符串集合
    std::cout << "\nTesting with strings:" << std::endl;
    SetOperations<std::string> stringSet1;
    SetOperations<std::string> stringSet2;
    
    stringSet1.insert({"apple", "banana", "cherry"});
    stringSet2.insert({"banana", "cherry", "date"});
    
    std::cout << "String Set1: ";
    stringSet1.display();
    std::cout << "String Set2: ";
    stringSet2.display();
    
    auto stringUnion = stringSet1.unionWith(stringSet2);
    std::cout << "String Union: ";
    stringUnion.display();
    
    return 0;
}
```

#### 题目6：unordered_map操作练习
**难度**：★★☆☆☆

编写程序使用unordered_map完成以下任务：
1. 实现缓存系统
2. 使用unordered_map进行快速查找
3. 实现LRU缓存

**要求**：
```cpp
#include <iostream>
#include <unordered_map>
#include <list>
#include <string>

// 简单缓存系统
template<typename K, typename V>
class SimpleCache {
private:
    std::unordered_map<K, V> cache;
    size_t maxSize;

public:
    SimpleCache(size_t size) : maxSize(size) {}
    
    void put(const K& key, const V& value) {
        if (cache.size() >= maxSize) {
            // 简单的FIFO策略：删除第一个元素
            auto it = cache.begin();
            cache.erase(it);
        }
        cache[key] = value;
    }
    
    bool get(const K& key, V& value) const {
        auto it = cache.find(key);
        if (it != cache.end()) {
            value = it->second;
            return true;
        }
        return false;
    }
    
    bool contains(const K& key) const {
        return cache.find(key) != cache.end();
    }
    
    void remove(const K& key) {
        cache.erase(key);
    }
    
    size_t size() const {
        return cache.size();
    }
    
    void display() const {
        std::cout << "Cache contents:" << std::endl;
        for (const auto& pair : cache) {
            std::cout << pair.first << " -> " << pair.second << std::endl;
        }
    }
    
    void clear() {
        cache.clear();
    }
};

// LRU缓存
template<typename K, typename V>
class LRUCache {
private:
    size_t capacity;
    std::list<std::pair<K, V>> items;
    std::unordered_map<K, typename std::list<std::pair<K, V>>::iterator> keyMap;

public:
    LRUCache(size_t cap) : capacity(cap) {}
    
    void put(const K& key, const V& value) {
        auto it = keyMap.find(key);
        
        if (it != keyMap.end()) {
            // 更新现有值
            it->second->second = value;
            // 移动到列表前端
            items.splice(items.begin(), items, it->second);
        } else {
            // 添加新值
            if (items.size() >= capacity) {
                // 删除最久未使用的元素
                auto last = items.back();
                keyMap.erase(last.first);
                items.pop_back();
            }
            
            items.push_front({key, value});
            keyMap[key] = items.begin();
        }
    }
    
    bool get(const K& key, V& value) {
        auto it = keyMap.find(key);
        if (it != keyMap.end()) {
            value = it->second->second;
            // 移动到列表前端
            items.splice(items.begin(), items, it->second);
            return true;
        }
        return false;
    }
    
    bool contains(const K& key) const {
        return keyMap.find(key) != keyMap.end();
    }
    
    size_t size() const {
        return items.size();
    }
    
    void display() const {
        std::cout << "LRU Cache (most recent first):" << std::endl;
        for (const auto& pair : items) {
            std::cout << pair.first << " -> " << pair.second << std::endl;
        }
    }
};

int main() {
    // 测试简单缓存
    std::cout << "Testing SimpleCache:" << std::endl;
    SimpleCache<std::string, int> cache(3);
    
    cache.put("apple", 5);
    cache.put("banana", 3);
    cache.put("cherry", 8);
    
    cache.display();
    
    int value;
    if (cache.get("banana", value)) {
        std::cout << "Found banana: " << value << std::endl;
    }
    
    cache.put("date", 2);  // 这会删除apple
    std::cout << "\nAfter adding date:" << std::endl;
    cache.display();
    
    // 测试LRU缓存
    std::cout << "\nTesting LRUCache:" << std::endl;
    LRUCache<std::string, int> lruCache(3);
    
    lruCache.put("apple", 5);
    lruCache.put("banana", 3);
    lruCache.put("cherry", 8);
    
    lruCache.display();
    
    // 访问banana，使其成为最近使用的
    if (lruCache.get("banana", value)) {
        std::cout << "Found banana: " << value << std::endl;
    }
    
    std::cout << "\nAfter accessing banana:" << std::endl;
    lruCache.display();
    
    // 添加新元素，应该删除最久未使用的
    lruCache.put("date", 2);
    std::cout << "\nAfter adding date:" << std::endl;
    lruCache.display();
    
    return 0;
}
```

### 第3天：迭代器

#### 题目7：迭代器操作练习
**难度**：★★☆☆☆

编写程序演示迭代器的使用：
1. 不同容器的迭代器特性
2. 迭代器的算术运算
3. 使用迭代器修改容器元素

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <algorithm>

void demonstrateVectorIterators() {
    std::cout << "=== Vector Iterators ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // 前向迭代器
    std::cout << "Forward iteration: ";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 反向迭代器
    std::cout << "Reverse iteration: ";
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 常量迭代器
    std::cout << "Const iteration: ";
    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 迭代器算术
    auto it = vec.begin();
    std::cout << "Element at begin(): " << *it << std::endl;
    std::cout << "Element at begin() + 2: " << *(it + 2) << std::endl;
    std::cout << "Element at end() - 1: " << *(vec.end() - 1) << std::endl;
    
    // 使用迭代器修改元素
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        *it *= 2;
    }
    std::cout << "After doubling: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

void demonstrateListIterators() {
    std::cout << "\n=== List Iterators ===" << std::endl;
    std::list<int> lst = {1, 2, 3, 4, 5};
    
    // 双向迭代器
    std::cout << "Forward iteration: ";
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 反向迭代器
    std::cout << "Reverse iteration: ";
    for (auto it = lst.rbegin(); it != lst.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 双向移动
    auto it = lst.begin();
    ++it;  // 前进
    --it;  // 后退
    std::cout << "Element after ++ and --: " << *it << std::endl;
    
    // 使用迭代器插入和删除
    it = lst.begin();
    std::advance(it, 2);  // 移动到第3个位置
    lst.insert(it, 99);   // 在位置2插入99
    
    std::cout << "After inserting 99 at position 2: ";
    for (const auto& element : lst) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    it = lst.begin();
    std::advance(it, 3);
    lst.erase(it);  // 删除位置3的元素
    
    std::cout << "After erasing element at position 3: ";
    for (const auto& element : lst) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

void demonstrateSetIterators() {
    std::cout << "\n=== Set Iterators ===" << std::endl;
    std::set<int> s = {5, 2, 8, 1, 9, 3};
    
    // 前向迭代器（自动排序）
    std::cout << "Set iteration (sorted): ";
    for (auto it = s.begin(); it != s.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 反向迭代器
    std::cout << "Reverse iteration: ";
    for (auto it = s.rbegin(); it != s.rend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    
    // 查找迭代器
    auto it = s.find(5);
    if (it != s.end()) {
        std::cout << "Found 5: " << *it << std::endl;
    }
    
    // 使用迭代器删除元素
    it = s.find(3);
    if (it != s.end()) {
        s.erase(it);
        std::cout << "After erasing 3: ";
        for (const auto& element : s) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
}

void demonstrateMapIterators() {
    std::cout << "\n=== Map Iterators ===" << std::endl;
    std::map<std::string, int> m = {{"apple", 5}, {"banana", 3}, {"cherry", 8}};
    
    // 前向迭代器
    std::cout << "Map iteration: ";
    for (auto it = m.begin(); it != m.end(); ++it) {
        std::cout << it->first << ":" << it->second << " ";
    }
    std::cout << std::endl;
    
    // 使用迭代器修改值
    for (auto it = m.begin(); it != m.end(); ++it) {
        it->second *= 2;
    }
    
    std::cout << "After doubling values: ";
    for (const auto& pair : m) {
        std::cout << pair.first << ":" << pair.second << " ";
    }
    std::cout << std::endl;
    
    // 查找迭代器
    auto it = m.find("banana");
    if (it != m.end()) {
        std::cout << "Found banana: " << it->second << std::endl;
    }
}

void demonstrateIteratorAlgorithms() {
    std::cout << "\n=== Iterator Algorithms ===" << std::endl;
    std::vector<int> vec = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    std::cout << "Original vector: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用迭代器进行排序
    std::sort(vec.begin(), vec.end());
    std::cout << "Sorted vector: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用迭代器查找
    auto it = std::find(vec.begin(), vec.end(), 5);
    if (it != vec.end()) {
        std::cout << "Found 5 at position: " << std::distance(vec.begin(), it) << std::endl;
    }
    
    // 使用迭代器计数
    int count = std::count_if(vec.begin(), vec.end(), 
                             [](int x) { return x > 5; });
    std::cout << "Elements greater than 5: " << count << std::endl;
    
    // 使用迭代器变换
    std::vector<int> squares(vec.size());
    std::transform(vec.begin(), vec.end(), squares.begin(),
                   [](int x) { return x * x; });
    
    std::cout << "Squares: ";
    for (const auto& element : squares) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

int main() {
    demonstrateVectorIterators();
    demonstrateListIterators();
    demonstrateSetIterators();
    demonstrateMapIterators();
    demonstrateIteratorAlgorithms();
    
    return 0;
}
```

### 第4天：算法库

#### 题目8：查找和排序算法
**难度**：★★☆☆☆

编写程序使用STL算法实现查找和排序功能：
1. 各种查找算法
2. 排序算法和自定义比较
3. 二分查找和范围查找

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <functional>

void demonstrateSearchAlgorithms() {
    std::cout << "=== Search Algorithms ===" << std::endl;
    std::vector<int> vec = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    
    // find - 线性查找
    auto it = std::find(vec.begin(), vec.end(), 7);
    if (it != vec.end()) {
        std::cout << "Found 7 at position: " << std::distance(vec.begin(), it) << std::endl;
    }
    
    // find_if - 条件查找
    it = std::find_if(vec.begin(), vec.end(), [](int x) { return x > 10; });
    if (it != vec.end()) {
        std::cout << "First element > 10: " << *it << std::endl;
    }
    
    // find_if_not - 反向条件查找
    it = std::find_if_not(vec.begin(), vec.end(), [](int x) { return x % 2 == 1; });
    if (it != vec.end()) {
        std::cout << "First even element: " << *it << std::endl;
    } else {
        std::cout << "No even elements found" << std::endl;
    }
    
    // binary_search - 二分查找（需要排序）
    bool found = std::binary_search(vec.begin(), vec.end(), 9);
    std::cout << "Binary search for 9: " << (found ? "Found" : "Not found") << std::endl;
    
    // lower_bound - 第一个不小于给定值的元素
    it = std::lower_bound(vec.begin(), vec.end(), 8);
    std::cout << "First element >= 8: " << *it << std::endl;
    
    // upper_bound - 第一个大于给定值的元素
    it = std::upper_bound(vec.begin(), vec.end(), 8);
    std::cout << "First element > 8: " << *it << std::endl;
    
    // equal_range - 等于给定值的范围
    auto range = std::equal_range(vec.begin(), vec.end(), 9);
    std::cout << "Range for 9: [" << std::distance(vec.begin(), range.first) 
              << ", " << std::distance(vec.begin(), range.second) << ")" << std::endl;
}

void demonstrateSortingAlgorithms() {
    std::cout << "\n=== Sorting Algorithms ===" << std::endl;
    std::vector<int> vec = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // sort - 排序
    std::sort(vec.begin(), vec.end());
    std::cout << "Sorted (ascending): ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // sort with custom comparator
    std::sort(vec.begin(), vec.end(), std::greater<int>());
    std::cout << "Sorted (descending): ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // partial_sort - 部分排序
    std::vector<int> vec2 = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    std::partial_sort(vec2.begin(), vec2.begin() + 3, vec2.end());
    std::cout << "Partial sort (first 3): ";
    for (const auto& element : vec2) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // nth_element - 第n个元素
    std::vector<int> vec3 = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    std::nth_element(vec3.begin(), vec3.begin() + 4, vec3.end());
    std::cout << "Nth element (5th): " << vec3[4] << std::endl;
    
    // is_sorted - 检查是否已排序
    std::vector<int> sorted = {1, 2, 3, 4, 5};
    std::vector<int> unsorted = {1, 3, 2, 4, 5};
    
    std::cout << "Is {1,2,3,4,5} sorted: " << std::is_sorted(sorted.begin(), sorted.end()) << std::endl;
    std::cout << "Is {1,3,2,4,5} sorted: " << std::is_sorted(unsorted.begin(), unsorted.end()) << std::endl;
}

void demonstrateStringAlgorithms() {
    std::cout << "\n=== String Algorithms ===" << std::endl;
    std::vector<std::string> words = {"apple", "banana", "cherry", "date", "elderberry"};
    
    std::cout << "Original words: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 按长度排序
    std::sort(words.begin(), words.end(), 
              [](const std::string& a, const std::string& b) {
                  return a.length() < b.length();
              });
    
    std::cout << "Sorted by length: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 按字母顺序排序
    std::sort(words.begin(), words.end());
    std::cout << "Sorted alphabetically: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 查找特定长度的单词
    auto it = std::find_if(words.begin(), words.end(),
                           [](const std::string& word) { return word.length() == 5; });
    if (it != words.end()) {
        std::cout << "First 5-letter word: " << *it << std::endl;
    }
    
    // 统计特定长度的单词
    int count = std::count_if(words.begin(), words.end(),
                              [](const std::string& word) { return word.length() > 5; });
    std::cout << "Words longer than 5 characters: " << count << std::endl;
}

void demonstrateRangeAlgorithms() {
    std::cout << "\n=== Range Algorithms ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 查找子序列
    std::vector<int> subseq = {3, 4, 5};
    auto it = std::search(vec.begin(), vec.end(), subseq.begin(), subseq.end());
    if (it != vec.end()) {
        std::cout << "Found subsequence {3,4,5} at position: " 
                  << std::distance(vec.begin(), it) << std::endl;
    }
    
    // 查找重复元素
    std::vector<int> vec2 = {1, 2, 2, 3, 3, 3, 4, 5};
    auto it2 = std::adjacent_find(vec2.begin(), vec2.end());
    if (it2 != vec2.end()) {
        std::cout << "First adjacent duplicate: " << *it2 << std::endl;
    }
    
    // 查找第一个不满足条件的元素
    auto it3 = std::find_if_not(vec.begin(), vec.end(), 
                                [](int x) { return x < 5; });
    if (it3 != vec.end()) {
        std::cout << "First element >= 5: " << *it3 << std::endl;
    }
    
    // 查找最后一个满足条件的元素
    auto it4 = std::find_if(vec.rbegin(), vec.rend(), 
                            [](int x) { return x < 5; });
    if (it4 != vec.rend()) {
        std::cout << "Last element < 5: " << *it4 << std::endl;
    }
}

int main() {
    demonstrateSearchAlgorithms();
    demonstrateSortingAlgorithms();
    demonstrateStringAlgorithms();
    demonstrateRangeAlgorithms();
    
    return 0;
}
```

### 第5天：变换和数值算法

#### 题目9：变换算法练习
**难度**：★★☆☆☆

编写程序使用变换算法实现数据处理：
1. 数据变换和映射
2. 条件变换和过滤
3. 数据组合和归约

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
#include <functional>

void demonstrateTransformAlgorithms() {
    std::cout << "=== Transform Algorithms ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // transform - 单输入变换
    std::vector<int> squares(vec.size());
    std::transform(vec.begin(), vec.end(), squares.begin(),
                   [](int x) { return x * x; });
    
    std::cout << "Squares: ";
    for (const auto& element : squares) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // transform - 双输入变换
    std::vector<int> vec2 = {2, 3, 4, 5, 6};
    std::vector<int> sums(vec.size());
    std::transform(vec.begin(), vec.end(), vec2.begin(), sums.begin(),
                   [](int a, int b) { return a + b; });
    
    std::cout << "Sums: ";
    for (const auto& element : sums) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // transform - 字符串变换
    std::vector<std::string> words = {"hello", "world", "c++", "programming"};
    std::vector<std::string> upperWords(words.size());
    
    std::transform(words.begin(), words.end(), upperWords.begin(),
                   [](const std::string& word) {
                       std::string result = word;
                       std::transform(result.begin(), result.end(), result.begin(), ::toupper);
                       return result;
                   });
    
    std::cout << "Upper case words: ";
    for (const auto& word : upperWords) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
}

void demonstrateFilteringAlgorithms() {
    std::cout << "\n=== Filtering Algorithms ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // copy_if - 条件复制
    std::vector<int> evens;
    std::copy_if(vec.begin(), vec.end(), std::back_inserter(evens),
                 [](int x) { return x % 2 == 0; });
    
    std::cout << "Even numbers: ";
    for (const auto& element : evens) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // remove_if - 移除满足条件的元素
    std::vector<int> vec2 = vec;
    auto it = std::remove_if(vec2.begin(), vec2.end(),
                             [](int x) { return x > 5; });
    vec2.erase(it, vec2.end());
    
    std::cout << "Numbers <= 5: ";
    for (const auto& element : vec2) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // partition - 分区
    std::vector<int> vec3 = vec;
    auto it2 = std::partition(vec3.begin(), vec3.end(),
                              [](int x) { return x % 2 == 0; });
    
    std::cout << "Partitioned (evens first): ";
    for (const auto& element : vec3) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // stable_partition - 稳定分区
    std::vector<int> vec4 = vec;
    auto it3 = std::stable_partition(vec4.begin(), vec4.end(),
                                    [](int x) { return x % 2 == 0; });
    
    std::cout << "Stable partitioned: ";
    for (const auto& element : vec4) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

void demonstrateNumericAlgorithms() {
    std::cout << "\n=== Numeric Algorithms ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // accumulate - 累加
    int sum = std::accumulate(vec.begin(), vec.end(), 0);
    std::cout << "Sum: " << sum << std::endl;
    
    // accumulate with custom operation
    int product = std::accumulate(vec.begin(), vec.end(), 1,
                                 [](int a, int b) { return a * b; });
    std::cout << "Product: " << product << std::endl;
    
    // partial_sum - 部分和
    std::vector<int> partialSums(vec.size());
    std::partial_sum(vec.begin(), vec.end(), partialSums.begin());
    
    std::cout << "Partial sums: ";
    for (const auto& element : partialSums) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // inner_product - 内积
    std::vector<int> vec2 = {2, 3, 4, 5, 6};
    int innerProduct = std::inner_product(vec.begin(), vec.end(), vec2.begin(), 0);
    std::cout << "Inner product: " << innerProduct << std::endl;
    
    // adjacent_difference - 相邻差
    std::vector<int> differences(vec.size());
    std::adjacent_difference(vec.begin(), vec.end(), differences.begin());
    
    std::cout << "Adjacent differences: ";
    for (const auto& element : differences) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

void demonstrateComplexTransformations() {
    std::cout << "\n=== Complex Transformations ===" << std::endl;
    std::vector<std::string> words = {"hello", "world", "c++", "programming", "language"};
    
    std::cout << "Original words: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 过滤长单词并转换为大写
    std::vector<std::string> longUpperWords;
    std::copy_if(words.begin(), words.end(), std::back_inserter(longUpperWords),
                 [](const std::string& word) { return word.length() > 3; });
    
    std::transform(longUpperWords.begin(), longUpperWords.end(), longUpperWords.begin(),
                   [](const std::string& word) {
                       std::string result = word;
                       std::transform(result.begin(), result.end(), result.begin(), ::toupper);
                       return result;
                   });
    
    std::cout << "Long words in upper case: ";
    for (const auto& word : longUpperWords) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 计算单词长度
    std::vector<size_t> lengths(words.size());
    std::transform(words.begin(), words.end(), lengths.begin(),
                   [](const std::string& word) { return word.length(); });
    
    std::cout << "Word lengths: ";
    for (const auto& length : lengths) {
        std::cout << length << " ";
    }
    std::cout << std::endl;
    
    // 计算总字符数
    size_t totalChars = std::accumulate(lengths.begin(), lengths.end(), 0);
    std::cout << "Total characters: " << totalChars << std::endl;
    
    // 查找最长单词
    auto maxIt = std::max_element(words.begin(), words.end(),
                                  [](const std::string& a, const std::string& b) {
                                      return a.length() < b.length();
                                  });
    std::cout << "Longest word: " << *maxIt << std::endl;
}

int main() {
    demonstrateTransformAlgorithms();
    demonstrateFilteringAlgorithms();
    demonstrateNumericAlgorithms();
    demonstrateComplexTransformations();
    
    return 0;
}
```

### 第6天：函数对象

#### 题目10：函数对象练习
**难度**：★★☆☆☆

编写程序使用函数对象实现数据处理：
1. 预定义函数对象
2. 自定义函数对象
3. lambda表达式

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <string>
#include <map>

void demonstratePredefinedFunctionObjects() {
    std::cout << "=== Predefined Function Objects ===" << std::endl;
    std::vector<int> vec = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用预定义函数对象排序
    std::sort(vec.begin(), vec.end(), std::greater<int>());
    std::cout << "Sorted (descending): ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用预定义函数对象查找
    auto it = std::find_if(vec.begin(), vec.end(), std::bind(std::equal_to<int>(), std::placeholders::_1, 5));
    if (it != vec.end()) {
        std::cout << "Found 5 at position: " << std::distance(vec.begin(), it) << std::endl;
    }
    
    // 使用预定义函数对象计数
    int count = std::count_if(vec.begin(), vec.end(), std::bind(std::greater<int>(), std::placeholders::_1, 5));
    std::cout << "Elements greater than 5: " << count << std::endl;
    
    // 使用预定义函数对象变换
    std::vector<int> negated(vec.size());
    std::transform(vec.begin(), vec.end(), negated.begin(), std::negate<int>());
    
    std::cout << "Negated: ";
    for (const auto& element : negated) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

// 自定义函数对象
class Square {
public:
    int operator()(int x) const {
        return x * x;
    }
};

class IsEven {
public:
    bool operator()(int x) const {
        return x % 2 == 0;
    }
};

class IsPrime {
public:
    bool operator()(int x) const {
        if (x <= 1) return false;
        if (x <= 3) return true;
        if (x % 2 == 0 || x % 3 == 0) return false;
        
        for (int i = 5; i * i <= x; i += 6) {
            if (x % i == 0 || x % (i + 2) == 0) {
                return false;
            }
        }
        return true;
    }
};

class StringLengthComparator {
public:
    bool operator()(const std::string& a, const std::string& b) const {
        return a.length() < b.length();
    }
};

void demonstrateCustomFunctionObjects() {
    std::cout << "\n=== Custom Function Objects ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用自定义函数对象计算平方
    Square square;
    std::vector<int> squares(vec.size());
    std::transform(vec.begin(), vec.end(), squares.begin(), square);
    
    std::cout << "Squares: ";
    for (const auto& element : squares) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用自定义函数对象过滤偶数
    IsEven isEven;
    std::vector<int> evens;
    std::copy_if(vec.begin(), vec.end(), std::back_inserter(evens), isEven);
    
    std::cout << "Even numbers: ";
    for (const auto& element : evens) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用自定义函数对象过滤素数
    IsPrime isPrime;
    std::vector<int> primes;
    std::copy_if(vec.begin(), vec.end(), std::back_inserter(primes), isPrime);
    
    std::cout << "Prime numbers: ";
    for (const auto& element : primes) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用自定义函数对象排序字符串
    std::vector<std::string> words = {"hello", "world", "c++", "programming", "language"};
    StringLengthComparator lengthComp;
    std::sort(words.begin(), words.end(), lengthComp);
    
    std::cout << "Words sorted by length: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
}

void demonstrateLambdaExpressions() {
    std::cout << "\n=== Lambda Expressions ===" << std::endl;
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    std::cout << "Original: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 基本lambda表达式
    auto square = [](int x) { return x * x; };
    std::cout << "Square of 5: " << square(5) << std::endl;
    
    // 捕获变量的lambda表达式
    int multiplier = 3;
    auto multiply = [multiplier](int x) { return x * multiplier; };
    std::cout << "5 * 3 = " << multiply(5) << std::endl;
    
    // 使用lambda表达式变换
    std::vector<int> doubled(vec.size());
    std::transform(vec.begin(), vec.end(), doubled.begin(),
                   [](int x) { return x * 2; });
    
    std::cout << "Doubled: ";
    for (const auto& element : doubled) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用lambda表达式过滤
    std::vector<int> filtered;
    std::copy_if(vec.begin(), vec.end(), std::back_inserter(filtered),
                 [](int x) { return x > 5; });
    
    std::cout << "Numbers > 5: ";
    for (const auto& element : filtered) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
    
    // 使用lambda表达式排序
    std::vector<std::string> words = {"apple", "banana", "cherry", "date"};
    std::sort(words.begin(), words.end(),
              [](const std::string& a, const std::string& b) {
                  return a.length() < b.length();
              });
    
    std::cout << "Words sorted by length: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 使用lambda表达式计数
    int count = std::count_if(vec.begin(), vec.end(),
                              [](int x) { return x % 2 == 0; });
    std::cout << "Even numbers count: " << count << std::endl;
}

void demonstrateAdvancedLambda() {
    std::cout << "\n=== Advanced Lambda ===" << std::endl;
    std::vector<std::string> words = {"hello", "world", "c++", "programming", "language"};
    
    std::cout << "Original words: ";
    for (const auto& word : words) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
    
    // 捕获引用
    int totalLength = 0;
    std::for_each(words.begin(), words.end(),
                  [&totalLength](const std::string& word) {
                      totalLength += word.length();
                  });
    std::cout << "Total length: " << totalLength << std::endl;
    
    // 捕获多个变量
    int minLength = 10;
    int maxLength = 0;
    std::for_each(words.begin(), words.end(),
                  [&minLength, &maxLength](const std::string& word) {
                      minLength = std::min(minLength, static_cast<int>(word.length()));
                      maxLength = std::max(maxLength, static_cast<int>(word.length()));
                  });
    std::cout << "Min length: " << minLength << ", Max length: " << maxLength << std::endl;
    
    // 通用lambda (C++14)
    auto genericAdd = [](auto a, auto b) { return a + b; };
    std::cout << "Generic add (int): " << genericAdd(5, 3) << std::endl;
    std::cout << "Generic add (double): " << genericAdd(3.14, 2.86) << std::endl;
    std::cout << "Generic add (string): " << genericAdd(std::string("Hello"), std::string(" World")) << std::endl;
    
    // 使用lambda表达式进行复杂变换
    std::vector<std::string> transformed;
    std::transform(words.begin(), words.end(), std::back_inserter(transformed),
                   [](const std::string& word) {
                       std::string result = word;
                       std::transform(result.begin(), result.end(), result.begin(), ::toupper);
                       return result + " (" + std::to_string(word.length()) + ")";
                   });
    
    std::cout << "Transformed words: ";
    for (const auto& word : transformed) {
        std::cout << word << " ";
    }
    std::cout << std::endl;
}

int main() {
    demonstratePredefinedFunctionObjects();
    demonstrateCustomFunctionObjects();
    demonstrateLambdaExpressions();
    demonstrateAdvancedLambda();
    
    return 0;
}
```

### 第7天：综合练习

#### 项目2：学生管理系统
**难度**：★★★★☆

使用STL实现一个学生管理系统，包含以下功能：
1. 学生信息管理
2. 成绩管理
3. 统计功能

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <string>
#include <iomanip>

struct Student {
    int id;
    std::string name;
    std::map<std::string, double> subjects;
    
    Student(int i, const std::string& n) : id(i), name(n) {}
    
    void addScore(const std::string& subject, double score) {
        subjects[subject] = score;
    }
    
    double getAverage() const {
        if (subjects.empty()) return 0.0;
        double sum = 0.0;
        for (const auto& pair : subjects) {
            sum += pair.second;
        }
        return sum / subjects.size();
    }
    
    double getScore(const std::string& subject) const {
        auto it = subjects.find(subject);
        return (it != subjects.end()) ? it->second : -1.0;
    }
    
    void display() const {
        std::cout << "ID: " << id << ", Name: " << name << std::endl;
        std::cout << "Scores: ";
        for (const auto& pair : subjects) {
            std::cout << pair.first << ":" << pair.second << " ";
        }
        std::cout << std::endl;
        std::cout << "Average: " << std::fixed << std::setprecision(2) << getAverage() << std::endl;
    }
};

class StudentManager {
private:
    std::map<int, Student> students;
    std::set<std::string> subjects;
    
public:
    void addStudent(int id, const std::string& name) {
        students.emplace(id, Student(id, name));
    }
    
    void addScore(int id, const std::string& subject, double score) {
        auto it = students.find(id);
        if (it != students.end()) {
            it->second.addScore(subject, score);
            subjects.insert(subject);
        }
    }
    
    void removeStudent(int id) {
        students.erase(id);
    }
    
    Student* getStudent(int id) {
        auto it = students.find(id);
        return (it != students.end()) ? &it->second : nullptr;
    }
    
    void displayAll() const {
        std::cout << "All Students:" << std::endl;
        std::cout << "=============" << std::endl;
        for (const auto& pair : students) {
            pair.second.display();
            std::cout << std::endl;
        }
    }
    
    void displayByAverage() const {
        std::vector<std::pair<int, double>> studentAverages;
        for (const auto& pair : students) {
            studentAverages.emplace_back(pair.first, pair.second.getAverage());
        }
        
        std::sort(studentAverages.begin(), studentAverages.end(),
                  [](const std::pair<int, double>& a, const std::pair<int, double>& b) {
                      return a.second > b.second;
                  });
        
        std::cout << "Students sorted by average:" << std::endl;
        std::cout << "===========================" << std::endl;
        for (const auto& pair : studentAverages) {
            auto it = students.find(pair.first);
            if (it != students.end()) {
                std::cout << "Average: " << std::fixed << std::setprecision(2) << pair.second << " - ";
                it->second.display();
                std::cout << std::endl;
            }
        }
    }
    
    void displaySubjectStatistics(const std::string& subject) const {
        std::vector<double> scores;
        for (const auto& pair : students) {
            double score = pair.second.getScore(subject);
            if (score >= 0) {
                scores.push_back(score);
            }
        }
        
        if (scores.empty()) {
            std::cout << "No scores found for subject: " << subject << std::endl;
            return;
        }
        
        std::sort(scores.begin(), scores.end());
        
        double sum = std::accumulate(scores.begin(), scores.end(), 0.0);
        double average = sum / scores.size();
        double min = scores.front();
        double max = scores.back();
        
        std::cout << "Statistics for " << subject << ":" << std::endl;
        std::cout << "========================" << std::endl;
        std::cout << "Number of students: " << scores.size() << std::endl;
        std::cout << "Average: " << std::fixed << std::setprecision(2) << average << std::endl;
        std::cout << "Minimum: " << std::fixed << std::setprecision(2) << min << std::endl;
        std::cout << "Maximum: " << std::fixed << std::setprecision(2) << max << std::endl;
        
        // 计算中位数
        double median;
        if (scores.size() % 2 == 0) {
            median = (scores[scores.size() / 2 - 1] + scores[scores.size() / 2]) / 2.0;
        } else {
            median = scores[scores.size() / 2];
        }
        std::cout << "Median: " << std::fixed << std::setprecision(2) << median << std::endl;
    }
    
    void displayTopStudents(int count) const {
        std::vector<std::pair<int, double>> studentAverages;
        for (const auto& pair : students) {
            studentAverages.emplace_back(pair.first, pair.second.getAverage());
        }
        
        std::sort(studentAverages.begin(), studentAverages.end(),
                  [](const std::pair<int, double>& a, const std::pair<int, double>& b) {
                      return a.second > b.second;
                  });
        
        std::cout << "Top " << count << " students:" << std::endl;
        std::cout << "===================" << std::endl;
        for (int i = 0; i < std::min(count, static_cast<int>(studentAverages.size())); ++i) {
            auto it = students.find(studentAverages[i].first);
            if (it != students.end()) {
                std::cout << (i + 1) << ". ";
                it->second.display();
                std::cout << std::endl;
            }
        }
    }
    
    void displaySubjectList() const {
        std::cout << "Available subjects:" << std::endl;
        std::cout << "===================" << std::endl;
        for (const auto& subject : subjects) {
            std::cout << subject << std::endl;
        }
    }
    
    size_t getStudentCount() const {
        return students.size();
    }
    
    size_t getSubjectCount() const {
        return subjects.size();
    }
};

int main() {
    StudentManager manager;
    
    // 添加学生
    manager.addStudent(1001, "Alice");
    manager.addStudent(1002, "Bob");
    manager.addStudent(1003, "Charlie");
    manager.addStudent(1004, "David");
    manager.addStudent(1005, "Eve");
    
    // 添加成绩
    manager.addScore(1001, "Math", 95.0);
    manager.addScore(1001, "Physics", 88.0);
    manager.addScore(1001, "Chemistry", 92.0);
    
    manager.addScore(1002, "Math", 87.0);
    manager.addScore(1002, "Physics", 91.0);
    manager.addScore(1002, "Chemistry", 85.0);
    
    manager.addScore(1003, "Math", 92.0);
    manager.addScore(1003, "Physics", 89.0);
    manager.addScore(1003, "Chemistry", 94.0);
    
    manager.addScore(1004, "Math", 78.0);
    manager.addScore(1004, "Physics", 82.0);
    manager.addScore(1004, "Chemistry", 80.0);
    
    manager.addScore(1005, "Math", 96.0);
    manager.addScore(1005, "Physics", 93.0);
    manager.addScore(1005, "Chemistry", 97.0);
    
    // 显示所有学生
    manager.displayAll();
    
    // 显示按平均分排序的学生
    manager.displayByAverage();
    
    // 显示科目统计
    manager.displaySubjectStatistics("Math");
    std::cout << std::endl;
    manager.displaySubjectStatistics("Physics");
    std::cout << std::endl;
    manager.displaySubjectStatistics("Chemistry");
    std::cout << std::endl;
    
    // 显示前3名学生
    manager.displayTopStudents(3);
    
    // 显示科目列表
    manager.displaySubjectList();
    
    std::cout << "\nTotal students: " << manager.getStudentCount() << std::endl;
    std::cout << "Total subjects: " << manager.getSubjectCount() << std::endl;
    
    return 0;
}
```

## 检查点

### 第3周结束时的能力要求
- [ ] 熟练使用各种STL容器
- [ ] 理解不同容器的特点和适用场景
- [ ] 能够使用迭代器遍历和操作容器
- [ ] 掌握常用STL算法的使用
- [ ] 能够编写和使用函数对象
- [ ] 熟练使用lambda表达式
- [ ] 能够选择合适的容器和算法
- [ ] 完成项目2的主要功能

## 评分标准

### 题目1-3：序列容器（30分）
- vector操作（10分）
- list操作（10分）
- deque操作（10分）

### 题目4-6：关联容器（30分）
- map操作（10分）
- set操作（10分）
- unordered_map操作（10分）

### 题目7：迭代器（20分）
- 迭代器操作和特性（20分）

### 题目8：查找和排序算法（20分）
- 查找算法（10分）
- 排序算法（10分）

### 题目9：变换和数值算法（20分）
- 变换算法（10分）
- 数值算法（10分）

### 题目10：函数对象（20分）
- 预定义函数对象（5分）
- 自定义函数对象（5分）
- lambda表达式（10分）

### 项目2：学生管理系统（50分）
- 实现基本功能（20分）
- 使用STL容器和算法（15分）
- 代码质量和设计（15分）

**总分：190分**
**及格分数：114分（60%）**

---

**学习时间**：第3周  
**预计完成时间**：2024-02-05























