# 第4周：内存管理和异常处理

## 学习目标

掌握C++内存管理技术，包括智能指针、RAII原则、异常处理机制和资源管理最佳实践。

## 学习内容

### 1. 智能指针（Smart Pointers）

#### 1.1 unique_ptr - 独占所有权
```cpp
#include <memory>
#include <iostream>

class Resource {
public:
    Resource(const std::string& name) : name(name) {
        std::cout << "Resource " << name << " created" << std::endl;
    }
    
    ~Resource() {
        std::cout << "Resource " << name << " destroyed" << std::endl;
    }
    
    void use() {
        std::cout << "Using resource " << name << std::endl;
    }
    
private:
    std::string name;
};

int main() {
    // 创建unique_ptr
    std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>("Resource1");
    ptr1->use();
    
    // 转移所有权
    std::unique_ptr<Resource> ptr2 = std::move(ptr1);
    
    if (ptr1 == nullptr) {
        std::cout << "ptr1 is now empty" << std::endl;
    }
    
    ptr2->use();
    
    // 自动释放资源
    return 0;
}
```

#### 1.2 shared_ptr - 共享所有权
```cpp
#include <memory>
#include <iostream>

class SharedResource {
public:
    SharedResource(const std::string& name) : name(name) {
        std::cout << "SharedResource " << name << " created" << std::endl;
    }
    
    ~SharedResource() {
        std::cout << "SharedResource " << name << " destroyed" << std::endl;
    }
    
    void use() {
        std::cout << "Using shared resource " << name << std::endl;
    }
    
private:
    std::string name;
};

int main() {
    // 创建shared_ptr
    std::shared_ptr<SharedResource> ptr1 = std::make_shared<SharedResource>("Shared1");
    
    // 复制shared_ptr
    std::shared_ptr<SharedResource> ptr2 = ptr1;
    std::shared_ptr<SharedResource> ptr3 = ptr1;
    
    std::cout << "Reference count: " << ptr1.use_count() << std::endl;
    
    ptr1->use();
    ptr2->use();
    ptr3->use();
    
    // 重置指针
    ptr2.reset();
    std::cout << "After reset, reference count: " << ptr1.use_count() << std::endl;
    
    // 自动释放资源（当最后一个shared_ptr被销毁时）
    return 0;
}
```

#### 1.3 weak_ptr - 弱引用
```cpp
#include <memory>
#include <iostream>

class Node {
public:
    std::string name;
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> parent;  // 使用weak_ptr避免循环引用
    
    Node(const std::string& n) : name(n) {
        std::cout << "Node " << name << " created" << std::endl;
    }
    
    ~Node() {
        std::cout << "Node " << name << " destroyed" << std::endl;
    }
    
    void setParent(std::shared_ptr<Node> p) {
        parent = p;
    }
    
    void printParent() {
        if (auto p = parent.lock()) {
            std::cout << "Parent: " << p->name << std::endl;
        } else {
            std::cout << "Parent is no longer available" << std::endl;
        }
    }
};

int main() {
    auto node1 = std::make_shared<Node>("Node1");
    auto node2 = std::make_shared<Node>("Node2");
    
    node1->next = node2;
    node2->setParent(node1);
    
    node2->printParent();
    
    // 即使node1被销毁，node2仍然存在
    node1.reset();
    node2->printParent();
    
    return 0;
}
```

### 2. RAII原则（Resource Acquisition Is Initialization）

#### 2.1 RAII基本概念
```cpp
#include <iostream>
#include <memory>

// RAII类示例
class FileHandle {
private:
    FILE* file;
    
public:
    FileHandle(const std::string& filename, const std::string& mode) {
        file = fopen(filename.c_str(), mode.c_str());
        if (!file) {
            throw std::runtime_error("Cannot open file: " + filename);
        }
        std::cout << "File opened: " << filename << std::endl;
    }
    
    ~FileHandle() {
        if (file) {
            fclose(file);
            std::cout << "File closed" << std::endl;
        }
    }
    
    // 禁用拷贝
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    // 支持移动
    FileHandle(FileHandle&& other) noexcept : file(other.file) {
        other.file = nullptr;
    }
    
    FileHandle& operator=(FileHandle&& other) noexcept {
        if (this != &other) {
            if (file) {
                fclose(file);
            }
            file = other.file;
            other.file = nullptr;
        }
        return *this;
    }
    
    FILE* get() const { return file; }
    
    void write(const std::string& data) {
        if (file) {
            fwrite(data.c_str(), 1, data.size(), file);
        }
    }
};

int main() {
    try {
        FileHandle file("test.txt", "w");
        file.write("Hello, RAII!");
        // 文件会在作用域结束时自动关闭
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

#### 2.2 RAII与异常安全
```cpp
#include <iostream>
#include <memory>
#include <vector>

class DatabaseConnection {
private:
    std::string connectionString;
    bool connected;
    
public:
    DatabaseConnection(const std::string& connStr) : connectionString(connStr), connected(false) {
        std::cout << "Connecting to database: " << connStr << std::endl;
        // 模拟连接过程
        connected = true;
    }
    
    ~DatabaseConnection() {
        if (connected) {
            std::cout << "Disconnecting from database" << std::endl;
            connected = false;
        }
    }
    
    void executeQuery(const std::string& query) {
        if (!connected) {
            throw std::runtime_error("Not connected to database");
        }
        std::cout << "Executing query: " << query << std::endl;
    }
    
    void beginTransaction() {
        std::cout << "Beginning transaction" << std::endl;
    }
    
    void commitTransaction() {
        std::cout << "Committing transaction" << std::endl;
    }
    
    void rollbackTransaction() {
        std::cout << "Rolling back transaction" << std::endl;
    }
};

// RAII事务管理
class Transaction {
private:
    DatabaseConnection& db;
    bool committed;
    
public:
    Transaction(DatabaseConnection& database) : db(database), committed(false) {
        db.beginTransaction();
    }
    
    ~Transaction() {
        if (!committed) {
            db.rollbackTransaction();
        }
    }
    
    void commit() {
        db.commitTransaction();
        committed = true;
    }
};

int main() {
    try {
        DatabaseConnection db("localhost:3306/mydb");
        
        {
            Transaction trans(db);
            db.executeQuery("INSERT INTO users VALUES (1, 'Alice')");
            db.executeQuery("INSERT INTO users VALUES (2, 'Bob')");
            
            // 如果这里抛出异常，事务会自动回滚
            // throw std::runtime_error("Simulated error");
            
            trans.commit();  // 手动提交事务
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 3. 异常处理机制

#### 3.1 基本异常处理
```cpp
#include <iostream>
#include <stdexcept>
#include <string>

class Calculator {
public:
    double divide(double a, double b) {
        if (b == 0) {
            throw std::invalid_argument("Division by zero");
        }
        return a / b;
    }
    
    double squareRoot(double x) {
        if (x < 0) {
            throw std::domain_error("Cannot compute square root of negative number");
        }
        return std::sqrt(x);
    }
    
    int factorial(int n) {
        if (n < 0) {
            throw std::invalid_argument("Factorial is not defined for negative numbers");
        }
        if (n > 12) {
            throw std::overflow_error("Factorial too large");
        }
        
        int result = 1;
        for (int i = 2; i <= n; ++i) {
            result *= i;
        }
        return result;
    }
};

int main() {
    Calculator calc;
    
    try {
        double result1 = calc.divide(10, 2);
        std::cout << "10 / 2 = " << result1 << std::endl;
        
        double result2 = calc.divide(10, 0);  // 抛出异常
        std::cout << "10 / 0 = " << result2 << std::endl;
        
    } catch (const std::invalid_argument& e) {
        std::cerr << "Invalid argument: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
    
    try {
        double result3 = calc.squareRoot(16);
        std::cout << "sqrt(16) = " << result3 << std::endl;
        
        double result4 = calc.squareRoot(-4);  // 抛出异常
        std::cout << "sqrt(-4) = " << result4 << std::endl;
        
    } catch (const std::domain_error& e) {
        std::cerr << "Domain error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

#### 3.2 自定义异常类
```cpp
#include <iostream>
#include <stdexcept>
#include <string>

// 自定义异常类
class BankException : public std::exception {
private:
    std::string message;
    
public:
    BankException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class InsufficientFundsException : public BankException {
public:
    InsufficientFundsException(double amount, double balance) 
        : BankException("Insufficient funds: requested " + std::to_string(amount) + 
                       ", available " + std::to_string(balance)) {}
};

class InvalidAmountException : public BankException {
public:
    InvalidAmountException(double amount) 
        : BankException("Invalid amount: " + std::to_string(amount)) {}
};

class BankAccount {
private:
    std::string accountNumber;
    double balance;
    
public:
    BankAccount(const std::string& accNum, double initialBalance = 0.0) 
        : accountNumber(accNum), balance(initialBalance) {}
    
    void deposit(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        balance += amount;
        std::cout << "Deposited " << amount << ", new balance: " << balance << std::endl;
    }
    
    void withdraw(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        if (amount > balance) {
            throw InsufficientFundsException(amount, balance);
        }
        balance -= amount;
        std::cout << "Withdrew " << amount << ", new balance: " << balance << std::endl;
    }
    
    double getBalance() const {
        return balance;
    }
    
    std::string getAccountNumber() const {
        return accountNumber;
    }
};

int main() {
    BankAccount account("12345", 1000.0);
    
    try {
        account.deposit(500.0);
        account.withdraw(200.0);
        account.withdraw(2000.0);  // 抛出InsufficientFundsException
        
    } catch (const InsufficientFundsException& e) {
        std::cerr << "Insufficient funds error: " << e.what() << std::endl;
    } catch (const InvalidAmountException& e) {
        std::cerr << "Invalid amount error: " << e.what() << std::endl;
    } catch (const BankException& e) {
        std::cerr << "Bank error: " << e.what() << std::endl;
    }
    
    try {
        account.deposit(-100.0);  // 抛出InvalidAmountException
        
    } catch (const BankException& e) {
        std::cerr << "Bank error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

#### 3.3 异常安全保证
```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <stdexcept>

// 异常安全的类
class ExceptionSafeVector {
private:
    std::vector<int> data;
    
public:
    // 强异常安全保证
    void insert(size_t pos, int value) {
        std::vector<int> temp = data;  // 创建副本
        temp.insert(temp.begin() + pos, value);  // 在副本上操作
        data = std::move(temp);  // 如果成功，则替换原数据
    }
    
    // 基本异常安全保证
    void push_back(int value) {
        data.push_back(value);  // 如果失败，vector保持原状态
    }
    
    // 无异常保证
    int& operator[](size_t index) {
        return data[index];  // 如果索引越界，行为未定义
    }
    
    const int& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return data.size();
    }
};

// 异常安全的资源管理
class ResourceManager {
private:
    std::vector<std::unique_ptr<int>> resources;
    
public:
    void addResource(int value) {
        auto resource = std::make_unique<int>(value);
        resources.push_back(std::move(resource));
    }
    
    void removeResource(size_t index) {
        if (index < resources.size()) {
            resources.erase(resources.begin() + index);
        }
    }
    
    int getResource(size_t index) const {
        if (index >= resources.size()) {
            throw std::out_of_range("Index out of range");
        }
        return *resources[index];
    }
    
    size_t getResourceCount() const {
        return resources.size();
    }
};

int main() {
    try {
        ExceptionSafeVector vec;
        vec.push_back(1);
        vec.push_back(2);
        vec.insert(1, 3);  // 在位置1插入3
        
        for (size_t i = 0; i < vec.size(); ++i) {
            std::cout << vec[i] << " ";
        }
        std::cout << std::endl;
        
        ResourceManager manager;
        manager.addResource(10);
        manager.addResource(20);
        manager.addResource(30);
        
        std::cout << "Resource count: " << manager.getResourceCount() << std::endl;
        std::cout << "Resource 1: " << manager.getResource(1) << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 4. 资源管理最佳实践

#### 4.1 内存泄漏检测
```cpp
#include <iostream>
#include <memory>
#include <vector>

// 简单的内存泄漏检测器
class MemoryTracker {
private:
    static size_t allocated;
    static size_t deallocated;
    
public:
    static void* allocate(size_t size) {
        void* ptr = malloc(size);
        if (ptr) {
            allocated += size;
            std::cout << "Allocated " << size << " bytes, total: " << allocated << std::endl;
        }
        return ptr;
    }
    
    static void deallocate(void* ptr, size_t size) {
        if (ptr) {
            free(ptr);
            deallocated += size;
            std::cout << "Deallocated " << size << " bytes, total: " << deallocated << std::endl;
        }
    }
    
    static void report() {
        std::cout << "Memory report - Allocated: " << allocated 
                  << ", Deallocated: " << deallocated 
                  << ", Leaked: " << (allocated - deallocated) << std::endl;
    }
};

size_t MemoryTracker::allocated = 0;
size_t MemoryTracker::deallocated = 0;

// 自定义分配器
template<typename T>
class TrackingAllocator {
public:
    using value_type = T;
    
    T* allocate(size_t n) {
        return static_cast<T*>(MemoryTracker::allocate(n * sizeof(T)));
    }
    
    void deallocate(T* ptr, size_t n) {
        MemoryTracker::deallocate(ptr, n * sizeof(T));
    }
};

// RAII内存管理
class ManagedArray {
private:
    int* data;
    size_t size;
    
public:
    ManagedArray(size_t s) : size(s) {
        data = new int[size];
        std::cout << "ManagedArray created with size " << size << std::endl;
    }
    
    ~ManagedArray() {
        delete[] data;
        std::cout << "ManagedArray destroyed" << std::endl;
    }
    
    // 禁用拷贝
    ManagedArray(const ManagedArray&) = delete;
    ManagedArray& operator=(const ManagedArray&) = delete;
    
    // 支持移动
    ManagedArray(ManagedArray&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
    
    int& operator[](size_t index) {
        return data[index];
    }
    
    const int& operator[](size_t index) const {
        return data[index];
    }
    
    size_t getSize() const {
        return size;
    }
};

int main() {
    {
        ManagedArray arr(10);
        for (size_t i = 0; i < arr.getSize(); ++i) {
            arr[i] = static_cast<int>(i);
        }
        
        for (size_t i = 0; i < arr.getSize(); ++i) {
            std::cout << arr[i] << " ";
        }
        std::cout << std::endl;
        
        // 使用智能指针
        auto smartPtr = std::make_unique<int[]>(5);
        for (int i = 0; i < 5; ++i) {
            smartPtr[i] = i * i;
        }
        
        for (int i = 0; i < 5; ++i) {
            std::cout << smartPtr[i] << " ";
        }
        std::cout << std::endl;
        
    }  // 自动释放资源
    
    MemoryTracker::report();
    
    return 0;
}
```

#### 4.2 异常安全的设计模式
```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <stdexcept>

// 异常安全的单例模式
class SafeSingleton {
private:
    static std::once_flag flag;
    static std::unique_ptr<SafeSingleton> instance;
    
    SafeSingleton() {
        std::cout << "SafeSingleton created" << std::endl;
    }
    
public:
    static SafeSingleton& getInstance() {
        std::call_once(flag, []() {
            instance = std::make_unique<SafeSingleton>();
        });
        return *instance;
    }
    
    void doSomething() {
        std::cout << "SafeSingleton doing something" << std::endl;
    }
    
    ~SafeSingleton() {
        std::cout << "SafeSingleton destroyed" << std::endl;
    }
};

std::once_flag SafeSingleton::flag;
std::unique_ptr<SafeSingleton> SafeSingleton::instance;

// 异常安全的工厂模式
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing circle" << std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing rectangle" << std::endl;
    }
};

class ShapeFactory {
public:
    static std::unique_ptr<Shape> createShape(const std::string& type) {
        if (type == "circle") {
            return std::make_unique<Circle>();
        } else if (type == "rectangle") {
            return std::make_unique<Rectangle>();
        } else {
            throw std::invalid_argument("Unknown shape type: " + type);
        }
    }
};

// 异常安全的RAII包装器
template<typename T>
class RAIIWrapper {
private:
    T resource;
    bool valid;
    
public:
    RAIIWrapper(T res) : resource(res), valid(true) {}
    
    ~RAIIWrapper() {
        if (valid) {
            // 假设T有cleanup方法
            if constexpr (std::is_member_function_pointer_v<decltype(&T::cleanup)>) {
                resource.cleanup();
            }
        }
    }
    
    T& get() {
        if (!valid) {
            throw std::runtime_error("Resource is no longer valid");
        }
        return resource;
    }
    
    void release() {
        valid = false;
    }
    
    RAIIWrapper(const RAIIWrapper&) = delete;
    RAIIWrapper& operator=(const RAIIWrapper&) = delete;
    
    RAIIWrapper(RAIIWrapper&& other) noexcept : resource(std::move(other.resource)), valid(other.valid) {
        other.valid = false;
    }
    
    RAIIWrapper& operator=(RAIIWrapper&& other) noexcept {
        if (this != &other) {
            resource = std::move(other.resource);
            valid = other.valid;
            other.valid = false;
        }
        return *this;
    }
};

int main() {
    try {
        // 使用单例
        SafeSingleton::getInstance().doSomething();
        
        // 使用工厂
        auto circle = ShapeFactory::createShape("circle");
        circle->draw();
        
        auto rectangle = ShapeFactory::createShape("rectangle");
        rectangle->draw();
        
        // 尝试创建未知形状
        auto unknown = ShapeFactory::createShape("triangle");
        
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
    
    return 0;
}
```

## 实践练习

### 练习1：智能指针使用
编写程序实现以下功能：
1. 使用unique_ptr管理动态数组
2. 使用shared_ptr实现简单的引用计数
3. 使用weak_ptr避免循环引用
4. 比较智能指针和原始指针的性能

### 练习2：RAII实现
实现以下RAII类：
1. 文件句柄管理类
2. 网络连接管理类
3. 数据库连接管理类
4. 锁管理类

### 练习3：异常处理
编写程序实现：
1. 自定义异常类层次结构
2. 异常安全的容器操作
3. 异常传播和捕获
4. 异常安全保证的实现

## 每日学习任务

### 第1天：智能指针基础
- 学习unique_ptr的使用
- 理解独占所有权的概念
- 练习移动语义的使用

### 第2天：智能指针进阶
- 学习shared_ptr和weak_ptr
- 理解引用计数和循环引用
- 练习智能指针的组合使用

### 第3天：RAII原则
- 学习RAII的基本概念
- 理解资源获取即初始化
- 练习RAII类的设计

### 第4天：异常处理基础
- 学习try-catch-throw语法
- 理解异常类型和层次结构
- 练习异常处理的基本用法

### 第5天：异常处理进阶
- 学习自定义异常类
- 理解异常安全保证
- 练习异常安全的设计

### 第6天：资源管理
- 学习资源管理最佳实践
- 理解内存泄漏检测
- 练习异常安全的设计模式

### 第7天：综合练习
- 完成所有实践练习
- 开始项目3：内存安全程序
- 综合运用所学知识

## 项目3：内存安全程序

### 项目要求
编写一个内存安全的C++程序，包含以下功能：

```cpp
#include <memory>
#include <vector>
#include <string>
#include <stdexcept>

class MemorySafeString {
private:
    std::unique_ptr<char[]> data;
    size_t length;
    
public:
    // 构造函数
    MemorySafeString();
    MemorySafeString(const char* str);
    MemorySafeString(const std::string& str);
    
    // 拷贝构造函数和赋值操作符
    MemorySafeString(const MemorySafeString& other);
    MemorySafeString& operator=(const MemorySafeString& other);
    
    // 移动构造函数和移动赋值操作符
    MemorySafeString(MemorySafeString&& other) noexcept;
    MemorySafeString& operator=(MemorySafeString&& other) noexcept;
    
    // 基本操作
    char& operator[](size_t index);
    const char& operator[](size_t index) const;
    
    size_t length() const;
    const char* c_str() const;
    
    // 字符串操作
    MemorySafeString operator+(const MemorySafeString& other) const;
    bool operator==(const MemorySafeString& other) const;
    
    // 异常安全的操作
    void append(const MemorySafeString& other);
    void insert(size_t pos, const MemorySafeString& other);
    void erase(size_t pos, size_t count);
};
```

### 实现要点
1. 使用智能指针管理内存
2. 实现RAII原则
3. 提供异常安全保证
4. 支持移动语义
5. 防止内存泄漏和悬空指针

## 检查点

### 第4周结束时的能力要求
- [ ] 熟练使用智能指针
- [ ] 理解RAII原则和实现
- [ ] 掌握异常处理机制
- [ ] 能够编写异常安全的代码
- [ ] 理解资源管理最佳实践
- [ ] 能够检测和避免内存泄漏
- [ ] 完成项目3的主要功能
- [ ] 具备内存安全编程能力

## 常见问题解答

### Q: 什么时候使用智能指针？
A: 当需要动态分配内存时，优先使用智能指针而不是原始指针。unique_ptr用于独占所有权，shared_ptr用于共享所有权，weak_ptr用于避免循环引用。

### Q: 如何避免内存泄漏？
A: 
- 使用智能指针自动管理内存
- 遵循RAII原则
- 使用容器而不是手动管理数组
- 定期使用内存检测工具

### Q: 异常处理的最佳实践？
A: 
- 使用RAII确保资源正确释放
- 提供适当的异常安全保证
- 避免在析构函数中抛出异常
- 使用具体的异常类型而不是通用的std::exception

### Q: 如何设计异常安全的类？
A: 
- 使用智能指针管理资源
- 实现强异常安全保证
- 避免在构造函数中抛出异常
- 使用移动语义提高性能

---

**学习时间**：第4周  
**预计完成时间**：2024-02-12



