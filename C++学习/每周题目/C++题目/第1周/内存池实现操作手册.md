# å†…å­˜æ± å®ç°è¯¦ç»†æ“ä½œæ‰‹å†Œ

## ğŸ“‹ ç›®å½•
1. [ç¯å¢ƒå‡†å¤‡](#ç¯å¢ƒå‡†å¤‡)
2. [é¡¹ç›®ç»“æ„åˆ›å»º](#é¡¹ç›®ç»“æ„åˆ›å»º)
3. [ç¬¬ä¸€é˜¶æ®µï¼šBlockHeaderå®ç°](#ç¬¬ä¸€é˜¶æ®µblockheaderå®ç°)
4. [ç¬¬äºŒé˜¶æ®µï¼šFixedSizePoolå®ç°](#ç¬¬äºŒé˜¶æ®µfixedsizepoolå®ç°)
5. [ç¬¬ä¸‰é˜¶æ®µï¼šæµ‹è¯•å’ŒéªŒè¯](#ç¬¬ä¸‰é˜¶æ®µæµ‹è¯•å’ŒéªŒè¯)
6. [ç¬¬å››é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–](#ç¬¬å››é˜¶æ®µæ€§èƒ½ä¼˜åŒ–)
7. [å¸¸è§é—®é¢˜å’Œè°ƒè¯•](#å¸¸è§é—®é¢˜å’Œè°ƒè¯•)

---

## ç¯å¢ƒå‡†å¤‡

### 1. å¼€å‘ç¯å¢ƒæ£€æŸ¥

#### Linux/WSLç¯å¢ƒ
```bash
# æ£€æŸ¥C++ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼ˆè¦æ±‚C++17ä»¥ä¸Šï¼‰
g++ --version  # æˆ– clang++ --version

# æ£€æŸ¥CMakeç‰ˆæœ¬ï¼ˆå»ºè®®3.10ä»¥ä¸Šï¼‰
cmake --version

# æ£€æŸ¥æ˜¯å¦æœ‰git
git --version

# æ£€æŸ¥æ˜¯å¦æœ‰make
make --version
```

#### å¿…è¦è½¯ä»¶å®‰è£…
```bash
# å®‰è£…ç¼–è¯‘å·¥å…·ï¼ˆUbuntu/Debianï¼‰
sudo apt-get update
sudo apt-get install -y build-essential cmake git

# å®‰è£…Clangå·¥å…·ï¼ˆå¯é€‰ä½†æ¨èï¼‰
sudo apt-get install -y clang clang-format clang-tidy

# å®‰è£…è°ƒè¯•å·¥å…·ï¼ˆæ¨èï¼‰
sudo apt-get install -y gdb valgrind
```

### 2. åˆ›å»ºé¡¹ç›®ç›®å½•

```bash
# è¿›å…¥é¡¹ç›®æ ¹ç›®å½•
cd /home/jonson/cuda-learning/æ¯å‘¨é¢˜ç›®/C++é¢˜ç›®/ç¬¬1å‘¨

# ç¡®è®¤StringProcessingLibç›®å½•å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
mkdir -p StringProcessingLib/{include/StringProcessingLib/memory_bool,src/memory_bool}

# åˆ›å»ºæµ‹è¯•ç›®å½•
mkdir -p StringProcessingLib/tests/unit_tests/memory_pool

# åˆ›å»ºç¤ºä¾‹ç›®å½•
mkdir -p StringProcessingLib/examples/basic_usage

# åˆ›å»ºæ„å»ºè¾“å‡ºç›®å½•
mkdir -p StringProcessingLib/build
```

### 3. éªŒè¯ç›®å½•ç»“æ„

æ‰§è¡Œä»¥ä¸‹å‘½ä»¤éªŒè¯ç›®å½•ç»“æ„æ˜¯å¦æ­£ç¡®ï¼š
```bash
tree StringProcessingLib -L 3
```

åº”è¯¥çœ‹åˆ°ç±»ä¼¼ä»¥ä¸‹ç»“æ„ï¼š
```
StringProcessingLib/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ StringProcessingLib/
â”‚       â””â”€â”€ memory_bool/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ memory_bool/
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ unit_tests/
â”‚       â””â”€â”€ memory_pool/
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ basic_usage/
â””â”€â”€ build/
```

---

## é¡¹ç›®ç»“æ„åˆ›å»º

### 1. åˆ›å»ºCMakeLists.txtä¸»æ–‡ä»¶

åœ¨`StringProcessingLib/`ç›®å½•ä¸‹åˆ›å»º`CMakeLists.txt`ï¼š

```bash
cat > StringProcessingLib/CMakeLists.txt << 'EOF'
cmake_minimum_required(VERSION 3.10)
project(StringProcessingLib VERSION 1.0.0 LANGUAGES CXX)

# è®¾ç½®C++æ ‡å‡†ä¸ºC++17
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# è®¾ç½®è¾“å‡ºç›®å½•
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# ç¼–è¯‘é€‰é¡¹
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -O0")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3 -DNDEBUG")

# åŒ…å«ç›®å½•
include_directories(${CMAKE_SOURCE_DIR}/include)

# æ·»åŠ å­ç›®å½•
add_subdirectory(src)
add_subdirectory(tests)
add_subdirectory(examples)

# å®‰è£…é…ç½®
install(DIRECTORY include/ DESTINATION include)
install(TARGETS stringprocessinglib DESTINATION lib)
EOF
```

### 2. åˆ›å»ºCMakeLists.txtå­æ–‡ä»¶

#### 2.1 src/CMakeLists.txt
```bash
cat > StringProcessingLib/src/CMakeLists.txt << 'EOF'
add_subdirectory(memory_bool)
EOF
```

#### 2.2 src/memory_bool/CMakeLists.txt
```bash
cat > StringProcessingLib/src/memory_bool/CMakeLists.txt << 'EOF'
# BlockHeaderæºæ–‡ä»¶
set(BLOCK_HEADER_SOURCES
    block_header.cpp
)

# FixedSizePoolæºæ–‡ä»¶
set(FIXED_SIZE_POOL_SOURCES
    fixed_size_pool.cpp
)

# æ‰€æœ‰æºæ–‡ä»¶
set(ALL_SOURCES
    ${BLOCK_HEADER_SOURCES}
    ${FIXED_SIZE_POOL_SOURCES}
)

# åˆ›å»ºåº“
add_library(stringprocessinglib STATIC ${ALL_SOURCES})

# åŒ…å«å¤´æ–‡ä»¶ç›®å½•
target_include_directories(stringprocessinglib PUBLIC
    ${CMAKE_SOURCE_DIR}/../include
)

# é“¾æ¥pthreadåº“ï¼ˆç”¨äºmutexï¼‰
target_link_libraries(stringprocessinglib PUBLIC pthread)
EOF
```

#### 2.3 tests/CMakeLists.txt
```bash
cat > StringProcessingLib/tests/CMakeLists.txt << 'EOF'
enable_testing()

add_subdirectory(unit_tests)
EOF
```

#### 2.4 tests/unit_tests/CMakeLists.txt
```bash
cat > StringProcessingLib/tests/unit_tests/CMakeLists.txt << 'EOF'
add_subdirectory(memory_pool)
EOF
```

#### 2.5 tests/unit_tests/memory_pool/CMakeLists.txt
```bash
cat > StringProcessingLib/tests/unit_tests/memory_pool/CMakeLists.txt << 'EOF'
# BlockHeaderæµ‹è¯•
add_executable(test_block_header test_block_header.cpp)
target_link_libraries(test_block_header stringprocessinglib)
add_test(NAME BlockHeaderTest COMMAND test_block_header)

# FixedSizePoolæµ‹è¯•
add_executable(test_fixed_size_pool test_fixed_size_pool.cpp)
target_link_libraries(test_fixed_size_pool stringprocessinglib)
add_test(NAME FixedSizePoolTest COMMAND test_fixed_size_pool)
EOF
```

---

## ç¬¬ä¸€é˜¶æ®µï¼šBlockHeaderå®ç°

### æ­¥éª¤1ï¼šåˆ›å»ºBlockHeaderå¤´æ–‡ä»¶

æ–‡ä»¶å·²å­˜åœ¨ï¼Œæˆ‘ä»¬éœ€è¦ç¡®è®¤å¹¶å®Œå–„å®ƒï¼š

```bash
# æŸ¥çœ‹ç°æœ‰æ–‡ä»¶
cat StringProcessingLib/include/StringProcessingLib/memory_bool/block_header.h
```

### æ­¥éª¤2ï¼šåˆ›å»ºBlockHeaderå®ç°æ–‡ä»¶

åˆ›å»º`StringProcessingLib/src/memory_bool/block_header.cpp`ï¼š

```cpp
/**
 * @file block_header.cpp
 * @brief BlockHeaderç»“æ„ä½“çš„æ–¹æ³•å®ç°
 * @author StringProcessingLib Team
 * @date 2024
 */

#include "StringProcessingLib/memory_bool/block_header.h"

namespace StringProcessingLib {
namespace MemoryPool {

// reset()æ–¹æ³•å·²ç»å†…è”å®šä¹‰åœ¨å¤´æ–‡ä»¶ä¸­ï¼Œå¦‚æœç¼–è¯‘å™¨æ”¯æŒï¼Œ
// å¯ä»¥ä¿æŒå†…è”ï¼›å¦‚æœéœ€è¦ç¼–è¯‘ä¼˜åŒ–æ§åˆ¶ï¼Œå¯ä»¥åœ¨è¿™é‡Œå®ç°

// å¦‚æœéœ€è¦æ·»åŠ å…¶ä»–éå†…è”æ–¹æ³•ï¼Œå¯ä»¥åœ¨è¿™é‡Œå®ç°

} // namespace MemoryPool
} // namespace StringProcessingLib
```

### æ­¥éª¤3ï¼šåˆ›å»ºBlockHeaderæµ‹è¯•æ–‡ä»¶

åˆ›å»º`StringProcessingLib/tests/unit_tests/memory_pool/test_block_header.cpp`ï¼š

```cpp
/**
 * @file test_block_header.cpp
 * @brief BlockHeaderå•å…ƒæµ‹è¯•
 */

#include <cassert>
#include <iostream>
#include "StringProcessingLib/memory_bool/block_header.h"

using namespace StringProcessingLib::MemoryPool;

// æµ‹è¯•BlockHeaderé»˜è®¤æ„é€ 
void test_default_constructor() {
    std::cout << "æµ‹è¯•1ï¼šé»˜è®¤æ„é€ å‡½æ•°\n";
    BlockHeader header;
    
    assert(header.size == 0);
    assert(header.is_free == true);
    assert(header.next == nullptr);
    assert(header.prev == nullptr);
    assert(header.allocation_count == 0);
    assert(header.last_alloc_time == 0);
    assert(header.is_valid() == true); // é­”æ•°åº”è¯¥æ­£ç¡®
    assert(header.get_user_size() == 0 - sizeof(BlockHeader));
    
    std::cout << "  âœ“ é»˜è®¤æ„é€ å‡½æ•°æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•BlockHeaderå‚æ•°æ„é€ 
void test_parameter_constructor() {
    std::cout << "æµ‹è¯•2ï¼šå‚æ•°æ„é€ å‡½æ•°\n";
    const size_t TEST_SIZE = 256;
    BlockHeader header(TEST_SIZE, false);
    
    assert(header.size == TEST_SIZE);
    assert(header.is_free == false);
    assert(header.next == nullptr);
    assert(header.is_valid() == true);
    
    std::cout << "  âœ“ å‚æ•°æ„é€ å‡½æ•°æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•is_validæ–¹æ³•
void test_is_valid() {
    std::cout << "æµ‹è¯•3ï¼šé­”æ•°éªŒè¯\n";
    BlockHeader header;
    
    // æ­£å¸¸æƒ…å†µåº”è¯¥æ˜¯æœ‰æ•ˆçš„
    assert(header.is_valid() == true);
    
    // ç ´åé­”æ•°
    header.magic = 0x12345678;
    assert(header.is_valid() == false);
    
    // æ¢å¤é­”æ•°
    header.magic = 0xDEADBEEF;
    assert(header.is_valid() == true);
    
    std::cout << "  âœ“ é­”æ•°éªŒè¯æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•get_user_sizeæ–¹æ³•
void test_get_user_size() {
    std::cout << "æµ‹è¯•4ï¼šè·å–ç”¨æˆ·ç©ºé—´å¤§å°\n";
    const size_t BLOCK_SIZE = 256;
    BlockHeader header(BLOCK_SIZE);
    
    size_t user_size = header.get_user_size();
    size_t expected = BLOCK_SIZE - sizeof(BlockHeader);
    
    assert(user_size == expected);
    std::cout << "  âœ“ ç”¨æˆ·ç©ºé—´å¤§å°è®¡ç®—æ­£ç¡®: " << user_size << " å­—èŠ‚\n";
}

// æµ‹è¯•get_user_ptræ–¹æ³•
void test_get_user_ptr() {
    std::cout << "æµ‹è¯•5ï¼šè·å–ç”¨æˆ·æŒ‡é’ˆ\n";
    BlockHeader header(256);
    void* user_ptr = header.get_user_ptr();
    
    // ç”¨æˆ·æŒ‡é’ˆåº”è¯¥æŒ‡å‘BlockHeaderä¹‹å
    char* header_ptr = reinterpret_cast<char*>(&header);
    char* expected_ptr = header_ptr + sizeof(BlockHeader);
    
    assert(user_ptr == expected_ptr);
    std::cout << "  âœ“ ç”¨æˆ·æŒ‡é’ˆè®¡ç®—æ­£ç¡®\n";
}

// æµ‹è¯•mark_allocatedæ–¹æ³•
void test_mark_allocated() {
    std::cout << "æµ‹è¯•6ï¼šæ ‡è®°ä¸ºå·²åˆ†é…\n";
    BlockHeader header;
    const uint64_t TEST_TIME = 1234567890;
    
    header.mark_allocated(TEST_TIME);
    
    assert(header.is_free == false);
    assert(header.allocation_count == 1);
    assert(header.last_alloc_time == TEST_TIME);
    
    // å†æ¬¡è°ƒç”¨åº”è¯¥å¢åŠ è®¡æ•°
    header.mark_allocated();
    assert(header.allocation_count == 2);
    
    std::cout << "  âœ“ æ ‡è®°ä¸ºå·²åˆ†é…æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•mark_freeæ–¹æ³•
void test_mark_free() {
    std::cout << "æµ‹è¯•7ï¼šæ ‡è®°ä¸ºç©ºé—²\n";
    BlockHeader header;
    header.is_free = false;
    
    header.mark_free();
    assert(header.is_free == true);
    
    std::cout << "  âœ“ æ ‡è®°ä¸ºç©ºé—²æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•resetæ–¹æ³•
void test_reset() {
    std::cout << "æµ‹è¯•8ï¼šé‡ç½®å—\n";
    BlockHeader header(256, false);
    header.next = reinterpret_cast<BlockHeader*>(0x1234);
    header.prev = reinterpret_cast<BlockHeader*>(0x5678);
    header.allocation_count = 5;
    header.last_alloc_time = 999;
    header.magic = 0xBAD; // ç ´åé­”æ•°
    
    header.reset();
    
    assert(header.is_free == true);
    assert(header.next == nullptr);
    assert(header.prev == nullptr);
    assert(header.allocation_count == 0);
    assert(header.last_alloc_time == 0);
    assert(header.is_valid() == true); // é­”æ•°åº”è¯¥è¢«æ¢å¤
    
    std::cout << "  âœ“ é‡ç½®å—æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•get_header_from_user_ptrè¾…åŠ©å‡½æ•°
void test_get_header_from_user_ptr() {
    std::cout << "æµ‹è¯•9ï¼šä»ç”¨æˆ·æŒ‡é’ˆè·å–å¤´éƒ¨\n";
    BlockHeader header(256);
    void* user_ptr = header.get_user_ptr();
    
    // ä»ç”¨æˆ·æŒ‡é’ˆåæ¨åº”è¯¥å¾—åˆ°åŸå¤´éƒ¨
    BlockHeader* recovered = get_header_from_user_ptr(user_ptr);
    assert(recovered == &header);
    
    std::cout << "  âœ“ ä»ç”¨æˆ·æŒ‡é’ˆè·å–å¤´éƒ¨æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•calculate_aligned_block_size
void test_calculate_aligned_block_size() {
    std::cout << "æµ‹è¯•10ï¼šè®¡ç®—å¯¹é½çš„å—å¤§å°\n";
    
    size_t user_size = 100;
    size_t aligned_size = calculate_aligned_block_size(user_size);
    
    // å¯¹é½åçš„å¤§å°åº”è¯¥åŒ…å«å¤´éƒ¨å¹¶ä¸”å¯¹é½
    assert(aligned_size >= sizeof(BlockHeader) + user_size);
    
    // åº”è¯¥æ˜¯å¯¹é½å€¼çš„å€æ•°
    size_t alignment = alignof(BlockHeader);
    assert(aligned_size % alignment == 0);
    
    std::cout << "  âœ“ è®¡ç®—å¯¹é½å¤§å°: " << user_size << " -> " << aligned_size << "\n";
}

// æµ‹è¯•validate_block_header
void test_validate_block_header() {
    std::cout << "æµ‹è¯•11ï¼šéªŒè¯å—å¤´éƒ¨\n";
    
    BlockHeader valid_header(256);
    assert(validate_block_header(&valid_header) == true);
    
    // æ— æ•ˆæŒ‡é’ˆ
    assert(validate_block_header(nullptr) == false);
    
    // æ— æ•ˆé­”æ•°
    BlockHeader invalid_magic(256);
    invalid_magic.magic = 0xBAD;
    assert(validate_block_header(&invalid_magic) == false);
    
    // å¤§å°å¤ªå°
    BlockHeader too_small;
    too_small.size = sizeof(BlockHeader) - 1;
    assert(validate_block_header(&too_small) == false);
    
    std::cout << "  âœ“ å—å¤´éƒ¨éªŒè¯æµ‹è¯•é€šè¿‡\n";
}

// ä¸»æµ‹è¯•å‡½æ•°
int main() {
    std::cout << "========== BlockHeaderå•å…ƒæµ‹è¯•å¼€å§‹ ==========\n\n";
    
    try {
        test_default_constructor();
        test_parameter_constructor();
        test_is_valid();
        test_get_user_size();
        test_get_user_ptr();
        test_mark_allocated();
        test_mark_free();
        test_reset();
        test_get_header_from_user_ptr();
        test_calculate_aligned_block_size();
        test_validate_block_header();
        
        std::cout << "\n========== æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼==========\n";
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "\næµ‹è¯•å¤±è´¥: " << e.what() << "\n";
        return 1;
    }
}
```

### æ­¥éª¤4ï¼šç¼–è¯‘å’Œæµ‹è¯•BlockHeader

```bash
# è¿›å…¥æ„å»ºç›®å½•
cd StringProcessingLib/build

# é…ç½®CMakeï¼ˆDebugæ¨¡å¼ï¼‰
cmake -DCMAKE_BUILD_TYPE=Debug ..

# ç¼–è¯‘
make

# è¿è¡ŒBlockHeaderæµ‹è¯•
./bin/test_block_header
```

**é¢„æœŸè¾“å‡º**ï¼š
```
========== BlockHeaderå•å…ƒæµ‹è¯•å¼€å§‹ ==========

æµ‹è¯•1ï¼šé»˜è®¤æ„é€ å‡½æ•°
  âœ“ é»˜è®¤æ„é€ å‡½æ•°æµ‹è¯•é€šè¿‡
æµ‹è¯•2ï¼šå‚æ•°æ„é€ å‡½æ•°
  âœ“ å‚æ•°æ„é€ å‡½æ•°æµ‹è¯•é€šè¿‡
...
========== æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼==========
```

---

## ç¬¬äºŒé˜¶æ®µï¼šFixedSizePoolå®ç°

### æ­¥éª¤1ï¼šå®Œå–„FixedSizePoolå¤´æ–‡ä»¶

æ£€æŸ¥å¹¶å®Œå–„`StringProcessingLib/include/StringProcessingLib/memory_bool/fixed_size_pool.h`ï¼š

```cpp
/**
 * @file fixed_size_pool.h
 * @brief å›ºå®šå¤§å°å†…å­˜æ± å®ç°
 * @author StringProcessingLib Team
 * @date 2024
 * 
 * æœ¬æ–‡ä»¶å®ç°äº†å›ºå®šå¤§å°å†…å­˜æ± ï¼Œç”¨äºç®¡ç†å¤§å°ç›¸åŒçš„å†…å­˜å—ã€‚
 * æ‰€æœ‰å—çš„å¤§å°ç”±æ„é€ å‡½æ•°æŒ‡å®šï¼Œæ”¯æŒO(1)æ—¶é—´çš„åˆ†é…å’Œé‡Šæ”¾ã€‚
 */

#ifndef STRINGPROCESSINGLIB_MEMORY_POOL_FIXED_SIZE_POOL_H
#define STRINGPROCESSINGLIB_MEMORY_POOL_FIXED_SIZE_POOL_H

#include <cstddef>  // ä¸ºäº†ä½¿ç”¨ size_t
#include <mutex>    // ä¸ºäº†ä½¿ç”¨ std::mutex
#include "block_header.h"

namespace StringProcessingLib {
namespace MemoryPool {

/**
 * @brief å›ºå®šå¤§å°å†…å­˜æ± ç±»
 * 
 * è¯¥ç±»ç®¡ç†å›ºå®šå¤§å°çš„å†…å­˜å—ï¼Œä½¿ç”¨ç©ºé—²é“¾è¡¨å®ç°O(1)çš„åˆ†é…å’Œé‡Šæ”¾ã€‚
 * æ‰€æœ‰å—åœ¨åˆå§‹åŒ–æ—¶é¢„åˆ†é…ï¼Œç©ºé—²å—ä½¿ç”¨é“¾è¡¨è¿æ¥ã€‚
 * 
 * ç‰¹æ€§ï¼š
 * - O(1)åˆ†é…å’Œé‡Šæ”¾æ—¶é—´å¤æ‚åº¦
 * - çº¿ç¨‹å®‰å…¨ï¼ˆä½¿ç”¨äº’æ–¥é”ï¼‰
 * - é¢„åˆ†é…æ‰€æœ‰å†…å­˜ï¼Œé¿å…è¿è¡Œæ—¶åŠ¨æ€åˆ†é…
 * - æ”¯æŒç»Ÿè®¡ä¿¡æ¯ï¼ˆåˆ†é…æ¬¡æ•°ã€ä½¿ç”¨æ•°é‡ç­‰ï¼‰
 */
class FixedSizePool {
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * 
     * @param block_size æ¯ä¸ªå†…å­˜å—çš„å¤§å°ï¼ˆå­—èŠ‚ï¼‰
     * @param block_count å†…å­˜å—çš„æ€»æ•°é‡
     */
    FixedSizePool(size_t block_size, size_t block_count);
    
    /**
     * @brief ææ„å‡½æ•°
     * 
     * é‡Šæ”¾æ‰€æœ‰é¢„åˆ†é…çš„å†…å­˜
     */
    ~FixedSizePool();
    
    /**
     * @brief åˆ†é…ä¸€ä¸ªå†…å­˜å—
     * 
     * @return æŒ‡å‘åˆ†é…å†…å­˜çš„æŒ‡é’ˆï¼Œå¦‚æœå†…å­˜æ± å·²æ»¡åˆ™è¿”å›nullptr
     */
    void* allocate();
    
    /**
     * @brief é‡Šæ”¾ä¸€ä¸ªå†…å­˜å—
     * 
     * @param ptr æŒ‡å‘è¦é‡Šæ”¾å†…å­˜çš„æŒ‡é’ˆ
     */
    void deallocate(void* ptr);
    
    /**
     * @brief è·å–ç»Ÿè®¡ä¿¡æ¯
     * 
     * @return åŒ…å«ä½¿ç”¨è®¡æ•°çš„ç»“æ„ä½“
     */
    struct Statistics {
        size_t used_count = 0;
        size_t total_allocations = 0;
        size_t total_deallocations = 0;
    };
    
    Statistics get_statistics() const;
    
    /**
     * @brief åˆ é™¤æ‹·è´æ„é€ å’Œèµ‹å€¼ï¼ˆèµ„æºç®¡ç†ï¼‰
     */
    FixedSizePool(const FixedSizePool&) = delete;
    FixedSizePool& operator=(const FixedSizePool&) = delete;
    
private:
    /**
     * @brief åˆå§‹åŒ–æ‰€æœ‰å†…å­˜å—
     * 
     * å°†é¢„åˆ†é…çš„å†…å­˜åˆ†å‰²æˆå›ºå®šå¤§å°çš„å—ï¼Œå¹¶å»ºç«‹ç©ºé—²é“¾è¡¨
     */
    void initialize_blocks();
    
    /**
     * @brief éªŒè¯å—å¤´éƒ¨çš„æœ‰æ•ˆæ€§
     * 
     * @param header å—å¤´éƒ¨æŒ‡é’ˆ
     * @return true å¦‚æœå—å¤´éƒ¨æœ‰æ•ˆ
     */
    bool validate_block_header(BlockHeader* header) const;
    
    void* memory_block;        ///< é¢„åˆ†é…çš„å¤§å—å†…å­˜
    size_t block_size;         ///< æ¯ä¸ªå—çš„å¤§å°ï¼ˆå›ºå®šï¼‰
    size_t block_count;        ///< å—çš„æ€»æ•°é‡
    BlockHeader* free_list;    ///< ç©ºé—²å—é“¾è¡¨å¤´æŒ‡é’ˆ
    mutable std::mutex mutex_; ///< çº¿ç¨‹å®‰å…¨é”ï¼ˆmutableå…è®¸åœ¨constæ–¹æ³•ä¸­ä½¿ç”¨ï¼‰
    
    // ç»Ÿè®¡ä¿¡æ¯
    size_t used_count;         ///< å·²ä½¿ç”¨å—æ•°é‡
    size_t total_allocations;  ///< æ€»åˆ†é…æ¬¡æ•°
    size_t total_deallocations;///< æ€»é‡Šæ”¾æ¬¡æ•°
};

} // namespace MemoryPool
} // namespace StringProcessingLib

#endif // STRINGPROCESSINGLIB_MEMORY_POOL_FIXED_SIZE_POOL_H
```

### æ­¥éª¤2ï¼šåˆ›å»ºFixedSizePoolå®ç°æ–‡ä»¶

åˆ›å»º`StringProcessingLib/src/memory_bool/fixed_size_pool.cpp`ï¼š

```cpp
/**
 * @file fixed_size_pool.cpp
 * @brief FixedSizePoolç±»çš„å®ç°
 */

#include "StringProcessingLib/memory_bool/fixed_size_pool.h"
#include <cstdlib>  // std::aligned_alloc, std::free
#include <stdexcept> // std::bad_alloc
#include <cstring>   // memset

namespace StringProcessingLib {
namespace MemoryPool {

// æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–å†…å­˜æ± 
FixedSizePool::FixedSizePool(size_t block_size, size_t block_count)
    : block_size(block_size), block_count(block_count), free_list(nullptr),
      used_count(0), total_allocations(0), total_deallocations(0) {
    
    // 1. é¢„åˆ†é…å¤§å—å†…å­˜
    size_t total_size = block_size * block_count;
    memory_block = std::aligned_alloc(alignof(BlockHeader), total_size);
    
    if (!memory_block) {
        throw std::bad_alloc();
    }
    
    // 2. å°†å†…å­˜åˆå§‹åŒ–ä¸º0ï¼ˆå¯é€‰ï¼Œä½†æœ‰åŠ©äºè°ƒè¯•ï¼‰
    std::memset(memory_block, 0, total_size);
    
    // 3. åˆå§‹åŒ–æ‰€æœ‰å—
    initialize_blocks();
}

// ææ„å‡½æ•°ï¼šé‡Šæ”¾å†…å­˜
FixedSizePool::~FixedSizePool() {
    if (memory_block) {
        std::free(memory_block);
        memory_block = nullptr;
    }
    free_list = nullptr;
}

// åˆå§‹åŒ–æ‰€æœ‰å—
void FixedSizePool::initialize_blocks() {
    // ã€é‡è¦ã€‘ä¸ºä»€ä¹ˆè¦è½¬æ¢ä¸º char*ï¼Ÿ
    // 1. memory_block æ˜¯ void* ç±»å‹ï¼Œvoid* æŒ‡é’ˆä¸èƒ½ç›´æ¥è¿›è¡Œç®—æœ¯è¿ç®—
    //    ä¾‹å¦‚ï¼švoid* ptr; ptr + 1;  // âŒ ç¼–è¯‘é”™è¯¯ï¼švoid* ä¸èƒ½åšæŒ‡é’ˆç®—æœ¯
    // 2. char* æ˜¯å­—èŠ‚æŒ‡é’ˆï¼ŒæŒ‰å­—èŠ‚åç§»ï¼Œå¯ä»¥ç²¾ç¡®æ§åˆ¶å†…å­˜åœ°å€
    //    ä¾‹å¦‚ï¼šchar* ptr; ptr + 10; // âœ… æ­£ç¡®ï¼šå‘ååç§»10ä¸ªå­—èŠ‚
    // 3. åœ¨å†…å­˜æ± ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æŒ‰ block_size å­—èŠ‚ä¸ºå•ä½éå†å†…å­˜å—
    //    ä½¿ç”¨ char* å¯ä»¥æ–¹ä¾¿åœ°è®¡ç®—æ¯ä¸ªå—çš„èµ·å§‹åœ°å€ï¼šptr + i * block_size
    // 4. static_cast æ˜¯å®‰å…¨çš„ç±»å‹è½¬æ¢ï¼švoid* å¯ä»¥è½¬æ¢ä¸ºä»»ä½•å¯¹è±¡æŒ‡é’ˆç±»å‹
    char* ptr = static_cast<char*>(memory_block);
    
    // å°†ç¬¬ä¸€ä¸ªå—åŠ å…¥ç©ºé—²é“¾è¡¨
    // ã€å…³é”®ã€‘reinterpret_cast çš„ä½œç”¨ï¼š
    // 1. ä½œç”¨ï¼šå°† char* å­—èŠ‚æŒ‡é’ˆé‡æ–°è§£é‡Šä¸º BlockHeader* ç»“æ„ä½“æŒ‡é’ˆ
    // 2. ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿå› ä¸ºå†…å­˜å—çš„å¼€å¤´å­˜å‚¨çš„æ˜¯ BlockHeader ç»“æ„ä½“ï¼Œæˆ‘ä»¬éœ€è¦ä»¥ç»“æ„ä½“çš„æ–¹å¼è®¿é—®
    // 3. å·¥ä½œåŸç†ï¼š
    //    - å†…å­˜å¸ƒå±€ï¼š[BlockHeaderç»“æ„ä½“][ç”¨æˆ·æ•°æ®åŒºåŸŸ][BlockHeaderç»“æ„ä½“][ç”¨æˆ·æ•°æ®åŒºåŸŸ]...
    //    - ptr æŒ‡å‘å†…å­˜å—çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼ˆä¹Ÿå°±æ˜¯ç¬¬ä¸€ä¸ª BlockHeader çš„èµ·å§‹åœ°å€ï¼‰
    //    - reinterpret_cast å‘Šè¯‰ç¼–è¯‘å™¨ï¼šå°†è¿™ä¸ªåœ°å€å½“ä½œ BlockHeader ç»“æ„ä½“æ¥è§£é‡Š
    // 4. ä¸ static_cast çš„åŒºåˆ«ï¼š
    //    - static_castï¼šç±»å‹ç›¸å…³è½¬æ¢ï¼Œç¼–è¯‘å™¨ä¼šæ£€æŸ¥ç±»å‹å…¼å®¹æ€§ï¼ˆå¦‚åŸºç±»è½¬æ´¾ç”Ÿç±»ï¼‰
    //    - reinterpret_castï¼šä½æ¨¡å¼é‡æ–°è§£é‡Šï¼Œä¸è¿›è¡Œä»»ä½•æ£€æŸ¥ï¼Œç›´æ¥å°†å†…å­˜å½“ä½œä¸åŒç±»å‹è§£é‡Š
    //    åœ¨æ­¤åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬æ˜ç¡®çŸ¥é“å†…å­˜ä¸­çš„å­—èŠ‚åºåˆ—å°±æ˜¯ BlockHeader ç»“æ„ä½“çš„æ•°æ®ï¼Œæ‰€ä»¥ç”¨ reinterpret_cast
    BlockHeader* first_header = reinterpret_cast<BlockHeader*>(ptr);
    
    // ã€é‡è¦ã€‘reset() æ–¹æ³•çš„ä½œç”¨ï¼š
    // 1. åŠŸèƒ½ï¼šå°† BlockHeader ç»“æ„ä½“çš„æ‰€æœ‰æˆå‘˜å˜é‡é‡ç½®ä¸ºåˆå§‹çŠ¶æ€
    // 2. å…·ä½“æ“ä½œï¼š
    //    - is_free = true              // æ ‡è®°ä¸ºç©ºé—²çŠ¶æ€
    //    - next = nullptr              // æ¸…ç©ºé“¾è¡¨æŒ‡é’ˆ
    //    - prev = nullptr              // æ¸…ç©ºä¸Šä¸€ä¸ªå—æŒ‡é’ˆ
    //    - allocation_count = 0        // é‡ç½®åˆ†é…è®¡æ•°
    //    - last_alloc_time = 0         // é‡ç½®æ—¶é—´æˆ³
    //    - magic = MAGIC_NUMBER        // é‡æ–°è®¾ç½®é­”æ•°ï¼ˆç”¨äºé”™è¯¯æ£€æµ‹ï¼‰
    // 3. ä¸ºä»€ä¹ˆéœ€è¦ reset()ï¼Ÿ
    //    - æ–°åˆ†é…çš„å†…å­˜å—å¯èƒ½åŒ…å«åƒåœ¾æ•°æ®ï¼ˆæœªåˆå§‹åŒ–çš„å€¼ï¼‰
    //    - å¦‚æœä¸é‡ç½®ï¼Œnext å’Œ prev å¯èƒ½åŒ…å«éšæœºå€¼ï¼Œå¯¼è‡´é“¾è¡¨é”™è¯¯
    //    - é‡ç½® magic å¯ä»¥ç¡®ä¿é­”æ•°æ­£ç¡®ï¼Œç”¨äºåç»­çš„é”™è¯¯æ£€æµ‹
    //    - ç¡®ä¿æ‰€æœ‰çŠ¶æ€å˜é‡éƒ½æœ‰æ˜ç¡®çš„åˆå§‹å€¼ï¼Œé¿å…æœªå®šä¹‰è¡Œä¸º
    first_header->reset();
    
    // è®¾ç½®å—å¤§å°
    first_header->size = block_size;
    
    // æ ‡è®°ä¸ºç©ºé—²
    first_header->is_free = true;
    
    // è®¾ç½®ä¸ºé“¾è¡¨æœ«å°¾ï¼ˆç¬¬ä¸€ä¸ªå—ï¼Œæš‚æ—¶æ²¡æœ‰ä¸‹ä¸€ä¸ªå—ï¼‰
    first_header->next = nullptr;
    
    free_list = first_header;
    
    // åˆå§‹åŒ–å…¶ä½™å—
    for (size_t i = 1; i < block_count; ++i) {
        char* block_ptr = ptr + i * block_size;
        BlockHeader* header = reinterpret_cast<BlockHeader*>(block_ptr);
        
        header->reset();
        header->size = block_size;
        header->is_free = true;
        
        // å°†å—åŠ å…¥ç©ºé—²é“¾è¡¨å¤´éƒ¨ï¼ˆO(1)æ“ä½œï¼‰
        header->next = free_list;
        free_list = header;
    }
}

// åˆ†é…ä¸€ä¸ªå†…å­˜å—
void* FixedSizePool::allocate() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 1. æ£€æŸ¥ç©ºé—²é“¾è¡¨æ˜¯å¦ä¸ºç©º
    if (free_list == nullptr) {
        return nullptr; // æ²¡æœ‰ç©ºé—²å—
    }
    
    // 2. ä»é“¾è¡¨å¤´éƒ¨å–å—ï¼ˆO(1)æ“ä½œï¼‰
    BlockHeader* header = free_list;
    free_list = free_list->next;
    
    // 3. æ ‡è®°å—ä¸ºå·²åˆ†é…
    header->mark_allocated();
    header->next = nullptr; // æ¸…é™¤é“¾è¡¨æŒ‡é’ˆ
    
    // 4. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    used_count++;
    total_allocations++;
    
    // 5. è¿”å›ç”¨æˆ·æ•°æ®åŒºåŸŸæŒ‡é’ˆ
    return header->get_user_ptr();
}

// é‡Šæ”¾ä¸€ä¸ªå†…å­˜å—
void FixedSizePool::deallocate(void* user_ptr) {
    if (!user_ptr) return;
    
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 1. ä»ç”¨æˆ·æŒ‡é’ˆè·å–å—å¤´éƒ¨
    BlockHeader* header = get_header_from_user_ptr(user_ptr);
    
    // 2. éªŒè¯å—çš„æœ‰æ•ˆæ€§
    if (!validate_block_header(header)) {
        // é”™è¯¯å¤„ç†ï¼šåŒé‡é‡Šæ”¾æˆ–å†…å­˜æŸå
        // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¿™é‡Œåº”è¯¥è®°å½•é”™è¯¯æ—¥å¿—æˆ–æŠ›å‡ºå¼‚å¸¸
        return;
    }
    
    // 3. æ£€æŸ¥æ˜¯å¦å·²ç»é‡Šæ”¾
    if (header->is_free) {
        // åŒé‡é‡Šæ”¾é”™è¯¯
        // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¿™é‡Œåº”è¯¥è®°å½•é”™è¯¯æ—¥å¿—æˆ–æŠ›å‡ºå¼‚å¸¸
        return;
    }
    
    // 4. æ ‡è®°å—ä¸ºç©ºé—²
    header->mark_free();
    
    // 5. å°†å—æ”¾å›ç©ºé—²é“¾è¡¨å¤´éƒ¨ï¼ˆO(1)æ“ä½œï¼‰
    header->next = free_list;
    free_list = header;
    
    // 6. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    used_count--;
    total_deallocations++;
}

// éªŒè¯å—å¤´éƒ¨çš„æœ‰æ•ˆæ€§
bool FixedSizePool::validate_block_header(BlockHeader* header) const {
    if (!header) return false;
    
    // æ£€æŸ¥é­”æ•°
    if (!header->is_valid()) {
        return false;
    }
    
    // æ£€æŸ¥å—å¤§å°æ˜¯å¦æ­£ç¡®
    if (header->size != block_size) {
        return false;
    }
    
    return true;
}

// è·å–ç»Ÿè®¡ä¿¡æ¯
FixedSizePool::Statistics FixedSizePool::get_statistics() const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    Statistics stats;
    stats.used_count = used_count;
    stats.total_allocations = total_allocations;
    stats.total_deallocations = total_deallocations;
    
    return stats;
}

} // namespace MemoryPool
} // namespace StringProcessingLib
```

### æ­¥éª¤3ï¼šåˆ›å»ºFixedSizePoolæµ‹è¯•æ–‡ä»¶

åˆ›å»º`StringProcessingLib/tests/unit_tests/memory_pool/test_fixed_size_pool.cpp`ï¼š

```cpp
/**
 * @file test_fixed_size_pool.cpp
 * @brief FixedSizePoolå•å…ƒæµ‹è¯•
 */

#include <cassert>
#include <iostream>
#include <cstring>
#include <thread>
#include <vector>
#include "StringProcessingLib/memory_bool/fixed_size_pool.h"

using namespace StringProcessingLib::MemoryPool;

// æµ‹è¯•åŸºæœ¬åˆ†é…å’Œé‡Šæ”¾
void test_basic_allocation() {
    std::cout << "æµ‹è¯•1ï¼šåŸºæœ¬åˆ†é…å’Œé‡Šæ”¾\n";
    
    const size_t BLOCK_SIZE = 256;
    const size_t BLOCK_COUNT = 10;
    
    FixedSizePool pool(BLOCK_SIZE, BLOCK_COUNT);
    
    // åˆ†é…ä¸€ä¸ªå—
    void* ptr1 = pool.allocate();
    assert(ptr1 != nullptr);
    
    // å†™å…¥æ•°æ®æµ‹è¯•
    char* data = static_cast<char*>(ptr1);
    strcpy(data, "Hello, Memory Pool!");
    assert(strcmp(data, "Hello, Memory Pool!") == 0);
    
    // é‡Šæ”¾å—
    pool.deallocate(ptr1);
    
    // å†æ¬¡åˆ†é…åº”è¯¥èƒ½åˆ†é…åˆ°ç›¸åŒæˆ–ä¸åŒçš„å—
    void* ptr2 = pool.allocate();
    assert(ptr2 != nullptr);
    
    std::cout << "  âœ“ åŸºæœ¬åˆ†é…å’Œé‡Šæ”¾æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•åˆ†é…æ‰€æœ‰å—
void test_allocate_all() {
    std::cout << "æµ‹è¯•2ï¼šåˆ†é…æ‰€æœ‰å—\n";
    
    const size_t BLOCK_SIZE = 128;
    const size_t BLOCK_COUNT = 5;
    
    FixedSizePool pool(BLOCK_SIZE, BLOCK_COUNT);
    
    // åˆ†é…æ‰€æœ‰å—
    std::vector<void*> ptrs;
    for (size_t i = 0; i < BLOCK_COUNT; ++i) {
        void* ptr = pool.allocate();
        assert(ptr != nullptr);
        ptrs.push_back(ptr);
    }
    
    // å°è¯•å†åˆ†é…ä¸€ä¸ªåº”è¯¥å¤±è´¥
    void* ptr_fail = pool.allocate();
    assert(ptr_fail == nullptr);
    
    std::cout << "  âœ“ åˆ†é…æ‰€æœ‰å—æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
void test_statistics() {
    std::cout << "æµ‹è¯•3ï¼šç»Ÿè®¡ä¿¡æ¯\n";
    
    FixedSizePool pool(256, 10);
    
    auto stats = pool.get_statistics();
    assert(stats.used_count == 0);
    assert(stats.total_allocations == 0);
    
    // åˆ†é…å’Œé‡Šæ”¾
    void* ptr1 = pool.allocate();
    void* ptr2 = pool.allocate();
    void* ptr3 = pool.allocate();
    
    stats = pool.get_statistics();
    assert(stats.used_count == 3);
    assert(stats.total_allocations == 3);
    
    pool.deallocate(ptr2);
    stats = pool.get_statistics();
    assert(stats.used_count == 2);
    assert(stats.total_deallocations == 1);
    
    std::cout << "  âœ“ ç»Ÿè®¡ä¿¡æ¯æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•é‡å¤é‡Šæ”¾æ£€æµ‹
void test_double_free_detection() {
    std::cout << "æµ‹è¯•4ï¼šé‡å¤é‡Šæ”¾æ£€æµ‹\n";
    
    FixedSizePool pool(256, 10);
    
    void* ptr = pool.allocate();
    pool.deallocate(ptr);
    
    // å†æ¬¡é‡Šæ”¾åº”è¯¥è¢«å¿½ç•¥ï¼ˆä¸å´©æºƒï¼‰
    pool.deallocate(ptr);
    
    // åº”è¯¥è¿˜èƒ½åˆ†é…
    void* ptr2 = pool.allocate();
    assert(ptr2 != nullptr);
    
    std::cout << "  âœ“ é‡å¤é‡Šæ”¾æ£€æµ‹æµ‹è¯•é€šè¿‡\n";
}

// æµ‹è¯•å†…å­˜å¤ç”¨
void test_memory_reuse() {
    std::cout << "æµ‹è¯•5ï¼šå†…å­˜å¤ç”¨\n";
    
    FixedSizePool pool(256, 10);
    
    // åˆ†é…ä¸¤ä¸ªå—
    void* ptr1 = pool.allocate();
    void* ptr2 = pool.allocate();
    
    // é‡Šæ”¾ç¬¬ä¸€ä¸ª
    pool.deallocate(ptr1);
    
    // å†æ¬¡åˆ†é…åº”è¯¥èƒ½ä½¿ç”¨é‡Šæ”¾çš„å—
    void* ptr3 = pool.allocate();
    assert(ptr3 != nullptr);
    
    std::cout << "  âœ“ å†…å­˜å¤ç”¨æµ‹è¯•é€šè¿‡\n";
}

// çº¿ç¨‹å®‰å…¨æµ‹è¯•è¾…åŠ©å‡½æ•°
void thread_safety_worker(FixedSizePool& pool, int thread_id, int iterations) {
    std::vector<void*> allocations;
    
    for (int i = 0; i < iterations; ++i) {
        // åˆ†é…
        void* ptr = pool.allocate();
        if (ptr) {
            allocations.push_back(ptr);
        }
        
        // å¶å°”é‡Šæ”¾
        if (!allocations.empty() && (i % 3 == 0)) {
            void* to_free = allocations.back();
            allocations.pop_back();
            pool.deallocate(to_free);
        }
        
        // çŸ­æš‚ç¡çœ ï¼Œå¢åŠ ç«äº‰
        std::this_thread::sleep_for(std::chrono::microseconds(10));
    }
    
    // é‡Šæ”¾æ‰€æœ‰å‰©ä½™çš„
    for (void* ptr : allocations) {
        pool.deallocate(ptr);
    }
}

// æµ‹è¯•å¤šçº¿ç¨‹å®‰å…¨æ€§
void test_thread_safety() {
    std::cout << "æµ‹è¯•6ï¼šå¤šçº¿ç¨‹å®‰å…¨æ€§\n";
    
    FixedSizePool pool(256, 100);
    const int NUM_THREADS = 4;
    const int ITERATIONS_PER_THREAD = 1000;
    
    std::vector<std::thread> threads;
    
    // å¯åŠ¨å¤šä¸ªçº¿ç¨‹
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads.emplace_back(thread_safety_worker, std::ref(pool), i, ITERATIONS_PER_THREAD);
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& t : threads) {
        t.join();
    }
    
    // æ£€æŸ¥æœ€ç»ˆçŠ¶æ€
    auto stats = pool.get_statistics();
    
    // used_countåº”è¯¥å›åˆ°0ï¼ˆæ‰€æœ‰çº¿ç¨‹éƒ½é‡Šæ”¾äº†ï¼‰
    assert(stats.used_count == 0);
    
    std::cout << "  âœ“ å¤šçº¿ç¨‹å®‰å…¨æµ‹è¯•é€šè¿‡ï¼ˆ" << stats.total_allocations 
              << " æ¬¡åˆ†é…ï¼Œ" << stats.total_deallocations << " æ¬¡é‡Šæ”¾ï¼‰\n";
}

// æµ‹è¯•å†…å­˜å¯¹é½
void test_memory_alignment() {
    std::cout << "æµ‹è¯•7ï¼šå†…å­˜å¯¹é½\n";
    
    // ä½¿ç”¨ä¸åŒçš„å—å¤§å°æµ‹è¯•
    std::vector<size_t> test_sizes = {16, 32, 64, 128, 256};
    
    for (size_t block_size : test_sizes) {
        FixedSizePool pool(block_size, 10);
        
        void* ptr = pool.allocate();
        assert(ptr != nullptr);
        
        // æ£€æŸ¥å¯¹é½ï¼ˆåœ°å€åº”è¯¥æ˜¯sizeof(void*)çš„å€æ•°ï¼‰
        uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
        assert(addr % sizeof(void*) == 0);
    }
    
    std::cout << "  âœ“ å†…å­˜å¯¹é½æµ‹è¯•é€šè¿‡\n";
}

// ä¸»æµ‹è¯•å‡½æ•°
int main() {
    std::cout << "========== FixedSizePoolå•å…ƒæµ‹è¯•å¼€å§‹ ==========\n\n";
    
    try {
        test_basic_allocation();
        test_allocate_all();
        test_statistics();
        test_double_free_detection();
        test_memory_reuse();
        test_thread_safety();
        test_memory_alignment();
        
        std::cout << "\n========== æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼==========\n";
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "\næµ‹è¯•å¤±è´¥: " << e.what() << "\n";
        return 1;
    }
}
```

### æ­¥éª¤4ï¼šç¼–è¯‘å’Œæµ‹è¯•FixedSizePool

```bash
# åœ¨buildç›®å½•ä¸­é‡æ–°ç¼–è¯‘
cd StringProcessingLib/build
cmake ..
make

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
ctest --output-on-failure

# æˆ–è€…å•ç‹¬è¿è¡Œæµ‹è¯•
./bin/test_block_header
./bin/test_fixed_size_pool
```

**é¢„æœŸè¾“å‡º**ï¼š
```
Test project /home/jonson/cuda-learning/æ¯å‘¨é¢˜ç›®/C++é¢˜ç›®/ç¬¬1å‘¨/StringProcessingLib/build
    Start 1: BlockHeaderTest
1/2 Test #1: BlockHeaderTest .................   Passed    0.00 sec
    Start 2: FixedSizePoolTest
2/2 Test #2: FixedSizePoolTest ...............   Passed    0.01 sec

100% tests passed, 0 tests failed out of 2
```

---

## ç¬¬ä¸‰é˜¶æ®µï¼šæµ‹è¯•å’ŒéªŒè¯

### æ­¥éª¤1ï¼šåˆ›å»ºç¤ºä¾‹ç¨‹åº

åˆ›å»º`StringProcessingLib/examples/basic_usage/memory_pool_example.cpp`ï¼š

```cpp
/**
 * @file memory_pool_example.cpp
 * @brief å†…å­˜æ± ä½¿ç”¨ç¤ºä¾‹
 */

#include <iostream>
#include <vector>
#include "StringProcessingLib/memory_bool/fixed_size_pool.h"

using namespace StringProcessingLib::MemoryPool;

int main() {
    std::cout << "========== å†…å­˜æ± ä½¿ç”¨ç¤ºä¾‹ ==========\n\n";
    
    // åˆ›å»ºä¸€ä¸ªå†…å­˜æ± ï¼šå—å¤§å°256å­—èŠ‚ï¼Œæ€»å…±10ä¸ªå—
    FixedSizePool pool(256, 10);
    
    std::cout << "1. å†…å­˜æ± åˆ›å»ºæˆåŠŸ\n";
    std::cout << "   - å—å¤§å°: 256 å­—èŠ‚\n";
    std::cout << "   - æ€»å—æ•°: 10\n";
    std::cout << "   - æ€»å†…å­˜: " << (256 * 10) << " å­—èŠ‚\n\n";
    
    // åˆ†é…ä¸€äº›å†…å­˜
    std::vector<void*> allocations;
    std::cout << "2. åˆ†é…5ä¸ªå†…å­˜å—\n";
    for (int i = 0; i < 5; ++i) {
        void* ptr = pool.allocate();
        if (ptr) {
            allocations.push_back(ptr);
            std::cout << "   åˆ†é…å— " << (i+1) << " @ " << ptr << "\n";
        }
    }
    
    auto stats = pool.get_statistics();
    std::cout << "\n3. å½“å‰ç»Ÿè®¡ä¿¡æ¯:\n";
    std::cout << "   - å·²ä½¿ç”¨å—: " << stats.used_count << "\n";
    std::cout << "   - æ€»åˆ†é…æ¬¡æ•°: " << stats.total_allocations << "\n\n";
    
    // é‡Šæ”¾ä¸€åŠ
    std::cout << "4. é‡Šæ”¾2ä¸ªå†…å­˜å—\n";
    for (int i = 0; i < 2; ++i) {
        pool.deallocate(allocations[i]);
    }
    
    stats = pool.get_statistics();
    std::cout << "   - å·²ä½¿ç”¨å—: " << stats.used_count << "\n";
    std::cout << "   - æ€»é‡Šæ”¾æ¬¡æ•°: " << stats.total_deallocations << "\n\n";
    
    // ä½¿ç”¨å†…å­˜
    std::cout << "5. ä½¿ç”¨å†…å­˜ç¤ºä¾‹\n";
    char* data = static_cast<char*>(allocations[2]);
    snprintf(data, 256, "Hello from Memory Pool! Block size: %zu", 256);
    std::cout << "   å†™å…¥æ•°æ®: " << data << "\n\n";
    
    std::cout << "6. æœ€ç»ˆç»Ÿè®¡ä¿¡æ¯:\n";
    stats = pool.get_statistics();
    std::cout << "   - å·²ä½¿ç”¨å—: " << stats.used_count << "\n";
    std::cout << "   - æ€»åˆ†é…æ¬¡æ•°: " << stats.total_allocations << "\n";
    std::cout << "   - æ€»é‡Šæ”¾æ¬¡æ•°: " << stats.total_deallocations << "\n\n";
    
    std::cout << "========== ç¤ºä¾‹å®Œæˆ ==========\n";
    
    return 0;
}
```

### æ­¥éª¤2ï¼šæ·»åŠ ç¤ºä¾‹çš„CMakeLists.txt

```bash
cat > StringProcessingLib/examples/CMakeLists.txt << 'EOF'
add_subdirectory(basic_usage)
EOF

cat > StringProcessingLib/examples/basic_usage/CMakeLists.txt << 'EOF'
add_executable(memory_pool_example memory_pool_example.cpp)
target_link_libraries(memory_pool_example stringprocessinglib)
EOF
```

### æ­¥éª¤3ï¼šç¼–è¯‘å’Œè¿è¡Œç¤ºä¾‹

```bash
cd StringProcessingLib/build
cmake ..
make

# è¿è¡Œç¤ºä¾‹
./bin/memory_pool_example
```

### æ­¥éª¤4ï¼šæ€§èƒ½å¯¹æ¯”æµ‹è¯•

åˆ›å»ºæ€§èƒ½æµ‹è¯•ç¨‹åº`StringProcessingLib/tests/performance_tests/benchmark_pool.cpp`ï¼š

```cpp
/**
 * @file benchmark_pool.cpp
 * @brief å†…å­˜æ± æ€§èƒ½æµ‹è¯•
 */

#include <iostream>
#include <chrono>
#include <random>
#include <vector>
#include <cstdlib>
#include "StringProcessingLib/memory_bool/fixed_size_pool.h"

using namespace StringProcessingLib::MemoryPool;
using namespace std::chrono;

void benchmark_standard_malloc(int iterations) {
    auto start = high_resolution_clock::now();
    
    std::vector<void*> ptrs;
    ptrs.reserve(iterations);
    
    for (int i = 0; i < iterations; ++i) {
        void* ptr = std::malloc(256);
        if (ptr) {
            ptrs.push_back(ptr);
        }
    }
    
    for (void* ptr : ptrs) {
        std::free(ptr);
    }
    
    auto end = high_resolution_clock::now();
    auto duration = duration_cast<microseconds>(end - start);
    
    std::cout << "æ ‡å‡†malloc: " << duration.count() << " å¾®ç§’\n";
}

void benchmark_memory_pool(FixedSizePool& pool, int iterations) {
    auto start = high_resolution_clock::now();
    
    std::vector<void*> ptrs;
    ptrs.reserve(iterations);
    
    for (int i = 0; i < iterations; ++i) {
        void* ptr = pool.allocate();
        if (ptr) {
            ptrs.push_back(ptr);
        }
    }
    
    for (void* ptr : ptrs) {
        pool.deallocate(ptr);
    }
    
    auto end = high_resolution_clock::now();
    auto duration = duration_cast<microseconds>(end - start);
    
    std::cout << "å†…å­˜æ± : " << duration.count() << " å¾®ç§’\n";
}

int main() {
    const int ITERATIONS = 100000;
    const int BLOCK_SIZE = 256;
    const int BLOCK_COUNT = 1000;
    
    std::cout << "========== æ€§èƒ½å¯¹æ¯”æµ‹è¯• ==========\n";
    std::cout << "è¿­ä»£æ¬¡æ•°: " << ITERATIONS << "\n";
    std::cout << "å—å¤§å°: " << BLOCK_SIZE << " å­—èŠ‚\n\n";
    
    // æ ‡å‡†mallocæ€§èƒ½
    std::cout << "æµ‹è¯•1ï¼šæ ‡å‡†malloc/free\n";
    benchmark_standard_malloc(ITERATIONS);
    
    // å†…å­˜æ± æ€§èƒ½
    FixedSizePool pool(BLOCK_SIZE, BLOCK_COUNT);
    std::cout << "\næµ‹è¯•2ï¼šå†…å­˜æ± åˆ†é…/é‡Šæ”¾\n";
    benchmark_memory_pool(pool, ITERATIONS);
    
    auto stats = pool.get_statistics();
    std::cout << "\nå†…å­˜æ± ç»Ÿè®¡:\n";
    std::cout << "- æ€»åˆ†é…æ¬¡æ•°: " << stats.total_allocations << "\n";
    std::cout << "- æ€»é‡Šæ”¾æ¬¡æ•°: " << stats.total_deallocations << "\n";
    
    std::cout << "\n========== æµ‹è¯•å®Œæˆ ==========\n";
    
    return 0;
}
```

ç¼–è¯‘å’Œè¿è¡Œï¼š
```bash
# æ·»åŠ åˆ°CMakeLists.txtä¸­
echo 'add_subdirectory(performance_tests)' >> StringProcessingLib/tests/CMakeLists.txt

mkdir -p StringProcessingLib/tests/performance_tests
cat > StringProcessingLib/tests/performance_tests/CMakeLists.txt << 'EOF'
add_executable(benchmark_pool benchmark_pool.cpp)
target_link_libraries(benchmark_pool stringprocessinglib)
EOF

# ç¼–è¯‘
cd StringProcessingLib/build
cmake ..
make

# è¿è¡Œï¼ˆReleaseæ¨¡å¼ä»¥è·å¾—æ›´å‡†ç¡®çš„æ€§èƒ½æ•°æ®ï¼‰
cmake -DCMAKE_BUILD_TYPE=Release ..
make
./bin/benchmark_pool
```

---

## ç¬¬å››é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–

### æ­¥éª¤1ï¼šä½¿ç”¨å†…å­˜åˆ†æå·¥å…·

ä½¿ç”¨Valgrindæ£€æŸ¥å†…å­˜æ³„æ¼ï¼š
```bash
cd StringProcessingLib/build

# ç¼–è¯‘Debugç‰ˆæœ¬
cmake -DCMAKE_BUILD_TYPE=Debug ..
make

# ä½¿ç”¨Valgrindè¿è¡Œæµ‹è¯•
valgrind --leak-check=full --show-leak-kinds=all ./bin/test_fixed_size_pool

# æˆ–ä½¿ç”¨massifè¿›è¡Œå†…å­˜åˆ†æ
valgrind --tool=massif ./bin/test_fixed_size_pool
ms_print massif.out.*
```

### æ­¥éª¤2ï¼šä»£ç è¦†ç›–ç‡æµ‹è¯•

å®‰è£…gcovå’Œlcovï¼ˆå¦‚æœæœªå®‰è£…ï¼‰ï¼š
```bash
sudo apt-get install -y gcov lcov
```

é‡æ–°ç¼–è¯‘å¹¶ç”Ÿæˆè¦†ç›–ç‡ï¼š
```bash
cd StringProcessingLib/build
cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_FLAGS="--coverage" ..
make
ctest

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
lcov --capture --directory . --output-file coverage.info
lcov --remove coverage.info '/usr/*' --output-file coverage.info
genhtml coverage.info --output-directory coverage
```

æŸ¥çœ‹æŠ¥å‘Šï¼š
```bash
firefox coverage/index.html
```

---

## å¸¸è§é—®é¢˜å’Œè°ƒè¯•

### é—®é¢˜1ï¼šç¼–è¯‘é”™è¯¯ "undefined reference to `std::mutex`"

**åŸå› **ï¼šç¼ºå°‘pthreadé“¾æ¥

**è§£å†³æ–¹æ¡ˆ**ï¼šç¡®ä¿åœ¨CMakeLists.txtä¸­æœ‰ï¼š
```cmake
target_link_libraries(stringprocessinglib PUBLIC pthread)
```

### é—®é¢˜2ï¼šå†…å­˜å¯¹é½é”™è¯¯

**ç°è±¡**ï¼šè¿è¡Œæ—¶å´©æºƒï¼Œé”™è¯¯ä¿¡æ¯åŒ…å«"aligned_alloc"

**æ£€æŸ¥æ–¹æ³•**ï¼š
```cpp
// åœ¨initialize_blocks()åæ·»åŠ æ£€æŸ¥
void* test_ptr = pool.allocate();
uintptr_t addr = reinterpret_cast<uintptr_t>(test_ptr);
std::cout << "å¯¹é½æ£€æŸ¥: " << (addr % alignof(void*)) << "\n";
```

### é—®é¢˜3ï¼šåŒé‡é‡Šæ”¾æ£€æµ‹æ— æ•ˆ

**æ£€æŸ¥**ï¼šç¡®ä¿`validate_block_header`æ­£ç¡®æ£€æŸ¥é­”æ•°å’Œå—å¤§å°

**è°ƒè¯•å»ºè®®**ï¼šæ·»åŠ æ—¥å¿—è¾“å‡º
```cpp
void FixedSizePool::deallocate(void* user_ptr) {
    // æ·»åŠ è°ƒè¯•è¾“å‡º
    std::cout << "é‡Šæ”¾æŒ‡é’ˆ: " << user_ptr << "\n";
    BlockHeader* header = get_header_from_user_ptr(user_ptr);
    std::cout << "å¤´éƒ¨åœ°å€: " << header << "\n";
    std::cout << "é­”æ•°: " << std::hex << header->magic << std::dec << "\n";
    // ...
}
```

### é—®é¢˜4ï¼šå¤šçº¿ç¨‹æ­»é”

**æ£€æŸ¥**ï¼šç¡®ä¿æ‰€æœ‰mutexç”¨æ³•éƒ½ä½¿ç”¨`std::lock_guard`ï¼Œé¿å…æ‰‹åŠ¨lock/unlock

**è°ƒè¯•å»ºè®®**ï¼šä½¿ç”¨gdbï¼š
```bash
gdb ./bin/test_fixed_size_pool
(gdb) run
# å¦‚æœæ­»é”ï¼ŒæŒ‰Ctrl+C
(gdb) thread apply all bt
```

### é—®é¢˜5ï¼šæ€§èƒ½ä¸å¦‚æ ‡å‡†malloc

**å¯èƒ½åŸå› **ï¼š
1. Debugæ¨¡å¼ç¼–è¯‘
2. æµ‹è¯•æ•°æ®å¤ªå°
3. é”ç«äº‰ä¸¥é‡

**ä¼˜åŒ–å»ºè®®**ï¼š
1. ä½¿ç”¨Releaseæ¨¡å¼ï¼š`-DCMAKE_BUILD_TYPE=Release`
2. å¢åŠ æµ‹è¯•è¿­ä»£æ¬¡æ•°
3. è€ƒè™‘ä½¿ç”¨æ— é”ç¼–ç¨‹ï¼ˆé«˜çº§ä¸»é¢˜ï¼‰

---

## æ€»ç»“æ£€æŸ¥æ¸…å•

åœ¨å®Œæˆæ‰€æœ‰é˜¶æ®µåï¼Œè¯·æ£€æŸ¥ï¼š

- [ ] æ‰€æœ‰æ–‡ä»¶ç¼–è¯‘æˆåŠŸ
- [ ] å•å…ƒæµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] æ²¡æœ‰å†…å­˜æ³„æ¼ï¼ˆValgrindæ£€æŸ¥ï¼‰
- [ ] ä»£ç è¦†ç›–ç‡ >80%
- [ ] æ€§èƒ½æµ‹è¯•æ˜¾ç¤ºå†…å­˜æ± ä¼˜äºæ ‡å‡†malloc
- [ ] å¤šçº¿ç¨‹æµ‹è¯•é€šè¿‡
- [ ] ç¤ºä¾‹ç¨‹åºè¿è¡Œæ­£ç¡®
- [ ] ä»£ç å·²æ ¼å¼åŒ–ï¼ˆclang-formatï¼‰
- [ ] ä»£ç å·²é€šè¿‡æ£€æŸ¥ï¼ˆclang-tidyï¼‰

å®Œæˆä»¥ä¸Šæ‰€æœ‰æ­¥éª¤åï¼Œæ‚¨å·²ç»æˆåŠŸå®ç°äº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€çº¿ç¨‹å®‰å…¨ã€é«˜æ€§èƒ½çš„å›ºå®šå¤§å°å†…å­˜æ± ï¼

æ­å–œï¼ğŸ‰



