# 内存池扩展设计面试题

## 题目1：实现标准分配器接口
**难度：⭐⭐⭐⭐**

### 问题描述
C++ 标准库提供了 `std::allocator` 接口。请实现：
1. 如何让 `FixedSizePool` 兼容 `std::allocator`？
2. 需要实现哪些接口？
3. 如何与 STL 容器集成？

### 参考答案要点
1. **标准分配器接口**：
   ```cpp
   template<typename T>
   class PoolAllocator {
   public:
       using value_type = T;
       using pointer = T*;
       using const_pointer = const T*;
       using size_type = std::size_t;
       
       PoolAllocator(FixedSizePool* pool) : pool_(pool) {}
       
       template<typename U>
       PoolAllocator(const PoolAllocator<U>& other) 
           : pool_(other.pool_) {}
       
       pointer allocate(size_type n) {
           void* ptr = pool_->allocate(n * sizeof(T));
           return static_cast<pointer>(ptr);
       }
       
       void deallocate(pointer p, size_type n) {
           pool_->deallocate(p);
       }
   };
   ```

2. **必需接口**：
   - `allocate(size_type n)`
   - `deallocate(pointer p, size_type n)`
   - 复制构造函数
   - `operator==` 和 `operator!=`

3. **STL 集成**：
   ```cpp
   FixedSizePool pool(sizeof(int), 1000);
   PoolAllocator<int> alloc(&pool);
   std::vector<int, PoolAllocator<int>> vec(alloc);
   ```

### 评分标准
- 实现标准分配器接口（2分）
- 列出必需接口（1分）
- 说明 STL 集成方法（2分）

---

## 题目2：可变大小内存池设计
**难度：⭐⭐⭐⭐⭐**

### 问题描述
当前实现是固定大小的，请设计一个支持可变大小的内存池：
1. 如何管理不同大小的块？
2. 如何实现内存合并（coalescing）？
3. 使用什么算法来选择块（首次适配、最佳适配等）？

### 参考答案要点
1. **管理不同大小的块**：
   - 使用多个空闲链表，按大小分类
   - 或者使用单一链表，按大小排序
   - 使用平衡树或跳表快速查找

2. **内存合并**：
   ```cpp
   void coalesce_blocks(BlockHeader* block) {
       // 检查前一个块
       BlockHeader* prev = get_previous_block(block);
       if (prev && prev->is_free) {
           merge_blocks(prev, block);
           block = prev;
       }
       
       // 检查后一个块
       BlockHeader* next = get_next_block(block);
       if (next && next->is_free) {
           merge_blocks(block, next);
       }
   }
   ```

3. **选择算法**：
   - **首次适配**：找到第一个满足大小的块（快，可能有碎片）
   - **最佳适配**：找到最接近请求大小的块（慢，碎片少）
   - **最差适配**：找到最大的块（适合大块请求）

### 评分标准
- 设计可变大小管理（2分）
- 实现内存合并（2分）
- 说明选择算法（1分）

---

## 题目3：内存池的监控和统计
**难度：⭐⭐⭐**

### 问题描述
生产环境需要监控内存池的使用情况。请设计：
1. 需要统计哪些指标？
2. 如何实现统计功能？
3. 如何输出统计报告？

### 参考答案要点
1. **统计指标**：
   - 总分配次数
   - 总释放次数
   - 当前使用块数
   - 峰值使用块数
   - 分配失败次数
   - 内存利用率

2. **实现统计**：
   ```cpp
   class PoolStatistics {
       std::atomic<size_t> total_allocations{0};
       std::atomic<size_t> total_deallocations{0};
       std::atomic<size_t> peak_usage{0};
       std::atomic<size_t> failed_allocations{0};
       
       void record_allocation() {
           total_allocations++;
           size_t current = use_count.load();
           size_t peak = peak_usage.load();
           while (current > peak && 
                  !peak_usage.compare_exchange_weak(peak, current)) {
               peak = peak_usage.load();
           }
       }
   };
   ```

3. **输出报告**：
   ```cpp
   void print_statistics() const {
       std::cout << "Total Allocations: " << total_allocations << "\n";
       std::cout << "Total Deallocations: " << total_deallocations << "\n";
       std::cout << "Peak Usage: " << peak_usage << "\n";
       std::cout << "Failed Allocations: " << failed_allocations << "\n";
       std::cout << "Current Usage: " << use_count << "\n";
       std::cout << "Usage Rate: " << 
           (100.0 * use_count / block_count) << "%\n";
   }
   ```

### 评分标准
- 列出统计指标（1分）
- 实现统计功能（2分）
- 设计报告输出（2分）

---

## 题目4：内存池的调试支持
**难度：⭐⭐⭐**

### 问题描述
调试内存问题非常困难。请设计调试功能：
1. 如何检测内存泄漏？
2. 如何检测内存损坏？
3. 如何记录分配调用栈？

### 参考答案要点
1. **内存泄漏检测**：
   ```cpp
   #ifdef DEBUG
   std::unordered_map<void*, AllocationInfo> active_allocations;
   
   void* allocate(size_t size) {
       void* ptr = /* 分配逻辑 */;
       active_allocations[ptr] = {
           .size = size,
           .timestamp = get_timestamp(),
           .callstack = capture_callstack()
       };
       return ptr;
   }
   
   ~FixedSizePool() {
       if (!active_allocations.empty()) {
           // 报告泄漏
       }
   }
   #endif
   ```

2. **内存损坏检测**：
   - 使用 magic number（已实现）
   - 在分配时填充特殊值（如 0xCD）
   - 在释放时填充特殊值（如 0xDD）
   - 定期检查 magic number

3. **调用栈记录**：
   ```cpp
   #ifdef DEBUG
   #include <execinfo.h>
   
   std::vector<void*> capture_callstack(int max_frames = 10) {
       std::vector<void*> frames(max_frames);
       int count = backtrace(frames.data(), max_frames);
       frames.resize(count);
       return frames;
   }
   #endif
   ```

### 评分标准
- 实现泄漏检测（2分）
- 实现损坏检测（2分）
- 实现调用栈记录（1分）

---

## 题目5：分层内存池设计
**难度：⭐⭐⭐⭐⭐**

### 问题描述
大型系统可能需要多个内存池。请设计一个内存池管理器：
1. 如何管理多个内存池？
2. 如何选择合适的池进行分配？
3. 如何实现池之间的内存共享？

### 参考答案要点
1. **管理器设计**：
   ```cpp
   class MemoryPoolManager {
       std::vector<std::unique_ptr<FixedSizePool>> pools;
       std::map<size_t, FixedSizePool*> size_to_pool;
       
   public:
       void* allocate(size_t size) {
           // 找到合适的池
           auto it = size_to_pool.lower_bound(size);
           if (it != size_to_pool.end()) {
               return it->second->allocate(size);
           }
           // 回退到标准分配器
           return std::malloc(size);
       }
   };
   ```

2. **选择策略**：
   - 向上取整到最近的池大小
   - 考虑内存利用率
   - 考虑分配性能

3. **内存共享**：
   - 实现跨池的内存转移
   - 使用全局内存池作为后备
   - 考虑性能开销

### 评分标准
- 设计管理器结构（2分）
- 实现选择策略（2分）
- 说明内存共享方案（1分）

---

## 题目6：内存池的性能分析工具
**难度：⭐⭐⭐⭐**

### 问题描述
请设计一个性能分析工具来分析内存池的使用：
1. 需要记录哪些性能指标？
2. 如何实现低开销的追踪？
3. 如何可视化性能数据？

### 参考答案要点
1. **性能指标**：
   - 分配/释放延迟（P50, P95, P99）
   - 吞吐量（ops/sec）
   - 锁竞争时间
   - 缓存命中率

2. **低开销追踪**：
   ```cpp
   class PerformanceTracker {
       std::atomic<uint64_t> allocation_count{0};
       std::atomic<uint64_t> total_time_ns{0};
       
       void record_allocation(uint64_t time_ns) {
           allocation_count.fetch_add(1);
           total_time_ns.fetch_add(time_ns);
       }
       
       double get_average_latency() const {
           return total_time_ns.load() / 
                  (double)allocation_count.load();
       }
   };
   ```

3. **可视化**：
   - 输出 JSON 格式数据
   - 使用时间序列数据库
   - 使用图表库可视化（如 matplotlib）

### 评分标准
- 列出性能指标（1分）
- 实现低开销追踪（2分）
- 提出可视化方案（2分）
