# 内存池性能优化面试题

## 题目1：减少内存碎片
**难度：⭐⭐⭐⭐**

### 问题描述
内存池虽然可以减少碎片，但仍然可能存在碎片问题。请分析：
1. 固定大小内存池是否会产生碎片？
2. 如何进一步减少碎片？
3. 内部碎片和外部碎片的区别是什么？

### 参考答案要点
1. **固定大小池的碎片**：
   - **内部碎片**：可能不存在（所有块大小相同）
   - **外部碎片**：如果池大小不是块大小的整数倍，可能存在
   - 固定大小池的主要优势就是减少碎片

2. **减少碎片的方法**：
   - 确保池大小是块大小的整数倍
   - 使用对齐分配，避免未对齐导致的浪费
   - 选择合适的块大小，平衡内存利用率和分配次数

3. **碎片类型**：
   - **内部碎片**：分配的内存块中未使用的部分
   - **外部碎片**：内存中存在小的空闲块，无法满足大块请求

### 评分标准
- 分析固定大小池的碎片问题（2分）
- 提出减少碎片的方法（2分）
- 区分内部和外部碎片（1分）

---

## 题目2：缓存友好的内存布局
**难度：⭐⭐⭐⭐⭐**

### 问题描述
现代 CPU 依赖缓存来提高性能。请考虑：
1. 如何设计内存池的布局以提高缓存命中率？
2. 空闲链表应该如何使用才能提高缓存性能？
3. 什么是 False Sharing，如何避免？

### 参考答案要点
1. **缓存友好的布局**：
   - 将频繁访问的数据放在一起（如 BlockHeader）
   - 减少指针跳转，提高局部性
   - 使用数组 + 索引代替链表（提高缓存命中率）

2. **空闲链表优化**：
   - 使用栈式分配（LIFO），最近释放的块优先分配
   - 这样可以提高缓存命中率（数据可能还在缓存中）
   - 考虑预取（prefetch）下一个可能分配的块

3. **False Sharing**：
   - 多个线程访问同一缓存行的不同数据
   - 导致缓存行在 CPU 间频繁移动
   - **解决方案**：将每个线程的数据对齐到缓存行边界（通常64字节）

### 评分标准
- 提出缓存友好的布局（2分）
- 优化空闲链表使用（2分）
- 说明 False Sharing 及避免方法（1分）

---

## 题目3：分配器的性能对比
**难度：⭐⭐⭐**

### 问题描述
请设计一个性能测试，对比：
1. 内存池分配器 vs 标准分配器（malloc/new）
2. 固定大小池 vs 可变大小池
3. 有锁 vs 无锁实现

### 参考答案要点
1. **测试指标**：
   - 分配/释放时间
   - 内存利用率
   - 线程竞争情况
   - 缓存命中率

2. **测试场景**：
   ```cpp
   // 分配释放循环
   for (int i = 0; i < iterations; ++i) {
       void* ptr = pool.allocate(size);
       // 使用内存
       pool.deallocate(ptr);
   }
   
   // 多线程测试
   std::vector<std::thread> threads;
   for (int i = 0; i < thread_count; ++i) {
       threads.emplace_back([&pool]() {
           // 分配释放操作
       });
   }
   ```

3. **预期结果**：
   - 内存池应该比 malloc 快 2-10 倍
   - 固定大小池比可变大小池快
   - 无锁实现在高竞争场景下可能更快

### 评分标准
- 设计测试指标（1分）
- 编写测试代码（2分）
- 分析预期结果（2分）

---

## 题目4：批量分配优化
**难度：⭐⭐⭐⭐**

### 问题描述
在某些场景下，需要连续分配多个内存块。请设计：
1. 如何实现批量分配接口？
2. 批量分配相比单个分配有什么优势？
3. 如何实现批量释放？

### 参考答案要点
1. **批量分配接口**：
   ```cpp
   std::vector<void*> allocate_batch(size_t count, size_t size) {
       std::vector<void*> result;
       result.reserve(count);
       
       std::lock_guard<std::mutex> lock(mutex_);
       for (size_t i = 0; i < count && free_list != nullptr; ++i) {
           BlockHeader* header = free_list;
           free_list = header->next;
           header->mark_allocated();
           result.push_back(header->get_user_ptr());
       }
       return result;
   }
   ```

2. **批量分配优势**：
   - 减少锁的获取次数
   - 提高缓存局部性
   - 减少函数调用开销

3. **批量释放**：
   ```cpp
   void deallocate_batch(std::vector<void*>& ptrs) {
       std::lock_guard<std::mutex> lock(mutex_);
       for (void* ptr : ptrs) {
           BlockHeader* header = get_header_from_user_ptr(ptr);
           header->reset();
           header->next = free_list;
           free_list = header;
       }
   }
   ```

### 评分标准
- 实现批量分配（2分）
- 说明优势（1分）
- 实现批量释放（2分）

---

## 题目5：内存预取（Prefetching）
**难度：⭐⭐⭐⭐⭐**

### 问题描述
现代 CPU 支持硬件预取。请考虑：
1. 如何在内存池中使用预取？
2. 预取哪些数据最有效？
3. 如何避免过度预取导致的性能下降？

### 参考答案要点
1. **预取策略**：
   ```cpp
   void* allocate(size_t size) {
       // 预取下一个可能分配的块
       if (free_list && free_list->next) {
           __builtin_prefetch(free_list->next, 0, 3);
       }
       
       // 正常分配逻辑
       BlockHeader* header = free_list;
       // ...
   }
   ```

2. **预取目标**：
   - 下一个空闲块的 BlockHeader
   - 用户数据区域（如果分配后立即使用）
   - 避免预取不必要的数据

3. **避免过度预取**：
   - 只在有高概率使用时预取
   - 监控预取效果，调整策略
   - 考虑 CPU 的预取能力限制

### 评分标准
- 实现预取逻辑（2分）
- 说明预取目标（2分）
- 考虑避免过度预取（1分）

---

## 题目6：内存池大小的选择
**难度：⭐⭐⭐**

### 问题描述
内存池的大小选择对性能有重要影响。请分析：
1. 如何确定合适的块大小？
2. 如何确定合适的块数量？
3. 如何动态调整池的大小？

### 参考答案要点
1. **块大小选择**：
   - 根据实际使用场景（最常见分配大小）
   - 考虑对齐要求
   - 平衡内存利用率和分配次数
   - 可以参考对象的实际大小

2. **块数量选择**：
   - 根据峰值并发需求
   - 考虑内存限制
   - 预留一定的余量（如 20%）
   - 可以通过监控调整

3. **动态调整**：
   - 监控使用率和分配失败次数
   - 当使用率超过阈值时扩容
   - 当使用率过低时考虑缩容（复杂）
   - 需要重新分配和迁移数据

### 评分标准
- 说明块大小选择方法（2分）
- 说明块数量选择方法（2分）
- 提出动态调整方案（1分）
