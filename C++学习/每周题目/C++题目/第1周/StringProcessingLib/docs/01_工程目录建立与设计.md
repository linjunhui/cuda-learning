# 工程目录建立与设计

## 1. 标准 C++ 项目目录结构

### 1.1 推荐的目录结构

```
StringProcessingLib/
├── CMakeLists.txt              # 主构建文件
├── README.md                   # 项目说明文档
├── include/                    # 公共头文件目录
│   └── StringProcessingLib/   # 命名空间对应的目录
│       └── memory_pool/        # 功能模块目录
│           ├── fixed_size_pool.h
│           └── block_header.h
├── src/                        # 源文件目录
│   └── memory_pool/
│       ├── fixed_size_pool.cpp
│       └── block_header.cpp
├── tests/                      # 测试文件目录
│   └── unit_tests/
│       └── memory_pool/
│           ├── test_fixed_size_pool.cpp
│           └── test_block_header.cpp
├── docs/                       # 文档目录
│   ├── 01_工程目录建立与设计.md
│   ├── 02_CMake基础教程.md
│   └── 03_GoogleTest基础教程.md
└── build/                     # 构建输出目录（gitignore）
```

### 1.2 目录结构设计原则

#### **include/ 目录**
- **目的**：存放所有公共头文件
- **规则**：
  - 头文件路径应该反映命名空间结构
  - 例如：`include/StringProcessingLib/memory_pool/fixed_size_pool.h`
  - 对应命名空间：`namespace StringProcessingLib { namespace MemoryPool { ... } }`
- **优势**：
  - 清晰的命名空间映射
  - 避免头文件名称冲突
  - 便于其他项目引用

#### **src/ 目录**
- **目的**：存放所有实现文件（.cpp）
- **规则**：
  - 目录结构通常与 `include/` 保持一致
  - 便于查找对应的头文件和源文件
- **优势**：
  - 代码组织清晰
  - 便于维护和扩展

#### **tests/ 目录**
- **目的**：存放所有测试代码
- **规则**：
  - 通常与 `src/` 结构对应
  - 测试文件以 `test_` 前缀命名
- **优势**：
  - 测试代码与实现代码分离
  - 便于管理和维护

#### **build/ 目录**
- **目的**：存放 CMake 生成的构建文件
- **规则**：
  - 通常添加到 `.gitignore`
  - 每次 `cmake ..` 时在此目录执行

### 1.3 命名空间与目录的关系

```cpp
// 文件路径：include/StringProcessingLib/memory_pool/fixed_size_pool.h
namespace StringProcessingLib {
namespace MemoryPool {
    class FixedSizePool {
        // ...
    };
} // namespace MemoryPool
} // namespace StringProcessingLib
```

**映射关系**：
- 目录结构 → 命名空间层次
- `StringProcessingLib/` → `namespace StringProcessingLib`
- `memory_pool/` → `namespace MemoryPool`

## 2. 文件组织最佳实践

### 2.1 头文件设计

```cpp
// fixed_size_pool.h
#ifndef STRINGPROCESSINGLIB_MEMORY_POOL_FIXED_SIZE_POOL_H
#define STRINGPROCESSINGLIB_MEMORY_POOL_FIXED_SIZE_POOL_H

// 标准库头文件
#include <mutex>
#include <cstddef>

// 项目内部头文件
#include "StringProcessingLib/memory_pool/block_header.h"

namespace StringProcessingLib {
namespace MemoryPool {

class FixedSizePool {
    // ...
};

} // namespace MemoryPool
} // namespace StringProcessingLib

#endif // STRINGPROCESSINGLIB_MEMORY_POOL_FIXED_SIZE_POOL_H
```

**要点**：
1. **头文件保护**：防止重复包含
2. **包含顺序**：标准库 → 第三方库 → 项目内部头文件
3. **命名空间**：与目录结构对应

### 2.2 源文件设计

```cpp
// fixed_size_pool.cpp
#include "StringProcessingLib/memory_pool/fixed_size_pool.h"

// 标准库头文件（如果需要）
#include <new>
#include <cstdlib>

namespace StringProcessingLib {
namespace MemoryPool {

// 实现代码
FixedSizePool::FixedSizePool(size_t block_size, size_t block_count) {
    // ...
}

} // namespace MemoryPool
} // namespace StringProcessingLib
```

**要点**：
1. **首先包含对应的头文件**
2. **标准库头文件放在后面**（如果头文件未包含）
3. **实现必须在命名空间内**

## 3. CMakeLists.txt 与目录结构的关系

### 3.1 包含目录配置

```cmake
# 设置包含目录，使 #include "StringProcessingLib/..." 能正常工作
include_directories(include)

# 或者使用现代方式
target_include_directories(StringProcessingLib
    PUBLIC
        include
)
```

### 3.2 源文件路径配置

```cmake
# 相对于 CMakeLists.txt 的路径
set(SOURCES
    src/memory_pool/fixed_size_pool.cpp
    src/memory_pool/block_header.cpp
)
```

### 3.3 测试文件路径配置

```cmake
set(TEST_SOURCES
    tests/unit_tests/memory_pool/test_fixed_size_pool.cpp
)
```

## 4. 常见问题与解决方案

### 4.1 路径不一致问题

**问题**：头文件路径与 include 路径不匹配

```cpp
// ❌ 错误
#include "memory_pool/fixed_size_pool.h"

// ✅ 正确
#include "StringProcessingLib/memory_pool/fixed_size_pool.h"
```

**解决方案**：
- 确保 `include_directories(include)` 已设置
- 使用完整的命名空间路径

### 4.2 命名空间不一致

**问题**：头文件中类在命名空间内，但源文件中实现不在命名空间内

```cpp
// ❌ 错误
// fixed_size_pool.cpp
void FixedSizePool::method() {  // 在全局命名空间

// ✅ 正确
namespace StringProcessingLib {
namespace MemoryPool {
    void FixedSizePool::method() {
        // ...
    }
} // namespace MemoryPool
} // namespace StringProcessingLib
```

### 4.3 缺少头文件保护

**问题**：头文件被多次包含导致重复定义

```cpp
// ❌ 错误：没有头文件保护
class FixedSizePool { ... };

// ✅ 正确：有头文件保护
#ifndef GUARD_NAME
#define GUARD_NAME
class FixedSizePool { ... };
#endif
```

## 5. 项目扩展指南

### 5.1 添加新模块

```
include/StringProcessingLib/
├── memory_pool/      # 已有模块
└── string_utils/     # 新模块
    ├── string_utils.h
    └── helper.h

src/
├── memory_pool/
└── string_utils/     # 对应实现
    ├── string_utils.cpp
    └── helper.cpp
```

### 5.2 更新 CMakeLists.txt

```cmake
# 添加新的源文件
set(SOURCES
    src/memory_pool/fixed_size_pool.cpp
    src/string_utils/string_utils.cpp  # 新增
)

# 添加新的测试
set(TEST_SOURCES
    tests/unit_tests/memory_pool/test_fixed_size_pool.cpp
    tests/unit_tests/string_utils/test_string_utils.cpp  # 新增
)
```

## 6. 总结

### 最佳实践清单

- ✅ 使用清晰的目录结构反映命名空间
- ✅ 头文件路径与命名空间对应
- ✅ 源文件与头文件目录结构一致
- ✅ 测试文件单独组织在 tests/ 目录
- ✅ 使用头文件保护防止重复包含
- ✅ 保持命名空间在头文件和源文件中一致
- ✅ 构建目录（build/）不提交到版本控制

### 目录结构的好处

1. **可维护性**：清晰的目录结构便于查找和修改代码
2. **可扩展性**：添加新模块时遵循相同的模式
3. **可理解性**：新团队成员能快速理解项目结构
4. **可重用性**：标准化的结构便于代码重用
