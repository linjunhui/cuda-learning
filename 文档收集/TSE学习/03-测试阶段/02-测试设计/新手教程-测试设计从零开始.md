# 测试设计 - 新手完整教程

## 📖 写在前面

欢迎学习测试设计！如果你是完全的新手，本教程将从最基础的概念开始，用通俗易懂的语言和丰富的例子，一步步教会你如何进行测试设计。

**测试设计是测试工程师的核心技能**，学会测试设计，你就能：
- 设计出全面、有效的测试用例
- 发现更多缺陷
- 提高测试效率和质量

---

## 第一部分：基础知识 - 什么是测试设计？

### 1.1 测试设计是什么？

想象一下，你要测试一个计算器：

**没有测试设计**：
```
测试人员："我随便点点，看能不能用"
结果：可能漏掉很多问题
```

**有了测试设计**：
```
测试人员："我设计了测试用例：
  1. 正常情况：1+1应该等于2
  2. 边界情况：999999999+1应该等于多少
  3. 异常情况：输入字母会怎样
  4. 界面测试：按钮点击是否正常"
结果：系统全面地测试，发现更多问题
```

**测试设计**就是：
- **思考如何测试**：要测试什么、怎么测试
- **设计测试用例**：把测试想法写成具体的测试步骤
- **确保覆盖完整**：不漏掉重要的测试场景

### 1.2 为什么需要测试设计？

**没有测试设计的问题**：
- ❌ 测试不全面，漏掉很多缺陷
- ❌ 测试效率低，重复测试
- ❌ 不知道测试是否充分
- ❌ 测试结果不可重现

**有了测试设计的好处**：
- ✅ 测试更全面，发现更多问题
- ✅ 测试效率高，有计划的测试
- ✅ 清楚知道测试覆盖了哪些场景
- ✅ 测试结果可重现，便于回归

### 1.3 测试设计的目标

测试设计的核心目标是：
1. **发现缺陷**：找到系统中的错误
2. **验证功能**：确保功能按需求正确实现
3. **提高质量**：保证软件质量
4. **降低风险**：减少上线后的问题

---

## 第二部分：测试设计基础方法

### 2.1 等价类划分法

#### 什么是等价类？

**概念**：把输入数据分成几类，同一类中的数据测试效果相同。

**例子**：测试"年龄输入"功能（要求18-65岁）

**等价类划分**：
```
有效等价类：
  - 18-65岁的数字（如：25、30、50）→ 这些测试一个就够了

无效等价类：
  - 小于18的数字（如：10、15、17）→ 测试一个代表
  - 大于65的数字（如：70、80、100）→ 测试一个代表
  - 负数（如：-5、-10）→ 测试一个代表
  - 小数（如：25.5、30.8）→ 测试一个代表
  - 字母（如：abc、test）→ 测试一个代表
  - 空值 → 测试空值
```

**测试用例设计**：

| 用例编号 | 输入数据 | 预期结果 | 等价类 |
|---------|---------|---------|--------|
| TC-001 | 30 | 验证通过，接受输入 | 有效等价类 |
| TC-002 | 10 | 显示错误"年龄必须在18-65之间" | 小于18 |
| TC-003 | 70 | 显示错误"年龄必须在18-65之间" | 大于65 |
| TC-004 | -5 | 显示错误"请输入有效的年龄" | 负数 |
| TC-005 | 25.5 | 显示错误"年龄必须是整数" | 小数 |
| TC-006 | abc | 显示错误"请输入数字" | 字母 |
| TC-007 | （空） | 显示错误"年龄不能为空" | 空值 |

**新手提示**：
- 每个等价类至少选一个测试数据
- 有效等价类和无效等价类都要测试
- 选择代表性的数据（边界值附近）

### 2.2 边界值分析法

#### 什么是边界值？

**概念**：测试输入范围的边界，因为边界是最容易出错的地方。

**例子**：年龄要求18-65岁

**边界值**：
```
上边界：65（最大值）
下边界：18（最小值）
边界外：17和66（刚超出边界）
边界内：19和64（刚在边界内）
```

**边界值测试用例**：

| 用例编号 | 输入数据 | 预期结果 | 说明 |
|---------|---------|---------|------|
| TC-008 | 17 | 错误："年龄必须≥18" | 下边界外 |
| TC-009 | 18 | 通过 | 下边界 |
| TC-010 | 19 | 通过 | 下边界内 |
| TC-011 | 64 | 通过 | 上边界内 |
| TC-012 | 65 | 通过 | 上边界 |
| TC-013 | 66 | 错误："年龄必须≤65" | 上边界外 |

**新手提示**：
- 边界值 = 最大值、最小值
- 边界外 = 最大值+1、最小值-1
- 边界内 = 最大值-1、最小值+1

### 2.3 场景法（流程测试）

#### 什么是场景法？

**概念**：按照用户使用系统的实际场景来设计测试用例。

**例子**：在线购物流程

**主流程（正常场景）**：
```
场景1：用户成功购买商品
  1. 用户登录
  2. 浏览商品
  3. 选择商品加入购物车
  4. 进入购物车
  5. 点击结算
  6. 填写收货地址
  7. 选择支付方式
  8. 确认订单
  9. 支付成功
  10. 订单创建成功
```

**异常场景**：
```
场景2：购物车为空时结算
  1. 用户登录
  2. 购物车为空
  3. 点击结算
  → 显示"购物车为空，请先添加商品"
```

```
场景3：库存不足
  1. 用户选择商品
  2. 商品库存为0
  3. 点击加入购物车
  → 显示"库存不足"
```

**新手提示**：
- 先画主流程（正常路径）
- 再考虑异常路径
- 每个分支都要覆盖

### 2.4 错误推测法

#### 什么是错误推测？

**概念**：基于经验，推测可能出错的地方。

**常见错误类型**：
1. **空值错误**：未输入、输入空格
2. **格式错误**：邮箱格式、手机号格式
3. **长度错误**：输入太长、太短
4. **特殊字符错误**：输入特殊符号
5. **并发错误**：同时操作

**例子**：注册功能

**错误推测测试用例**：

| 推测的错误 | 测试用例 | 预期结果 |
|-----------|---------|---------|
| 空值 | 所有字段为空，点击注册 | 显示相应的错误提示 |
| 邮箱格式错误 | 输入"test@"（不完整邮箱） | 显示"邮箱格式不正确" |
| 密码太短 | 输入"123"（要求至少8位） | 显示"密码至少8位" |
| 密码包含特殊字符 | 输入"密码!@#" | 根据规则判断是否允许 |
| 重复注册 | 用已存在的邮箱注册 | 显示"邮箱已被注册" |

---

## 第三部分：实战教程 - 手把手设计测试用例

### 3.1 实战案例：登录功能测试设计

#### 第一步：理解需求

**需求描述**：
```
用户登录功能：
- 用户输入用户名和密码
- 系统验证用户名和密码
- 验证通过则允许登录，跳转到主页
- 验证失败则显示错误信息
```

**需求澄清**（向产品经理提问）：
1. 用户名可以用邮箱还是手机号？
2. 密码有长度要求吗？
3. 登录失败几次会锁定账号？
4. 忘记密码怎么处理？

**澄清后的需求**：
- 用户名可以是邮箱或手机号
- 密码长度6-20位，包含字母和数字
- 连续3次失败锁定账号30分钟
- 忘记密码功能（后续版本）

#### 第二步：识别测试点

**功能测试点**：
1. 正常登录
2. 用户名错误
3. 密码错误
4. 用户名和密码都错误
5. 输入为空
6. 账号被锁定
7. 用户名格式验证（邮箱、手机号）

#### 第三步：设计测试用例

**使用等价类 + 边界值 + 错误推测**

**测试用例表**：

| 用例ID | 测试场景 | 输入数据 | 预期结果 | 优先级 |
|--------|---------|---------|---------|--------|
| TC-LOGIN-001 | 正常登录（邮箱） | 邮箱：test@example.com<br>密码：Test123456 | 登录成功，跳转主页 | P0 |
| TC-LOGIN-002 | 正常登录（手机号） | 手机号：13812345678<br>密码：Test123456 | 登录成功，跳转主页 | P0 |
| TC-LOGIN-003 | 邮箱格式错误 | 邮箱：test@<br>密码：Test123456 | 显示"邮箱格式不正确" | P1 |
| TC-LOGIN-004 | 手机号格式错误 | 手机号：1381234<br>密码：Test123456 | 显示"手机号格式不正确" | P1 |
| TC-LOGIN-005 | 密码错误 | 邮箱：test@example.com<br>密码：WrongPass | 显示"用户名或密码错误" | P0 |
| TC-LOGIN-006 | 用户名不存在 | 邮箱：notexist@example.com<br>密码：Test123456 | 显示"用户名或密码错误" | P1 |
| TC-LOGIN-007 | 邮箱为空 | 邮箱：空<br>密码：Test123456 | 显示"邮箱不能为空" | P1 |
| TC-LOGIN-008 | 密码为空 | 邮箱：test@example.com<br>密码：空 | 显示"密码不能为空" | P1 |
| TC-LOGIN-009 | 密码长度不足（5位） | 邮箱：test@example.com<br>密码：Test1 | 显示"密码长度必须6-20位" | P1 |
| TC-LOGIN-010 | 密码长度边界（6位） | 邮箱：test@example.com<br>密码：Test12 | 登录成功 | P1 |
| TC-LOGIN-011 | 密码长度边界（20位） | 邮箱：test@example.com<br>密码：Test1234567890123 | 登录成功 | P1 |
| TC-LOGIN-012 | 密码超长（21位） | 邮箱：test@example.com<br>密码：Test12345678901234 | 显示"密码长度不能超过20位" | P1 |
| TC-LOGIN-013 | 账号锁定（3次失败） | 连续3次输入错误密码 | 第3次后显示"账号已锁定，30分钟后重试" | P0 |
| TC-LOGIN-014 | 账号锁定后尝试登录 | 账号已锁定，输入正确密码 | 显示"账号已锁定，请30分钟后再试" | P0 |
| TC-LOGIN-015 | 密码包含特殊字符 | 邮箱：test@example.com<br>密码：Test@123 | 根据业务规则判断 | P2 |

**详细测试用例示例（TC-LOGIN-001）**：

```
测试用例ID：TC-LOGIN-001
测试用例名称：用户使用正确邮箱和密码登录成功
优先级：P0
前置条件：
  - 系统中存在用户：邮箱test@example.com，密码Test123456，状态激活
  - 用户未登录
测试步骤：
  1. 访问登录页面
  2. 在邮箱输入框输入"test@example.com"
  3. 在密码输入框输入"Test123456"
  4. 点击"登录"按钮
预期结果：
  1. 系统验证用户名和密码匹配
  2. 系统创建用户会话
  3. 系统显示"登录成功"提示
  4. 系统跳转到主页
  5. 页面显示欢迎消息"欢迎，test"
  6. 浏览器保存登录状态（cookie/session）
```

### 3.2 测试用例编写规范

#### 测试用例包含的要素

1. **用例ID**：唯一标识，如TC-LOGIN-001
2. **用例名称**：简洁描述测试内容
3. **优先级**：P0（必须）、P1（重要）、P2（一般）
4. **前置条件**：执行测试前的系统状态
5. **测试步骤**：详细的操作步骤
6. **预期结果**：每个步骤的预期结果
7. **实际结果**：（执行后填写）
8. **测试状态**：（执行后填写：通过/失败/阻塞）

#### 编写技巧

**✅ 好的测试用例**：
- 步骤清晰，按顺序编号
- 每一步都有预期结果
- 可以独立执行
- 任何人执行都能得到相同结果

**❌ 差的测试用例**：
- 步骤模糊："测试登录功能"
- 缺少预期结果
- 依赖其他用例的状态
- 描述不清，有歧义

---

## 第四部分：测试分层策略

### 4.1 什么是测试分层？

**概念**：按照测试的粒度（范围）分为不同层次。

**常见的测试分层**：

```
┌─────────────────────────────────────┐
│  系统测试（ST - System Test）       │  ← 测试整个系统
│  功能测试（FT - Function Test）    │  ← 测试功能模块
│  单元测试（UT - Unit Test）        │  ← 测试单个函数/类
└─────────────────────────────────────┘
```

### 4.2 测试分层详解

#### UT - 单元测试（Unit Test）

**测试对象**：单个函数、类、方法

**例子**：
```python
# 要测试的函数
def calculate_price(price, discount):
    if discount < 0 or discount > 1:
        return None
    return price * (1 - discount)

# 单元测试用例
测试用例1：正常折扣
  输入：price=100, discount=0.1
  预期：返回90

测试用例2：折扣为0
  输入：price=100, discount=0
  预期：返回100

测试用例3：折扣无效（负数）
  输入：price=100, discount=-0.1
  预期：返回None

测试用例4：折扣无效（大于1）
  输入：price=100, discount=1.5
  预期：返回None
```

**特点**：
- 测试粒度最小
- 执行速度快
- 通常由开发人员编写

#### FT - 功能测试（Function Test）

**测试对象**：一个完整的功能模块

**例子**：登录功能
- 测试登录的完整流程
- 测试各种输入情况
- 测试界面交互

**特点**：
- 测试一个功能点
- 关注功能是否按需求实现
- 通常由测试人员编写

#### ST - 系统测试（System Test）

**测试对象**：整个系统

**例子**：用户购买流程
- 用户注册 → 浏览商品 → 下单 → 支付 → 收货
- 测试整个业务流程
- 测试系统各模块的协作

**特点**：
- 测试整个系统
- 关注业务流程
- 模拟真实用户场景

### 4.3 如何选择测试层级？

**原则**：
- **单元测试**：测试底层逻辑（计算、验证等）
- **功能测试**：测试功能模块（登录、注册等）
- **系统测试**：测试业务流程（购物、支付等）

**例子**：登录功能的分层测试

```
单元测试（UT）：
  - 测试密码加密函数
  - 测试邮箱格式验证函数
  - 测试会话管理函数

功能测试（FT）：
  - 测试登录功能
  - 测试各种输入情况
  - 测试错误处理

系统测试（ST）：
  - 测试用户登录后的完整流程
  - 测试登录与其他功能的集成
```

---

## 第五部分：ATDD和BDD - 测试驱动的方法

### 5.1 ATDD - 验收测试驱动开发

#### 什么是ATDD？

**概念**：在开发之前，先写验收测试（也就是测试用例），然后用测试驱动开发。

**流程**：
```
1. 写验收测试（测试用例）
   ↓
2. 看测试失败（因为还没开发）
   ↓
3. 开发功能
   ↓
4. 运行测试，看是否通过
   ↓
5. 测试通过，功能完成
```

**例子**：

**步骤1：写验收测试**
```
验收标准：
  - 用户输入邮箱"test@example.com"和密码"Test123"
  - 点击登录
  - 系统验证成功，跳转主页
```

**步骤2：开发功能**

**步骤3：运行测试**
- 如果通过 → 功能完成 ✅
- 如果不通过 → 继续开发直到通过 ✅

**优点**：
- 需求更清晰（用测试用例表达需求）
- 开发目标明确（让测试通过）
- 质量有保障（测试覆盖需求）

### 5.2 BDD - 行为驱动开发

#### 什么是BDD？

**概念**：用自然语言描述系统行为，然后转化为可执行的测试。

**格式**：Given-When-Then（和实例化需求一样）

**例子**：

**BDD格式的测试用例**：
```gherkin
场景：用户成功登录

Given 系统中存在用户：
  | 邮箱 | 密码 | 状态 |
  | test@example.com | Test123 | 激活 |

When 用户执行以下操作：
  | 操作 | 输入 |
  | 输入邮箱 | test@example.com |
  | 输入密码 | Test123 |
  | 点击登录 | - |

Then 系统应该：
  - 验证用户名和密码匹配
  - 创建用户会话
  - 显示"登录成功"
  - 跳转到主页
```

**优点**：
- 用自然语言，易理解
- 可以自动执行（用工具如Cucumber）
- 需求和测试用例一致

### 5.3 ATDD和BDD的关系

```
ATDD（验收测试驱动开发）
  ↓
BDD（行为驱动开发）
  ↓
用Given-When-Then格式写测试用例
  ↓
转化为可执行的测试代码
```

**简单理解**：
- ATDD是思想：先写测试，再开发
- BDD是方法：用Given-When-Then格式写测试

---

## 第六部分：测试自动化分析

### 6.1 什么时候需要自动化？

**适合自动化的测试**：
- ✅ **重复执行**：需要反复运行的测试
- ✅ **稳定不变**：功能稳定的测试
- ✅ **耗时操作**：执行时间长的测试
- ✅ **回归测试**：每次版本都要测的

**不适合自动化的测试**：
- ❌ **一次性的测试**：只测一次的功能
- ❌ **经常变化**：需求经常变的功能
- ❌ **界面测试**：UI经常调整的测试
- ❌ **探索性测试**：需要人工思考的

### 6.2 如何判断是否可以自动化？

**判断标准**：

| 评估维度 | 评分（1-5分） | 说明 |
|---------|-------------|------|
| 重复执行次数 | 高（5分）= 每天执行，低（1分）= 偶尔执行 | |
| 功能稳定性 | 高（5分）= 很少变化，低（1分）= 经常变化 | |
| 自动化难度 | 低（5分）= 容易自动化，高（1分）= 很难自动化 | |
| 执行时间 | 长（5分）= 执行时间长，短（1分）= 执行很快 | |

**总分 ≥ 15分**：强烈建议自动化
**总分 10-14分**：可以考虑自动化
**总分 < 10分**：不建议自动化

**例子**：登录功能自动化评估

```
重复执行次数：5分（每个版本都要测试）
功能稳定性：4分（登录功能比较稳定）
自动化难度：5分（登录测试容易自动化）
执行时间：3分（登录测试很快）

总分：17分 → 强烈建议自动化
```

---

## 第七部分：实战练习

### 练习1：设计"用户注册"功能的测试用例

**任务**：
1. 使用等价类划分法识别测试点
2. 使用边界值分析法补充用例
3. 设计至少15个测试用例

**提示**：
- 考虑：邮箱格式、密码规则、必填项验证等
- 参考登录功能的测试用例设计

### 练习2：设计"购物车"功能的测试用例

**任务**：
1. 使用场景法画出主要流程
2. 设计正常场景的测试用例
3. 设计异常场景的测试用例

**提示**：
- 主流程：添加商品 → 修改数量 → 删除商品 → 结算
- 异常：库存不足、商品下架、价格变化等

---

## 第八部分：测试设计检查清单

设计完测试用例后，检查：

### 覆盖完整性 ✅
- [ ] 正常流程已覆盖
- [ ] 异常流程已覆盖
- [ ] 边界值已测试
- [ ] 错误情况已考虑

### 用例质量 ✅
- [ ] 用例步骤清晰
- [ ] 预期结果明确
- [ ] 用例可以独立执行
- [ ] 用例无重复

### 优先级合理 ✅
- [ ] P0用例覆盖核心功能
- [ ] 优先级划分合理
- [ ] 关键场景都是P0

---

## 第九部分：常见问题和解答

### Q1：测试用例要写多详细？

**A**：
- **详细程度**：要让没参与设计的人也能执行
- **包含内容**：步骤、输入数据、预期结果
- **原则**：清晰 > 详细

### Q2：如何保证测试覆盖完整？

**A**：
- 使用多种方法：等价类 + 边界值 + 场景法
- 检查需求文档，确保每个需求都有对应测试
- 使用检查清单自查

### Q3：测试用例和需求的关系？

**A**：
- 测试用例验证需求是否实现
- 一个需求对应多个测试用例（正常+异常+边界）
- 需求变更时，测试用例也要更新

---

## 第十部分：下一步学习

### 学完本教程后：

1. **继续学习**：
   - KYM和TCO分析方法
   - PPDCS建模方法
   - 威胁建模和安全测试

2. **实际应用**：
   - 在实际项目中设计测试用例
   - 使用测试工具
   - 积累测试设计经验

3. **深入提升**：
   - 学习更高级的测试设计方法
   - 学习测试策略制定
   - 学习测试自动化

---

## 🎉 恭喜你！

如果你读到这里，说明你已经掌握了测试设计的基础知识。

**记住**：
- **多练习**：设计测试用例是个实践性很强的技能
- **多思考**：思考用户会怎么用，会遇到什么问题
- **多总结**：每次设计后总结经验，持续改进

**祝你测试设计之路顺利！** 🚀

---

**需要帮助？**
- 参考：[测试设计实践案例](./实践案例/)
- 参考：[测试用例设计模板](./模板/)
- 提问：找有经验的测试同事




