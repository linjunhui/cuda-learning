# 内存池分配释放实现详解

## 1. 固定大小内存池的分配释放实现

### 1.1 固定大小池的数据结构

```cpp
class FixedSizePool {
private:
    void* memory_block;        // 预分配的大块内存
    size_t block_size;        // 每个块的大小（固定）
    size_t block_count;       // 块的总数量
    BlockHeader* free_list;    // 空闲块链表头指针
    std::mutex mutex_;         // 线程安全锁
    
    // 统计信息
    size_t used_count;        // 已使用块数量
    size_t total_allocations; // 总分配次数
    size_t total_deallocations; // 总释放次数
};
```

### 1.2 固定大小池的初始化

```cpp
FixedSizePool::FixedSizePool(size_t block_size, size_t block_count) 
    : block_size(block_size), block_count(block_count), free_list(nullptr),
      used_count(0), total_allocations(0), total_deallocations(0) {
    
    // 1. 预分配大块内存
    size_t total_size = block_size * block_count;
    memory_block = std::aligned_alloc(alignof(BlockHeader), total_size);
    
    if (!memory_block) {
        throw std::bad_alloc();
    }
    
    // 2. 初始化所有块
    initialize_blocks();
}

void FixedSizePool::initialize_blocks() {
    // 【重要】为什么要转换为 char*？
    // 1. memory_block 是 void* 类型，void* 指针不能直接进行算术运算
    //    例如：void* ptr; ptr + 1;  // ❌ 编译错误：void* 不能做指针算术
    // 2. char* 是字节指针，按字节偏移，可以精确控制内存地址
    //    例如：char* ptr; ptr + 10; // ✅ 正确：向后偏移10个字节
    // 3. 在内存池中，我们需要按 block_size 字节为单位遍历内存块
    //    使用 char* 可以方便地计算每个块的起始地址：ptr + i * block_size
    // 4. static_cast 是安全的类型转换：void* 可以转换为任何对象指针类型
    char* ptr = static_cast<char*>(memory_block);
    
    // 将第一个块加入空闲链表
    // 【关键】reinterpret_cast 的作用：
    // 1. 作用：将 char* 字节指针重新解释为 BlockHeader* 结构体指针
    // 2. 为什么需要？因为内存块的开头存储的是 BlockHeader 结构体，我们需要以结构体的方式访问
    // 3. 工作原理：
    //    - 内存布局：[BlockHeader结构体][用户数据区域][BlockHeader结构体][用户数据区域]...
    //    - ptr 指向内存块的第一个字节（也就是第一个 BlockHeader 的起始地址）
    //    - reinterpret_cast 告诉编译器：将这个地址当作 BlockHeader 结构体来解释
    // 4. 与 static_cast 的区别：
    //    - static_cast：类型相关转换，编译器会检查类型兼容性（如基类转派生类）
    //    - reinterpret_cast：位模式重新解释，不进行任何检查，直接将内存当作不同类型解释
    //    在此场景中，我们明确知道内存中的字节序列就是 BlockHeader 结构体的数据，所以用 reinterpret_cast
    BlockHeader* first_header = reinterpret_cast<BlockHeader*>(ptr);
    
    // 【重要】reset() 方法的作用：
    // 1. 功能：将 BlockHeader 结构体的所有成员变量重置为初始状态
    // 2. 具体操作：
    //    - is_free = true              // 标记为空闲状态
    //    - next = nullptr              // 清空链表指针（因为是第一个块，还没有连接其他块）
    //    - prev = nullptr              // 清空上一个块指针
    //    - allocation_count = 0        // 重置分配计数
    //    - last_alloc_time = 0         // 重置时间戳
    //    - magic = MAGIC_NUMBER        // 重新设置魔数（用于错误检测）
    // 3. 为什么需要 reset()？
    //    - 新分配的内存块可能包含垃圾数据（未初始化的值）
    //    - 如果不重置，next 和 prev 可能包含随机值，导致链表错误
    //    - 重置 magic 可以确保魔数正确，用于后续的错误检测
    //    - 确保所有状态变量都有明确的初始值，避免未定义行为
    first_header->reset();
    
    // 设置块大小（reset() 不会修改 size，所以需要单独设置）
    first_header->size = block_size;
    
    // 标记为空闲（redundant，因为 reset() 已经设置了，但保留以明确意图）
    first_header->is_free = true;
    
    // 设置为链表末尾（第一个块，暂时没有下一个块）
    first_header->next = nullptr;
    
    free_list = first_header;
    
    // 初始化其余块
    for (size_t i = 1; i < block_count; ++i) {
        char* block_ptr = ptr + i * block_size;
        BlockHeader* header = reinterpret_cast<BlockHeader*>(block_ptr);
        
        header->reset();
        header->size = block_size;
        header->is_free = true;
        
        // 将块加入空闲链表
        header->next = free_list;
        free_list = header;
    }
}
```

### 1.3 固定大小池的分配实现

```cpp
void* FixedSizePool::allocate() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 1. 检查空闲链表是否为空
    if (free_list == nullptr) {
        return nullptr; // 没有空闲块
    }
    
    // 2. 从链表头部取块（O(1)操作）
    BlockHeader* header = free_list;
    free_list = free_list->next;
    
    // 3. 标记块为已分配
    header->mark_allocated();
    header->next = nullptr; // 清除链表指针
    
    // 4. 更新统计信息
    used_count++;
    total_allocations++;
    
    // 5. 返回用户数据区域指针
    return header->get_user_ptr();
}
```

**分配流程详解**：
1. **加锁**：确保线程安全
2. **检查空闲链表**：如果为空则分配失败
3. **取块**：从链表头部取第一个空闲块（O(1)）
4. **更新状态**：标记块为已分配
5. **更新统计**：记录分配次数
6. **返回指针**：返回用户数据区域

### 1.4 固定大小池的释放实现

```cpp
void FixedSizePool::deallocate(void* user_ptr) {
    if (!user_ptr) return;
    
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 1. 从用户指针获取块头部
    BlockHeader* header = get_header_from_user_ptr(user_ptr);
    
    // 2. 验证块的有效性
    if (!validate_block_header(header)) {
        // 错误处理：双重释放或内存损坏
        handle_deallocation_error(header);
        return;
    }
    
    // 3. 检查是否已经释放
    if (header->is_free) {
        // 双重释放错误
        handle_double_free_error(header);
        return;
    }
    
    // 4. 标记块为空闲
    header->mark_free();
    
    // 5. 将块放回空闲链表头部（O(1)操作）
    header->next = free_list;
    free_list = header;
    
    // 6. 更新统计信息
    used_count--;
    total_deallocations++;
}
```

**释放流程详解**：
1. **参数检查**：检查用户指针是否有效
2. **加锁**：确保线程安全
3. **获取头部**：从用户指针计算块头部地址
4. **验证有效性**：检查魔数、大小等
5. **检查状态**：防止双重释放
6. **更新状态**：标记块为空闲
7. **放回链表**：将块放回链表头部（O(1)）
8. **更新统计**：记录释放次数

## 2. 可变大小内存池的分配释放实现

### 2.1 可变大小池的数据结构

```cpp
class VariableSizePool {
private:
    void* memory_block;        // 预分配的大块内存
    size_t total_size;         // 总内存大小
    BlockHeader* free_tree;    // 空闲块红黑树根节点
    std::mutex mutex_;         // 线程安全锁
    
    // 统计信息
    size_t used_bytes;         // 已使用字节数
    size_t total_allocations;  // 总分配次数
    size_t total_deallocations; // 总释放次数
    size_t fragmentation_bytes; // 碎片字节数
};
```

### 2.2 可变大小池的初始化

```cpp
VariableSizePool::VariableSizePool(size_t total_size) 
    : total_size(total_size), free_tree(nullptr),
      used_bytes(0), total_allocations(0), total_deallocations(0),
      fragmentation_bytes(0) {
    
    // 1. 预分配大块内存
    memory_block = std::aligned_alloc(alignof(BlockHeader), total_size);
    
    if (!memory_block) {
        throw std::bad_alloc();
    }
    
    // 2. 初始化整个内存块为一个大的空闲块
    initialize_single_block();
}

void VariableSizePool::initialize_single_block() {
    BlockHeader* header = reinterpret_cast<BlockHeader*>(memory_block);
    
    header->reset();
    header->size = total_size;
    header->is_free = true;
    header->next = nullptr;
    header->prev = nullptr;
    
    // 将块插入红黑树
    insert_into_free_tree(header);
}
```

### 2.3 可变大小池的分配实现

```cpp
void* VariableSizePool::allocate(size_t user_size) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 1. 计算实际需要的块大小
    size_t required_size = calculate_aligned_block_size(user_size);
    
    // 2. 在红黑树中查找最佳适配块
    BlockHeader* best_block = find_best_fit(required_size);
    
    if (!best_block) {
        return nullptr; // 没有合适的块
    }
    
    // 3. 从红黑树中移除块
    remove_from_free_tree(best_block);
    
    // 4. 检查是否需要分割块
    if (best_block->size > required_size + sizeof(BlockHeader) + MIN_FRAGMENT_SIZE) {
        // 分割块
        BlockHeader* remaining_block = split_block(best_block, required_size);
        if (remaining_block) {
            insert_into_free_tree(remaining_block);
        }
    }
    
    // 5. 标记块为已分配
    best_block->mark_allocated();
    
    // 6. 更新统计信息
    used_bytes += best_block->size;
    total_allocations++;
    
    // 7. 返回用户数据区域指针
    return best_block->get_user_ptr();
}

BlockHeader* VariableSizePool::find_best_fit(size_t required_size) {
    BlockHeader* best_block = nullptr;
    BlockHeader* current = free_tree;
    
    while (current) {
        if (current->size >= required_size) {
            if (!best_block || current->size < best_block->size) {
                best_block = current;
            }
            // 继续查找更小的块
            current = current->left;
        } else {
            // 当前块太小，查找更大的块
            current = current->right;
        }
    }
    
    return best_block;
}

BlockHeader* VariableSizePool::split_block(BlockHeader* block, size_t required_size) {
    // 计算剩余块的位置
    char* block_ptr = reinterpret_cast<char*>(block);
    char* remaining_ptr = block_ptr + required_size;
    
    // 创建剩余块
    BlockHeader* remaining_block = reinterpret_cast<BlockHeader*>(remaining_ptr);
    remaining_block->reset();
    remaining_block->size = block->size - required_size;
    remaining_block->is_free = true;
    
    // 更新原块大小
    block->size = required_size;
    
    return remaining_block;
}
```

### 2.4 可变大小池的释放实现

```cpp
void VariableSizePool::deallocate(void* user_ptr) {
    if (!user_ptr) return;
    
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 1. 从用户指针获取块头部
    BlockHeader* header = get_header_from_user_ptr(user_ptr);
    
    // 2. 验证块的有效性
    if (!validate_block_header(header)) {
        handle_deallocation_error(header);
        return;
    }
    
    // 3. 检查是否已经释放
    if (header->is_free) {
        handle_double_free_error(header);
        return;
    }
    
    // 4. 标记块为空闲
    header->mark_free();
    
    // 5. 尝试合并相邻的空闲块
    BlockHeader* merged_block = merge_adjacent_blocks(header);
    
    // 6. 将合并后的块插入红黑树
    insert_into_free_tree(merged_block);
    
    // 7. 更新统计信息
    used_bytes -= header->size;
    total_deallocations++;
}

BlockHeader* VariableSizePool::merge_adjacent_blocks(BlockHeader* block) {
    BlockHeader* merged_block = block;
    
    // 检查前一个块是否空闲
    BlockHeader* prev_block = get_previous_block(block);
    if (prev_block && prev_block->is_free) {
        // 从前一个块开始合并
        merged_block = prev_block;
        merged_block->size += block->size;
        
        // 从红黑树中移除前一个块
        remove_from_free_tree(prev_block);
    }
    
    // 检查后一个块是否空闲
    BlockHeader* next_block = get_next_block(block);
    if (next_block && next_block->is_free) {
        // 合并后一个块
        merged_block->size += next_block->size;
        
        // 从红黑树中移除后一个块
        remove_from_free_tree(next_block);
    }
    
    return merged_block;
}
```

## 3. 内存池管理器的分配释放实现

### 3.1 内存池管理器的数据结构

```cpp
class MemoryPoolManager {
private:
    FixedSizePool small_pool;    // 小字符串池（≤16字节）
    FixedSizePool medium_pool;   // 中字符串池（17-256字节）
    VariableSizePool large_pool; // 大字符串池（257-4096字节）
    
    // 统计信息
    PoolStatistics stats;
    
public:
    void* allocate(size_t size);
    void deallocate(void* ptr, size_t size);
    PoolStatistics get_statistics() const;
};
```

### 3.2 内存池管理器的分配实现

```cpp
void* MemoryPoolManager::allocate(size_t size) {
    // 1. 根据大小选择合适的内存池
    if (size <= 16) {
        // 小字符串：使用固定大小池
        return small_pool.allocate();
    } else if (size <= 256) {
        // 中字符串：使用固定大小池
        return medium_pool.allocate();
    } else if (size <= 4096) {
        // 大字符串：使用可变大小池
        return large_pool.allocate(size);
    } else {
        // 超大字符串：直接使用系统分配
        return std::aligned_alloc(alignof(BlockHeader), size);
    }
}
```

### 3.3 内存池管理器的释放实现

```cpp
void MemoryPoolManager::deallocate(void* ptr, size_t size) {
    if (!ptr) return;
    
    // 1. 根据大小选择合适的内存池
    if (size <= 16) {
        // 小字符串：使用固定大小池
        small_pool.deallocate(ptr);
    } else if (size <= 256) {
        // 中字符串：使用固定大小池
        medium_pool.deallocate(ptr);
    } else if (size <= 4096) {
        // 大字符串：使用可变大小池
        large_pool.deallocate(ptr);
    } else {
        // 超大字符串：直接使用系统释放
        std::free(ptr);
    }
}
```

## 4. 错误处理和调试

### 4.1 错误检测机制

```cpp
void FixedSizePool::handle_deallocation_error(BlockHeader* header) {
    if (!header->is_valid()) {
        // 内存损坏错误
        log_error("Memory corruption detected in block at %p", header);
        // 可以触发断言或异常
        assert(false);
    }
}

void FixedSizePool::handle_double_free_error(BlockHeader* header) {
    log_error("Double free detected in block at %p", header);
    // 可以触发断言或异常
    assert(false);
}
```

### 4.2 调试和统计功能

```cpp
struct PoolStatistics {
    size_t total_allocations;
    size_t total_deallocations;
    size_t current_used_blocks;
    size_t current_free_blocks;
    size_t total_memory_used;
    size_t total_memory_free;
    double fragmentation_ratio;
    double allocation_success_rate;
};

PoolStatistics MemoryPoolManager::get_statistics() const {
    PoolStatistics stats;
    
    // 收集各池的统计信息
    auto small_stats = small_pool.get_statistics();
    auto medium_stats = medium_pool.get_statistics();
    auto large_stats = large_pool.get_statistics();
    
    // 合并统计信息
    stats.total_allocations = small_stats.total_allocations + 
                             medium_stats.total_allocations + 
                             large_stats.total_allocations;
    
    stats.total_deallocations = small_stats.total_deallocations + 
                               medium_stats.total_deallocations + 
                               large_stats.total_deallocations;
    
    // 计算其他统计信息
    stats.fragmentation_ratio = calculate_fragmentation_ratio();
    stats.allocation_success_rate = calculate_success_rate();
    
    return stats;
}
```

## 5. 性能优化技术

### 5.1 无锁优化

```cpp
class LockFreeFixedSizePool {
private:
    std::atomic<BlockHeader*> free_list;
    
public:
    void* allocate() {
        BlockHeader* current = free_list.load(std::memory_order_acquire);
        
        while (current) {
            BlockHeader* next = current->next;
            
            if (free_list.compare_exchange_weak(current, next, 
                                               std::memory_order_release,
                                               std::memory_order_acquire)) {
                current->mark_allocated();
                return current->get_user_ptr();
            }
        }
        
        return nullptr;
    }
};
```

### 5.2 批量操作优化

```cpp
class BatchAllocator {
public:
    // 批量分配
    std::vector<void*> allocate_batch(size_t count, size_t size) {
        std::vector<void*> results;
        results.reserve(count);
        
        for (size_t i = 0; i < count; ++i) {
            void* ptr = allocate(size);
            if (ptr) {
                results.push_back(ptr);
            } else {
                break;
            }
        }
        
        return results;
    }
    
    // 批量释放
    void deallocate_batch(const std::vector<void*>& ptrs, size_t size) {
        for (void* ptr : ptrs) {
            deallocate(ptr, size);
        }
    }
};
```

## 6. 总结

内存池的分配释放实现具有以下特点：

1. **分层设计**：不同大小的对象使用不同的内存池
2. **高效算法**：固定大小池O(1)分配，可变大小池O(log n)分配
3. **线程安全**：使用锁或无锁技术保证并发安全
4. **错误检测**：魔数验证、双重释放检测等安全机制
5. **统计功能**：提供详细的性能和使用统计
6. **优化技术**：无锁操作、批量操作等性能优化

这种设计确保了内存池的高性能、高安全性和高可维护性。




