# 内存池线程安全面试题

## 题目1：互斥锁 vs 读写锁
**难度：⭐⭐⭐**

### 问题描述
当前实现使用了 `std::mutex`。请分析：
1. 是否可以使用 `std::shared_mutex`（读写锁）来优化？
2. 读写锁在什么场景下更有优势？
3. 如何分析锁竞争情况？

### 参考答案要点
1. **是否适合读写锁**：
   - 当前实现：分配和释放都需要修改 free_list
   - 都是写操作，不适合读写锁
   - 如果有只读操作（如统计信息查询），可以考虑

2. **读写锁的优势场景**：
   - 读操作远多于写操作
   - 读操作不需要互斥
   - 可以提高并发性能

3. **锁竞争分析**：
   - 使用性能分析工具（如 perf, valgrind）
   - 监控锁等待时间
   - 分析锁持有的时间
   - 考虑锁的粒度

### 评分标准
- 分析是否适合读写锁（2分）
- 说明读写锁优势场景（2分）
- 提出竞争分析方法（1分）

---

## 题目2：无锁内存池设计
**难度：⭐⭐⭐⭐⭐**

### 问题描述
请设计一个无锁（lock-free）的内存池：
1. 如何实现无锁的分配和释放？
2. 需要处理哪些并发问题？
3. 无锁实现的优缺点是什么？

### 参考答案要点
1. **无锁实现**：
   ```cpp
   void* allocate(size_t size) {
       BlockHeader* head = free_list.load(std::memory_order_acquire);
       do {
           if (head == nullptr) {
               return nullptr; // 池已满
           }
           BlockHeader* next = head->next;
           // CAS: 如果 free_list 仍然是 head，则更新为 next
       } while (!free_list.compare_exchange_weak(
           head, next, 
           std::memory_order_release, 
           std::memory_order_acquire));
       
       head->mark_allocated();
       return head->get_user_ptr();
   }
   ```

2. **并发问题**：
   - **ABA 问题**：需要处理指针重用
   - **内存序**：正确使用 memory_order
   - **忙等待**：可能导致 CPU 占用高

3. **优缺点**：
   - **优点**：无锁竞争，高并发性能好
   - **缺点**：实现复杂，调试困难，可能有忙等待

### 评分标准
- 实现无锁分配（2分）
- 说明并发问题（2分）
- 分析优缺点（1分）

---

## 题目3：线程本地存储（TLS）优化
**难度：⭐⭐⭐⭐**

### 问题描述
使用线程本地存储可以减少锁竞争。请设计：
1. 如何为每个线程维护本地空闲块缓存？
2. 何时从全局池获取块？
3. 何时将块归还到全局池？

### 参考答案要点
1. **TLS 设计**：
   ```cpp
   class FixedSizePool {
       thread_local static BlockHeader* local_free_list;
       
       void* allocate(size_t size) {
           // 先尝试从本地缓存分配
           if (local_free_list != nullptr) {
               BlockHeader* header = local_free_list;
               local_free_list = header->next;
               header->mark_allocated();
               return header->get_user_ptr();
           }
           
           // 本地缓存为空，从全局池获取一批
           refill_local_cache();
           // 再次尝试分配
       }
   };
   ```

2. **从全局池获取时机**：
   - 本地缓存为空时
   - 批量获取多个块（如 10-20 个）
   - 减少全局锁的竞争

3. **归还到全局池时机**：
   - 本地缓存超过阈值时
   - 线程退出时
   - 避免内存浪费

### 评分标准
- 设计 TLS 结构（2分）
- 说明获取时机（1分）
- 说明归还时机（2分）

---

## 题目4：内存屏障和内存序
**难度：⭐⭐⭐⭐⭐**

### 问题描述
在无锁编程中，内存序（memory ordering）非常重要。请解释：
1. `memory_order_acquire` 和 `memory_order_release` 的作用？
2. 在内存池中如何正确使用内存序？
3. 什么是 happens-before 关系？

### 参考答案要点
1. **内存序说明**：
   - `memory_order_acquire`：获取操作，之后的读写不能重排到之前
   - `memory_order_release`：释放操作，之前的读写不能重排到之后
   - 形成同步关系，保证可见性

2. **在内存池中的应用**：
   ```cpp
   // 分配时
   BlockHeader* head = free_list.load(std::memory_order_acquire);
   // 确保看到最新的 free_list 值
   
   // 释放时
   free_list.store(new_head, std::memory_order_release);
   // 确保之前的操作对后续的 acquire 可见
   ```

3. **happens-before 关系**：
   - 定义操作的可见性顺序
   - release-acquire 对形成同步
   - 保证数据的一致性

### 评分标准
- 解释内存序（2分）
- 说明在内存池中的应用（2分）
- 说明 happens-before（1分）

---

## 题目5：死锁预防
**难度：⭐⭐⭐**

### 问题描述
在多线程环境中，内存池可能与其他组件交互。请考虑：
1. 内存池可能发生死锁的场景？
2. 如何预防死锁？
3. 如何检测死锁？

### 参考答案要点
1. **死锁场景**：
   - 多个内存池之间的锁顺序不一致
   - 在持有锁时调用用户回调函数
   - 嵌套分配导致锁重入

2. **预防方法**：
   - **锁顺序**：统一锁的获取顺序
   - **避免嵌套**：不在持有锁时分配内存
   - **超时机制**：使用 `try_lock` 和超时
   - **锁层次**：定义锁的层次结构

3. **检测方法**：
   - 使用死锁检测工具
   - 记录锁的获取顺序
   - 使用超时机制检测

### 评分标准
- 列举死锁场景（2分）
- 提出预防方法（2分）
- 说明检测方法（1分）

---

## 题目6：原子操作的正确使用
**难度：⭐⭐⭐⭐**

### 问题描述
在实现无锁内存池时，需要正确使用原子操作。请回答：
1. `compare_exchange_weak` vs `compare_exchange_strong` 的区别？
2. 为什么在循环中使用 `compare_exchange_weak`？
3. 如何实现无锁的统计信息更新？

### 参考答案要点
1. **CAS 操作区别**：
   - `compare_exchange_weak`：可能虚假失败（spurious failure）
   - `compare_exchange_strong`：保证成功或真正的失败
   - weak 版本性能可能更好（在某些架构上）

2. **循环中使用 weak**：
   ```cpp
   do {
       // 准备新值
   } while (!atomic_var.compare_exchange_weak(old, new));
   ```
   - 在循环中，虚假失败会被重试
   - weak 版本可能更高效

3. **无锁统计**：
   ```cpp
   std::atomic<size_t> total_allocations{0};
   
   void* allocate(...) {
       // 分配逻辑
       total_allocations.fetch_add(1, std::memory_order_relaxed);
   }
   ```
   - 使用 `memory_order_relaxed`（统计信息不需要严格同步）
   - 使用原子操作保证线程安全

### 评分标准
- 说明 CAS 操作区别（2分）
- 解释循环中使用 weak 的原因（2分）
- 实现无锁统计（1分）
