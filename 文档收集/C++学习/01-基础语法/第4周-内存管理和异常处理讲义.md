# 第4周：C++内存管理和异常处理讲义

## 课程概述

### 学习目标
通过本课程的学习，学生将掌握C++内存管理和异常处理的核心技术，包括：
- 智能指针的使用和管理
- RAII原则的理解和应用
- 异常处理机制的掌握
- 资源管理最佳实践
- 内存安全编程技能

### 课程结构
- **第1-2天**：智能指针基础与进阶
- **第3天**：RAII原则深入理解
- **第4-5天**：异常处理机制
- **第6天**：资源管理最佳实践
- **第7天**：综合项目实践

---

## 第一部分：智能指针（Smart Pointers）

### 1.1 智能指针概述

#### 什么是智能指针？
智能指针是C++11引入的RAII（Resource Acquisition Is Initialization）机制的具体实现，用于自动管理动态分配的内存。它们提供了自动内存管理，避免了手动内存管理的常见问题。

#### 智能指针的优势
1. **自动内存管理**：自动释放内存，避免内存泄漏
2. **异常安全**：即使发生异常也能正确释放资源
3. **所有权明确**：明确表达资源的所有权关系
4. **类型安全**：编译时类型检查

#### 智能指针类型
- `std::unique_ptr`：独占所有权
- `std::shared_ptr`：共享所有权
- `std::weak_ptr`：弱引用，避免循环引用

### 1.2 unique_ptr - 独占所有权

#### 基本概念
`unique_ptr`实现了独占所有权的智能指针，确保同一时间只有一个`unique_ptr`实例拥有某个对象的所有权。

#### 核心特性
1. **独占所有权**：同一时间只能有一个`unique_ptr`拥有对象
2. **不可复制**：不能复制，只能移动
3. **自动释放**：析构时自动释放资源
4. **零开销**：与原始指针性能相当

#### 基本使用
```cpp
#include <memory>
#include <iostream>

class Resource {
public:
    Resource(const std::string& name) : name(name) {
        std::cout << "Resource " << name << " created" << std::endl;
    }
    
    ~Resource() {
        std::cout << "Resource " << name << " destroyed" << std::endl;
    }
    
    void use() {
        std::cout << "Using resource " << name << std::endl;
    }
    
private:
    std::string name;
};

int main() {
    // 创建unique_ptr
    std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>("Resource1");
    ptr1->use();
    
    // 转移所有权
    std::unique_ptr<Resource> ptr2 = std::move(ptr1);
    
    if (ptr1 == nullptr) {
        std::cout << "ptr1 is now empty" << std::endl;
    }
    
    ptr2->use();
    
    // 自动释放资源
    return 0;
}
```

#### 重要方法
- `get()`：获取原始指针
- `release()`：释放所有权，返回原始指针
- `reset()`：重置指针，释放当前对象
- `swap()`：交换两个unique_ptr

#### 使用场景
1. **工厂模式**：返回动态创建的对象
2. **资源管理**：管理文件句柄、网络连接等
3. **容器元素**：在容器中存储动态对象
4. **异常安全**：确保异常时资源正确释放

### 1.3 shared_ptr - 共享所有权

#### 基本概念
`shared_ptr`实现了共享所有权的智能指针，多个`shared_ptr`可以共享同一个对象的所有权，使用引用计数来管理对象的生命周期。

#### 核心特性
1. **共享所有权**：多个`shared_ptr`可以共享同一对象
2. **引用计数**：自动维护引用计数
3. **自动释放**：引用计数为0时自动释放
4. **线程安全**：引用计数操作是线程安全的

#### 基本使用
```cpp
#include <memory>
#include <iostream>

class SharedResource {
public:
    SharedResource(const std::string& name) : name(name) {
        std::cout << "SharedResource " << name << " created" << std::endl;
    }
    
    ~SharedResource() {
        std::cout << "SharedResource " << name << " destroyed" << std::endl;
    }
    
    void use() {
        std::cout << "Using shared resource " << name << std::endl;
    }
    
private:
    std::string name;
};

int main() {
    // 创建shared_ptr
    std::shared_ptr<SharedResource> ptr1 = std::make_shared<SharedResource>("Shared1");
    
    // 复制shared_ptr
    std::shared_ptr<SharedResource> ptr2 = ptr1;
    std::shared_ptr<SharedResource> ptr3 = ptr1;
    
    std::cout << "Reference count: " << ptr1.use_count() << std::endl;
    
    ptr1->use();
    ptr2->use();
    ptr3->use();
    
    // 重置指针
    ptr2.reset();
    std::cout << "After reset, reference count: " << ptr1.use_count() << std::endl;
    
    // 自动释放资源（当最后一个shared_ptr被销毁时）
    return 0;
}
```

#### 重要方法
- `use_count()`：获取引用计数
- `reset()`：重置指针
- `get()`：获取原始指针
- `swap()`：交换两个shared_ptr

#### 性能考虑
1. **内存开销**：需要额外的控制块存储引用计数
2. **原子操作**：引用计数操作使用原子操作
3. **循环引用**：可能导致内存泄漏

### 1.4 weak_ptr - 弱引用

#### 基本概念
`weak_ptr`是对`shared_ptr`管理的对象的弱引用，它不增加引用计数，主要用于打破循环引用。

#### 核心特性
1. **弱引用**：不增加引用计数
2. **安全访问**：通过`lock()`方法安全访问对象
3. **循环引用解决**：解决shared_ptr的循环引用问题
4. **过期检测**：可以检测对象是否已被释放

#### 基本使用
```cpp
#include <memory>
#include <iostream>

class Node {
public:
    std::string name;
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> parent;  // 使用weak_ptr避免循环引用
    
    Node(const std::string& n) : name(n) {
        std::cout << "Node " << name << " created" << std::endl;
    }
    
    ~Node() {
        std::cout << "Node " << name << " destroyed" << std::endl;
    }
    
    void setParent(std::shared_ptr<Node> p) {
        parent = p;
    }
    
    void printParent() {
        if (auto p = parent.lock()) {
            std::cout << "Parent: " << p->name << std::endl;
        } else {
            std::cout << "Parent is no longer available" << std::endl;
        }
    }
};

int main() {
    auto node1 = std::make_shared<Node>("Node1");
    auto node2 = std::make_shared<Node>("Node2");
    
    node1->next = node2;
    node2->setParent(node1);
    
    node2->printParent();
    
    // 即使node1被销毁，node2仍然存在
    node1.reset();
    node2->printParent();
    
    return 0;
}
```

#### 重要方法
- `lock()`：获取shared_ptr，如果对象已过期则返回空指针
- `expired()`：检查对象是否已过期
- `use_count()`：获取引用计数

#### 使用场景
1. **循环引用**：打破shared_ptr的循环引用
2. **缓存系统**：实现弱引用缓存
3. **观察者模式**：实现弱引用观察者
4. **临时访问**：临时访问shared_ptr管理的对象

---

## 第二部分：RAII原则（Resource Acquisition Is Initialization）

### 2.1 RAII基本概念

#### 什么是RAII？
RAII（Resource Acquisition Is Initialization）是C++中管理资源的重要原则，其核心思想是：
- 资源的获取与对象的初始化绑定
- 资源的释放与对象的析构绑定
- 利用C++的析构函数自动调用机制确保资源正确释放

#### RAII的优势
1. **自动资源管理**：无需手动释放资源
2. **异常安全**：即使发生异常也能正确释放资源
3. **代码简洁**：减少资源管理代码
4. **防止资源泄漏**：自动防止资源泄漏

### 2.2 RAII实现示例

#### 文件句柄管理
```cpp
#include <iostream>
#include <memory>

// RAII类示例
class FileHandle {
private:
    FILE* file;
    
public:
    FileHandle(const std::string& filename, const std::string& mode) {
        file = fopen(filename.c_str(), mode.c_str());
        if (!file) {
            throw std::runtime_error("Cannot open file: " + filename);
        }
        std::cout << "File opened: " << filename << std::endl;
    }
    
    ~FileHandle() {
        if (file) {
            fclose(file);
            std::cout << "File closed" << std::endl;
        }
    }
    
    // 禁用拷贝
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    // 支持移动
    FileHandle(FileHandle&& other) noexcept : file(other.file) {
        other.file = nullptr;
    }
    
    FileHandle& operator=(FileHandle&& other) noexcept {
        if (this != &other) {
            if (file) {
                fclose(file);
            }
            file = other.file;
            other.file = nullptr;
        }
        return *this;
    }
    
    FILE* get() const { return file; }
    
    void write(const std::string& data) {
        if (file) {
            fwrite(data.c_str(), 1, data.size(), file);
        }
    }
};

int main() {
    try {
        FileHandle file("test.txt", "w");
        file.write("Hello, RAII!");
        // 文件会在作用域结束时自动关闭
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

#### 数据库连接管理
```cpp
#include <iostream>
#include <memory>
#include <vector>

class DatabaseConnection {
private:
    std::string connectionString;
    bool connected;
    
public:
    DatabaseConnection(const std::string& connStr) : connectionString(connStr), connected(false) {
        std::cout << "Connecting to database: " << connStr << std::endl;
        // 模拟连接过程
        connected = true;
    }
    
    ~DatabaseConnection() {
        if (connected) {
            std::cout << "Disconnecting from database" << std::endl;
            connected = false;
        }
    }
    
    void executeQuery(const std::string& query) {
        if (!connected) {
            throw std::runtime_error("Not connected to database");
        }
        std::cout << "Executing query: " << query << std::endl;
    }
    
    void beginTransaction() {
        std::cout << "Beginning transaction" << std::endl;
    }
    
    void commitTransaction() {
        std::cout << "Committing transaction" << std::endl;
    }
    
    void rollbackTransaction() {
        std::cout << "Rolling back transaction" << std::endl;
    }
};

// RAII事务管理
class Transaction {
private:
    DatabaseConnection& db;
    bool committed;
    
public:
    Transaction(DatabaseConnection& database) : db(database), committed(false) {
        db.beginTransaction();
    }
    
    ~Transaction() {
        if (!committed) {
            db.rollbackTransaction();
        }
    }
    
    void commit() {
        db.commitTransaction();
        committed = true;
    }
};

int main() {
    try {
        DatabaseConnection db("localhost:3306/mydb");
        
        {
            Transaction trans(db);
            db.executeQuery("INSERT INTO users VALUES (1, 'Alice')");
            db.executeQuery("INSERT INTO users VALUES (2, 'Bob')");
            
            // 如果这里抛出异常，事务会自动回滚
            // throw std::runtime_error("Simulated error");
            
            trans.commit();  // 手动提交事务
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 2.3 RAII设计原则

#### 基本原则
1. **资源获取即初始化**：在构造函数中获取资源
2. **资源释放即析构**：在析构函数中释放资源
3. **异常安全**：确保异常时资源正确释放
4. **所有权明确**：明确资源的所有权

#### 设计模式
1. **独占所有权**：使用`unique_ptr`或禁用拷贝
2. **共享所有权**：使用`shared_ptr`
3. **移动语义**：支持高效的资源转移
4. **异常安全**：提供强异常安全保证

---

## 第三部分：异常处理机制

### 3.1 异常处理基础

#### 异常处理概念
异常处理是C++中处理运行时错误的机制，它允许程序在遇到错误时优雅地处理，而不是崩溃。

#### 异常处理组件
1. **throw**：抛出异常
2. **try**：尝试执行可能抛出异常的代码
3. **catch**：捕获和处理异常
4. **异常类型**：标准异常类型和自定义异常类型

#### 基本异常处理
```cpp
#include <iostream>
#include <stdexcept>
#include <string>

class Calculator {
public:
    double divide(double a, double b) {
        if (b == 0) {
            throw std::invalid_argument("Division by zero");
        }
        return a / b;
    }
    
    double squareRoot(double x) {
        if (x < 0) {
            throw std::domain_error("Cannot compute square root of negative number");
        }
        return std::sqrt(x);
    }
    
    int factorial(int n) {
        if (n < 0) {
            throw std::invalid_argument("Factorial is not defined for negative numbers");
        }
        if (n > 12) {
            throw std::overflow_error("Factorial too large");
        }
        
        int result = 1;
        for (int i = 2; i <= n; ++i) {
            result *= i;
        }
        return result;
    }
};

int main() {
    Calculator calc;
    
    try {
        double result1 = calc.divide(10, 2);
        std::cout << "10 / 2 = " << result1 << std::endl;
        
        double result2 = calc.divide(10, 0);  // 抛出异常
        std::cout << "10 / 0 = " << result2 << std::endl;
        
    } catch (const std::invalid_argument& e) {
        std::cerr << "Invalid argument: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
    
    try {
        double result3 = calc.squareRoot(16);
        std::cout << "sqrt(16) = " << result3 << std::endl;
        
        double result4 = calc.squareRoot(-4);  // 抛出异常
        std::cout << "sqrt(-4) = " << result4 << std::endl;
        
    } catch (const std::domain_error& e) {
        std::cerr << "Domain error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 3.2 自定义异常类

#### 异常类层次结构
```cpp
#include <iostream>
#include <stdexcept>
#include <string>

// 自定义异常类
class BankException : public std::exception {
private:
    std::string message;
    
public:
    BankException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class InsufficientFundsException : public BankException {
public:
    InsufficientFundsException(double amount, double balance) 
        : BankException("Insufficient funds: requested " + std::to_string(amount) + 
                       ", available " + std::to_string(balance)) {}
};

class InvalidAmountException : public BankException {
public:
    InvalidAmountException(double amount) 
        : BankException("Invalid amount: " + std::to_string(amount)) {}
};

class BankAccount {
private:
    std::string accountNumber;
    double balance;
    
public:
    BankAccount(const std::string& accNum, double initialBalance = 0.0) 
        : accountNumber(accNum), balance(initialBalance) {}
    
    void deposit(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        balance += amount;
        std::cout << "Deposited " << amount << ", new balance: " << balance << std::endl;
    }
    
    void withdraw(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException(amount);
        }
        if (amount > balance) {
            throw InsufficientFundsException(amount, balance);
        }
        balance -= amount;
        std::cout << "Withdrew " << amount << ", new balance: " << balance << std::endl;
    }
    
    double getBalance() const {
        return balance;
    }
    
    std::string getAccountNumber() const {
        return accountNumber;
    }
};

int main() {
    BankAccount account("12345", 1000.0);
    
    try {
        account.deposit(500.0);
        account.withdraw(200.0);
        account.withdraw(2000.0);  // 抛出InsufficientFundsException
        
    } catch (const InsufficientFundsException& e) {
        std::cerr << "Insufficient funds error: " << e.what() << std::endl;
    } catch (const InvalidAmountException& e) {
        std::cerr << "Invalid amount error: " << e.what() << std::endl;
    } catch (const BankException& e) {
        std::cerr << "Bank error: " << e.what() << std::endl;
    }
    
    try {
        account.deposit(-100.0);  // 抛出InvalidAmountException
        
    } catch (const BankException& e) {
        std::cerr << "Bank error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 3.3 异常安全保证

#### 异常安全级别
1. **基本异常安全**：保证对象处于有效状态
2. **强异常安全**：操作要么成功，要么保持原状态
3. **无异常安全**：操作不会抛出异常

#### 异常安全实现
```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <stdexcept>

// 异常安全的类
class ExceptionSafeVector {
private:
    std::vector<int> data;
    
public:
    // 强异常安全保证
    void insert(size_t pos, int value) {
        std::vector<int> temp = data;  // 创建副本
        temp.insert(temp.begin() + pos, value);  // 在副本上操作
        data = std::move(temp);  // 如果成功，则替换原数据
    }
    
    // 基本异常安全保证
    void push_back(int value) {
        data.push_back(value);  // 如果失败，vector保持原状态
    }
    
    // 无异常保证
    int& operator[](size_t index) {
        return data[index];  // 如果索引越界，行为未定义
    }
    
    const int& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return data.size();
    }
};

// 异常安全的资源管理
class ResourceManager {
private:
    std::vector<std::unique_ptr<int>> resources;
    
public:
    void addResource(int value) {
        auto resource = std::make_unique<int>(value);
        resources.push_back(std::move(resource));
    }
    
    void removeResource(size_t index) {
        if (index < resources.size()) {
            resources.erase(resources.begin() + index);
        }
    }
    
    int getResource(size_t index) const {
        if (index >= resources.size()) {
            throw std::out_of_range("Index out of range");
        }
        return *resources[index];
    }
    
    size_t getResourceCount() const {
        return resources.size();
    }
};

int main() {
    try {
        ExceptionSafeVector vec;
        vec.push_back(1);
        vec.push_back(2);
        vec.insert(1, 3);  // 在位置1插入3
        
        for (size_t i = 0; i < vec.size(); ++i) {
            std::cout << vec[i] << " ";
        }
        std::cout << std::endl;
        
        ResourceManager manager;
        manager.addResource(10);
        manager.addResource(20);
        manager.addResource(30);
        
        std::cout << "Resource count: " << manager.getResourceCount() << std::endl;
        std::cout << "Resource 1: " << manager.getResource(1) << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
    
    return 0;
}
```

---

## 第四部分：资源管理最佳实践

### 4.1 内存泄漏检测

#### 内存泄漏检测器
```cpp
#include <iostream>
#include <memory>
#include <vector>

// 简单的内存泄漏检测器
class MemoryTracker {
private:
    static size_t allocated;
    static size_t deallocated;
    
public:
    static void* allocate(size_t size) {
        void* ptr = malloc(size);
        if (ptr) {
            allocated += size;
            std::cout << "Allocated " << size << " bytes, total: " << allocated << std::endl;
        }
        return ptr;
    }
    
    static void deallocate(void* ptr, size_t size) {
        if (ptr) {
            free(ptr);
            deallocated += size;
            std::cout << "Deallocated " << size << " bytes, total: " << deallocated << std::endl;
        }
    }
    
    static void report() {
        std::cout << "Memory report - Allocated: " << allocated 
                  << ", Deallocated: " << deallocated 
                  << ", Leaked: " << (allocated - deallocated) << std::endl;
    }
};

size_t MemoryTracker::allocated = 0;
size_t MemoryTracker::deallocated = 0;

// 自定义分配器
template<typename T>
class TrackingAllocator {
public:
    using value_type = T;
    
    T* allocate(size_t n) {
        return static_cast<T*>(MemoryTracker::allocate(n * sizeof(T)));
    }
    
    void deallocate(T* ptr, size_t n) {
        MemoryTracker::deallocate(ptr, n * sizeof(T));
    }
};

// RAII内存管理
class ManagedArray {
private:
    int* data;
    size_t size;
    
public:
    ManagedArray(size_t s) : size(s) {
        data = new int[size];
        std::cout << "ManagedArray created with size " << size << std::endl;
    }
    
    ~ManagedArray() {
        delete[] data;
        std::cout << "ManagedArray destroyed" << std::endl;
    }
    
    // 禁用拷贝
    ManagedArray(const ManagedArray&) = delete;
    ManagedArray& operator=(const ManagedArray&) = delete;
    
    // 支持移动
    ManagedArray(ManagedArray&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
    
    int& operator[](size_t index) {
        return data[index];
    }
    
    const int& operator[](size_t index) const {
        return data[index];
    }
    
    size_t getSize() const {
        return size;
    }
};

int main() {
    {
        ManagedArray arr(10);
        for (size_t i = 0; i < arr.getSize(); ++i) {
            arr[i] = static_cast<int>(i);
        }
        
        for (size_t i = 0; i < arr.getSize(); ++i) {
            std::cout << arr[i] << " ";
        }
        std::cout << std::endl;
        
        // 使用智能指针
        auto smartPtr = std::make_unique<int[]>(5);
        for (int i = 0; i < 5; ++i) {
            smartPtr[i] = i * i;
        }
        
        for (int i = 0; i < 5; ++i) {
            std::cout << smartPtr[i] << " ";
        }
        std::cout << std::endl;
        
    }  // 自动释放资源
    
    MemoryTracker::report();
    
    return 0;
}
```

### 4.2 异常安全的设计模式

#### 单例模式
```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <stdexcept>

// 异常安全的单例模式
class SafeSingleton {
private:
    static std::once_flag flag;
    static std::unique_ptr<SafeSingleton> instance;
    
    SafeSingleton() {
        std::cout << "SafeSingleton created" << std::endl;
    }
    
public:
    static SafeSingleton& getInstance() {
        std::call_once(flag, []() {
            instance = std::make_unique<SafeSingleton>();
        });
        return *instance;
    }
    
    void doSomething() {
        std::cout << "SafeSingleton doing something" << std::endl;
    }
    
    ~SafeSingleton() {
        std::cout << "SafeSingleton destroyed" << std::endl;
    }
};

std::once_flag SafeSingleton::flag;
std::unique_ptr<SafeSingleton> SafeSingleton::instance;
```

#### 工厂模式
```cpp
// 异常安全的工厂模式
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing circle" << std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing rectangle" << std::endl;
    }
};

class ShapeFactory {
public:
    static std::unique_ptr<Shape> createShape(const std::string& type) {
        if (type == "circle") {
            return std::make_unique<Circle>();
        } else if (type == "rectangle") {
            return std::make_unique<Rectangle>();
        } else {
            throw std::invalid_argument("Unknown shape type: " + type);
        }
    }
};
```

#### RAII包装器
```cpp
// 异常安全的RAII包装器
template<typename T>
class RAIIWrapper {
private:
    T resource;
    bool valid;
    
public:
    RAIIWrapper(T res) : resource(res), valid(true) {}
    
    ~RAIIWrapper() {
        if (valid) {
            // 假设T有cleanup方法
            if constexpr (std::is_member_function_pointer_v<decltype(&T::cleanup)>) {
                resource.cleanup();
            }
        }
    }
    
    T& get() {
        if (!valid) {
            throw std::runtime_error("Resource is no longer valid");
        }
        return resource;
    }
    
    void release() {
        valid = false;
    }
    
    RAIIWrapper(const RAIIWrapper&) = delete;
    RAIIWrapper& operator=(const RAIIWrapper&) = delete;
    
    RAIIWrapper(RAIIWrapper&& other) noexcept : resource(std::move(other.resource)), valid(other.valid) {
        other.valid = false;
    }
    
    RAIIWrapper& operator=(RAIIWrapper&& other) noexcept {
        if (this != &other) {
            resource = std::move(other.resource);
            valid = other.valid;
            other.valid = false;
        }
        return *this;
    }
};
```

---

## 第五部分：综合项目实践

### 5.1 内存安全字符串类

#### 项目要求
实现一个内存安全的字符串类，包含以下功能：
- 使用智能指针管理内存
- 实现RAII原则
- 提供异常安全保证
- 支持移动语义
- 防止内存泄漏和悬空指针

#### 核心实现
```cpp
#include <memory>
#include <vector>
#include <string>
#include <stdexcept>

class MemorySafeString {
private:
    std::unique_ptr<char[]> data;
    size_t length;
    
public:
    // 构造函数
    MemorySafeString() : length(0) {
        data = std::make_unique<char[]>(1);
        data[0] = '\0';
    }
    
    MemorySafeString(const char* str) : length(0) {
        if (str) {
            length = std::strlen(str);
            data = std::make_unique<char[]>(length + 1);
            std::strcpy(data.get(), str);
        } else {
            data = std::make_unique<char[]>(1);
            data[0] = '\0';
        }
    }
    
    MemorySafeString(const std::string& str) : length(str.length()) {
        data = std::make_unique<char[]>(length + 1);
        std::strcpy(data.get(), str.c_str());
    }
    
    // 拷贝构造函数和赋值操作符
    MemorySafeString(const MemorySafeString& other) : length(other.length) {
        data = std::make_unique<char[]>(length + 1);
        std::strcpy(data.get(), other.data.get());
    }
    
    MemorySafeString& operator=(const MemorySafeString& other) {
        if (this != &other) {
            length = other.length;
            data = std::make_unique<char[]>(length + 1);
            std::strcpy(data.get(), other.data.get());
        }
        return *this;
    }
    
    // 移动构造函数和移动赋值操作符
    MemorySafeString(MemorySafeString&& other) noexcept 
        : data(std::move(other.data)), length(other.length) {
        other.length = 0;
    }
    
    MemorySafeString& operator=(MemorySafeString&& other) noexcept {
        if (this != &other) {
            data = std::move(other.data);
            length = other.length;
            other.length = 0;
        }
        return *this;
    }
    
    // 基本操作
    char& operator[](size_t index) {
        if (index >= length) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    const char& operator[](size_t index) const {
        if (index >= length) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    size_t length() const {
        return length;
    }
    
    const char* c_str() const {
        return data.get();
    }
    
    // 字符串操作
    MemorySafeString operator+(const MemorySafeString& other) const {
        MemorySafeString result;
        result.length = length + other.length;
        result.data = std::make_unique<char[]>(result.length + 1);
        std::strcpy(result.data.get(), data.get());
        std::strcat(result.data.get(), other.data.get());
        return result;
    }
    
    bool operator==(const MemorySafeString& other) const {
        return length == other.length && std::strcmp(data.get(), other.data.get()) == 0;
    }
    
    // 异常安全的操作
    void append(const MemorySafeString& other) {
        size_t newLength = length + other.length;
        auto newData = std::make_unique<char[]>(newLength + 1);
        std::strcpy(newData.get(), data.get());
        std::strcat(newData.get(), other.data.get());
        data = std::move(newData);
        length = newLength;
    }
    
    void insert(size_t pos, const MemorySafeString& other) {
        if (pos > length) {
            throw std::out_of_range("Position out of range");
        }
        
        size_t newLength = length + other.length;
        auto newData = std::make_unique<char[]>(newLength + 1);
        
        std::strncpy(newData.get(), data.get(), pos);
        std::strcpy(newData.get() + pos, other.data.get());
        std::strcpy(newData.get() + pos + other.length, data.get() + pos);
        
        data = std::move(newData);
        length = newLength;
    }
    
    void erase(size_t pos, size_t count) {
        if (pos >= length) {
            throw std::out_of_range("Position out of range");
        }
        
        size_t actualCount = std::min(count, length - pos);
        size_t newLength = length - actualCount;
        
        auto newData = std::make_unique<char[]>(newLength + 1);
        std::strncpy(newData.get(), data.get(), pos);
        std::strcpy(newData.get() + pos, data.get() + pos + actualCount);
        
        data = std::move(newData);
        length = newLength;
    }
};
```

### 5.2 项目实现要点

#### 内存管理
1. **智能指针**：使用`unique_ptr`管理动态内存
2. **RAII原则**：构造函数获取资源，析构函数释放资源
3. **移动语义**：支持高效的资源转移
4. **异常安全**：提供强异常安全保证

#### 异常安全
1. **强异常安全**：操作要么成功，要么保持原状态
2. **资源管理**：确保异常时资源正确释放
3. **边界检查**：防止越界访问
4. **错误处理**：提供清晰的错误信息

#### 性能优化
1. **移动语义**：减少不必要的拷贝
2. **内存预分配**：避免频繁的内存分配
3. **内联函数**：提高小函数性能
4. **零开销抽象**：智能指针零开销

---

## 学习要点总结

### 核心概念
1. **智能指针**：自动内存管理，避免内存泄漏
2. **RAII原则**：资源获取即初始化，资源释放即析构
3. **异常安全**：确保异常时资源正确释放
4. **移动语义**：高效的资源转移

### 重要技术
1. **unique_ptr**：独占所有权，零开销
2. **shared_ptr**：共享所有权，引用计数
3. **weak_ptr**：弱引用，避免循环引用
4. **异常处理**：try-catch-throw机制

### 最佳实践
1. **优先使用智能指针**：避免手动内存管理
2. **遵循RAII原则**：确保资源正确释放
3. **提供异常安全保证**：确保异常时程序状态一致
4. **使用移动语义**：提高性能

### 常见陷阱
1. **循环引用**：shared_ptr可能导致内存泄漏
2. **异常安全**：不正确的异常处理可能导致资源泄漏
3. **性能问题**：过度使用shared_ptr可能影响性能
4. **所有权混乱**：不明确的所有权关系

---

## 课后练习建议

### 基础练习
1. 实现基本的智能指针使用
2. 编写RAII资源管理类
3. 练习异常处理机制

### 进阶练习
1. 实现异常安全的容器
2. 设计内存安全的类
3. 编写资源管理最佳实践

### 项目实践
1. 完成内存安全字符串类
2. 实现智能指针管理器
3. 设计异常安全的系统

---

## 参考资料

### 推荐书籍
1. 《Effective C++》- Scott Meyers
2. 《More Effective C++》- Scott Meyers
3. 《C++ Primer》- Stanley Lippman

### 在线资源
1. C++ Reference: https://en.cppreference.com/
2. C++ Core Guidelines: https://isocpp.github.io/CppCoreGuidelines/
3. Smart Pointers: https://en.cppreference.com/w/cpp/memory

---

**课程结束**

通过本课程的学习，您应该已经掌握了C++内存管理和异常处理的核心技术。这些技术是现代C++编程的基础，掌握它们将大大提高您的编程技能和代码质量。继续练习和实践，您将能够编写出内存安全、异常安全的C++程序。
