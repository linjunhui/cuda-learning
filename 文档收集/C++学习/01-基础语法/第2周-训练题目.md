# 第2周：模板编程基础 - 训练题目

## 学习目标
通过实践练习掌握C++模板编程的基本概念，包括函数模板、类模板、模板特化和模板参数推导。

## 每日训练题目

### 第1天：函数模板基础

#### 题目1：基本函数模板
**难度**：★☆☆☆☆

编写函数模板实现以下功能：
1. 交换两个变量的值
2. 返回两个值中的最大值
3. 返回两个值中的最小值

**要求**：
```cpp
#include <iostream>
#include <string>

// 函数模板：交换两个变量
template<typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// 函数模板：返回最大值
template<typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

// 函数模板：返回最小值
template<typename T>
T minimum(T a, T b) {
    return (a < b) ? a : b;
}

int main() {
    // 测试int类型
    int x = 10, y = 20;
    std::cout << "Before swap: x = " << x << ", y = " << y << std::endl;
    swap(x, y);
    std::cout << "After swap: x = " << x << ", y = " << y << std::endl;
    std::cout << "Max: " << maximum(x, y) << ", Min: " << minimum(x, y) << std::endl;
    
    // 测试double类型
    double a = 3.14, b = 2.71;
    std::cout << "\nBefore swap: a = " << a << ", b = " << b << std::endl;
    swap(a, b);
    std::cout << "After swap: a = " << a << ", b = " << b << std::endl;
    std::cout << "Max: " << maximum(a, b) << ", Min: " << minimum(a, b) << std::endl;
    
    // 测试string类型
    std::string str1 = "Hello", str2 = "World";
    std::cout << "\nBefore swap: str1 = " << str1 << ", str2 = " << str2 << std::endl;
    swap(str1, str2);
    std::cout << "After swap: str1 = " << str1 << ", str2 = " << str2 << std::endl;
    std::cout << "Max: " << maximum(str1, str2) << ", Min: " << minimum(str1, str2) << std::endl;
    
    return 0;
}
```

#### 题目2：多参数函数模板
**难度**：★★☆☆☆

编写多参数函数模板实现以下功能：
1. 计算两个不同类型数值的和
2. 比较两个不同类型数值的大小
3. 将两个不同类型数值转换为字符串

**要求**：
```cpp
#include <iostream>
#include <string>
#include <sstream>

// 多参数函数模板：计算和
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

// 多参数函数模板：比较大小
template<typename T, typename U>
bool isGreater(T a, U b) {
    return a > b;
}

// 多参数函数模板：转换为字符串
template<typename T, typename U>
std::string toString(T a, U b) {
    std::ostringstream oss;
    oss << "(" << a << ", " << b << ")";
    return oss.str();
}

// 多参数函数模板：创建对
template<typename T, typename U>
struct Pair {
    T first;
    U second;
    
    Pair(T f, U s) : first(f), second(s) {}
    
    std::string toString() const {
        std::ostringstream oss;
        oss << "(" << first << ", " << second << ")";
        return oss.str();
    }
};

int main() {
    // 测试不同类型的加法
    std::cout << "add(10, 3.14) = " << add(10, 3.14) << std::endl;
    std::cout << "add(3.14, 10) = " << add(3.14, 10) << std::endl;
    std::cout << "add(5, 2.5) = " << add(5, 2.5) << std::endl;
    
    // 测试不同类型的比较
    std::cout << "\nisGreater(10, 3.14) = " << isGreater(10, 3.14) << std::endl;
    std::cout << "isGreater(3.14, 10) = " << isGreater(3.14, 10) << std::endl;
    std::cout << "isGreater(5, 5.0) = " << isGreater(5, 5.0) << std::endl;
    
    // 测试转换为字符串
    std::cout << "\ntoString(10, 3.14) = " << toString(10, 3.14) << std::endl;
    std::cout << "toString(\"Hello\", 42) = " << toString(std::string("Hello"), 42) << std::endl;
    
    // 测试Pair类
    Pair<int, double> p1(10, 3.14);
    Pair<std::string, int> p2("Hello", 42);
    
    std::cout << "\nPair 1: " << p1.toString() << std::endl;
    std::cout << "Pair 2: " << p2.toString() << std::endl;
    
    return 0;
}
```

#### 题目3：模板参数推导
**难度**：★★☆☆☆

编写程序演示模板参数推导：
1. 自动推导参数类型
2. 显式指定类型
3. 推导失败的情况

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <string>

// 自动推导参数类型
template<typename T>
void printType(T value) {
    std::cout << "Value: " << value << ", Type: " << typeid(T).name() << std::endl;
}

// 显式指定类型
template<typename T>
void printTypeExplicit(T value) {
    std::cout << "Explicit - Value: " << value << ", Type: " << typeid(T).name() << std::endl;
}

// 推导失败的情况
template<typename T>
void printArray(T arr[], int size) {
    std::cout << "Array elements: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

// 使用decltype推导返回类型
template<typename T, typename U>
auto multiply(T a, U b) -> decltype(a * b) {
    return a * b;
}

// 使用auto推导返回类型
template<typename T>
auto getValue(T value) {
    return value;
}

int main() {
    // 自动推导
    std::cout << "Automatic type deduction:" << std::endl;
    printType(42);
    printType(3.14);
    printType(std::string("Hello"));
    printType('A');
    
    // 显式指定类型
    std::cout << "\nExplicit type specification:" << std::endl;
    printTypeExplicit<int>(42);
    printTypeExplicit<double>(3.14);
    printTypeExplicit<std::string>("Hello");
    
    // 数组推导
    std::cout << "\nArray type deduction:" << std::endl;
    int intArr[] = {1, 2, 3, 4, 5};
    double doubleArr[] = {1.1, 2.2, 3.3, 4.4, 5.5};
    
    printArray(intArr, 5);
    printArray(doubleArr, 5);
    
    // 返回类型推导
    std::cout << "\nReturn type deduction:" << std::endl;
    auto result1 = multiply(10, 3.14);
    auto result2 = multiply(3.14, 10);
    auto result3 = getValue(42);
    auto result4 = getValue(3.14);
    
    std::cout << "multiply(10, 3.14) = " << result1 << ", Type: " << typeid(result1).name() << std::endl;
    std::cout << "multiply(3.14, 10) = " << result2 << ", Type: " << typeid(result2).name() << std::endl;
    std::cout << "getValue(42) = " << result3 << ", Type: " << typeid(result3).name() << std::endl;
    std::cout << "getValue(3.14) = " << result4 << ", Type: " << typeid(result4).name() << std::endl;
    
    return 0;
}
```

### 第2天：函数模板进阶

#### 题目4：模板特化
**难度**：★★★☆☆

编写程序实现模板特化：
1. 全特化
2. 偏特化
3. 特化的使用场景

**要求**：
```cpp
#include <iostream>
#include <string>
#include <vector>

// 通用模板
template<typename T>
void printType(T value) {
    std::cout << "Generic type: " << value << std::endl;
}

// 全特化：int类型
template<>
void printType<int>(int value) {
    std::cout << "Integer type: " << value << std::endl;
}

// 全特化：double类型
template<>
void printType<double>(double value) {
    std::cout << "Double type: " << value << std::endl;
}

// 全特化：string类型
template<>
void printType<std::string>(std::string value) {
    std::cout << "String type: " << value << std::endl;
}

// 通用模板：比较函数
template<typename T>
bool isEqual(T a, T b) {
    return a == b;
}

// 特化：浮点数比较（考虑精度）
template<>
bool isEqual<double>(double a, double b) {
    const double epsilon = 1e-9;
    return std::abs(a - b) < epsilon;
}

// 通用模板：获取类型信息
template<typename T>
std::string getTypeInfo() {
    return "Unknown type";
}

// 特化：指针类型
template<typename T>
std::string getTypeInfo<T*>() {
    return "Pointer type";
}

// 特化：引用类型
template<typename T>
std::string getTypeInfo<T&>() {
    return "Reference type";
}

int main() {
    // 测试全特化
    std::cout << "Testing full specialization:" << std::endl;
    printType(42);
    printType(3.14);
    printType(std::string("Hello"));
    printType('A');
    
    // 测试比较特化
    std::cout << "\nTesting comparison specialization:" << std::endl;
    std::cout << "isEqual(5, 5) = " << isEqual(5, 5) << std::endl;
    std::cout << "isEqual(5.0, 5.0) = " << isEqual(5.0, 5.0) << std::endl;
    std::cout << "isEqual(5.0000001, 5.0000002) = " << isEqual(5.0000001, 5.0000002) << std::endl;
    
    // 测试类型信息特化
    std::cout << "\nTesting type info specialization:" << std::endl;
    std::cout << "getTypeInfo<int>() = " << getTypeInfo<int>() << std::endl;
    std::cout << "getTypeInfo<int*>() = " << getTypeInfo<int*>() << std::endl;
    std::cout << "getTypeInfo<int&>() = " << getTypeInfo<int&>() << std::endl;
    
    return 0;
}
```

#### 题目5：模板重载
**难度**：★★★☆☆

编写程序实现模板重载：
1. 函数模板重载
2. 模板与非模板函数重载
3. 重载解析规则

**要求**：
```cpp
#include <iostream>
#include <string>
#include <vector>

// 非模板函数
void print(int value) {
    std::cout << "Non-template function: " << value << std::endl;
}

// 函数模板
template<typename T>
void print(T value) {
    std::cout << "Template function: " << value << std::endl;
}

// 特化模板
template<>
void print<double>(double value) {
    std::cout << "Specialized template for double: " << value << std::endl;
}

// 重载模板：不同参数个数
template<typename T>
void print(T a, T b) {
    std::cout << "Two parameters: " << a << ", " << b << std::endl;
}

// 重载模板：不同参数类型
template<typename T, typename U>
void print(T a, U b) {
    std::cout << "Different types: " << a << ", " << b << std::endl;
}

// 重载模板：容器
template<typename T>
void print(const std::vector<T>& vec) {
    std::cout << "Vector: ";
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;
}

// 重载模板：数组
template<typename T, size_t N>
void print(T (&arr)[N]) {
    std::cout << "Array: ";
    for (size_t i = 0; i < N; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    // 测试重载解析
    std::cout << "Testing overload resolution:" << std::endl;
    
    // 非模板函数优先
    print(42);
    
    // 模板函数
    print(3.14);
    print(std::string("Hello"));
    print('A');
    
    // 两个参数
    print(10, 20);
    print(3.14, 2.71);
    
    // 不同类型
    print(10, 3.14);
    print(std::string("Hello"), 42);
    
    // 容器
    std::vector<int> vec = {1, 2, 3, 4, 5};
    print(vec);
    
    // 数组
    int arr[] = {10, 20, 30, 40, 50};
    print(arr);
    
    return 0;
}
```

### 第3天：类模板基础

#### 题目6：基本类模板
**难度**：★★☆☆☆

编写类模板实现以下功能：
1. 简单的栈类
2. 简单的队列类
3. 简单的对类

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

// 栈类模板
template<typename T>
class Stack {
private:
    std::vector<T> elements;

public:
    // 构造函数
    Stack() = default;
    
    // 成员函数
    void push(const T& element) {
        elements.push_back(element);
    }
    
    void pop() {
        if (elements.empty()) {
            throw std::runtime_error("Stack is empty");
        }
        elements.pop_back();
    }
    
    T top() const {
        if (elements.empty()) {
            throw std::runtime_error("Stack is empty");
        }
        return elements.back();
    }
    
    bool empty() const {
        return elements.empty();
    }
    
    size_t size() const {
        return elements.size();
    }
    
    void display() const {
        std::cout << "Stack (top to bottom): ";
        for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
            std::cout << *it << " ";
        }
        std::cout << std::endl;
    }
};

// 队列类模板
template<typename T>
class Queue {
private:
    std::vector<T> elements;

public:
    // 构造函数
    Queue() = default;
    
    // 成员函数
    void enqueue(const T& element) {
        elements.push_back(element);
    }
    
    void dequeue() {
        if (elements.empty()) {
            throw std::runtime_error("Queue is empty");
        }
        elements.erase(elements.begin());
    }
    
    T front() const {
        if (elements.empty()) {
            throw std::runtime_error("Queue is empty");
        }
        return elements.front();
    }
    
    bool empty() const {
        return elements.empty();
    }
    
    size_t size() const {
        return elements.size();
    }
    
    void display() const {
        std::cout << "Queue (front to back): ";
        for (const auto& element : elements) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
};

// 对类模板
template<typename T, typename U>
class Pair {
private:
    T first;
    U second;

public:
    // 构造函数
    Pair(T f, U s) : first(f), second(s) {}
    
    // 访问器函数
    T getFirst() const { return first; }
    U getSecond() const { return second; }
    
    void setFirst(T f) { first = f; }
    void setSecond(U s) { second = s; }
    
    void display() const {
        std::cout << "(" << first << ", " << second << ")" << std::endl;
    }
};

int main() {
    try {
        // 测试栈
        std::cout << "Testing Stack:" << std::endl;
        Stack<int> intStack;
        intStack.push(1);
        intStack.push(2);
        intStack.push(3);
        intStack.display();
        
        std::cout << "Top: " << intStack.top() << std::endl;
        intStack.pop();
        intStack.display();
        
        // 测试队列
        std::cout << "\nTesting Queue:" << std::endl;
        Queue<std::string> stringQueue;
        stringQueue.enqueue("First");
        stringQueue.enqueue("Second");
        stringQueue.enqueue("Third");
        stringQueue.display();
        
        std::cout << "Front: " << stringQueue.front() << std::endl;
        stringQueue.dequeue();
        stringQueue.display();
        
        // 测试对
        std::cout << "\nTesting Pair:" << std::endl;
        Pair<int, std::string> p1(1, "Hello");
        Pair<double, char> p2(3.14, 'A');
        
        p1.display();
        p2.display();
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

#### 题目7：多参数类模板
**难度**：★★★☆☆

编写多参数类模板实现以下功能：
1. 三元组类
2. 矩阵类
3. 映射类

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <stdexcept>

// 三元组类模板
template<typename T, typename U, typename V>
class Triple {
private:
    T first;
    U second;
    V third;

public:
    Triple(T f, U s, V t) : first(f), second(s), third(t) {}
    
    T getFirst() const { return first; }
    U getSecond() const { return second; }
    V getThird() const { return third; }
    
    void setFirst(T f) { first = f; }
    void setSecond(U s) { second = s; }
    void setThird(V t) { third = t; }
    
    void display() const {
        std::cout << "(" << first << ", " << second << ", " << third << ")" << std::endl;
    }
};

// 矩阵类模板
template<typename T, size_t ROWS, size_t COLS>
class Matrix {
private:
    T data[ROWS][COLS];

public:
    Matrix() {
        for (size_t i = 0; i < ROWS; ++i) {
            for (size_t j = 0; j < COLS; ++j) {
                data[i][j] = T{};
            }
        }
    }
    
    T& operator()(size_t row, size_t col) {
        if (row >= ROWS || col >= COLS) {
            throw std::out_of_range("Matrix index out of range");
        }
        return data[row][col];
    }
    
    const T& operator()(size_t row, size_t col) const {
        if (row >= ROWS || col >= COLS) {
            throw std::out_of_range("Matrix index out of range");
        }
        return data[row][col];
    }
    
    void display() const {
        for (size_t i = 0; i < ROWS; ++i) {
            for (size_t j = 0; j < COLS; ++j) {
                std::cout << data[i][j] << " ";
            }
            std::cout << std::endl;
        }
    }
    
    size_t getRows() const { return ROWS; }
    size_t getCols() const { return COLS; }
};

// 映射类模板
template<typename K, typename V>
class SimpleMap {
private:
    std::vector<std::pair<K, V>> data;

public:
    void insert(const K& key, const V& value) {
        // 检查是否已存在
        for (auto& pair : data) {
            if (pair.first == key) {
                pair.second = value;
                return;
            }
        }
        data.emplace_back(key, value);
    }
    
    V& operator[](const K& key) {
        // 查找现有键
        for (auto& pair : data) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        // 如果不存在，插入新键值对
        data.emplace_back(key, V{});
        return data.back().second;
    }
    
    const V& operator[](const K& key) const {
        for (const auto& pair : data) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        throw std::out_of_range("Key not found");
    }
    
    bool contains(const K& key) const {
        for (const auto& pair : data) {
            if (pair.first == key) {
                return true;
            }
        }
        return false;
    }
    
    size_t size() const {
        return data.size();
    }
    
    void display() const {
        std::cout << "Map contents:" << std::endl;
        for (const auto& pair : data) {
            std::cout << pair.first << " -> " << pair.second << std::endl;
        }
    }
};

int main() {
    try {
        // 测试三元组
        std::cout << "Testing Triple:" << std::endl;
        Triple<int, std::string, double> t1(1, "Hello", 3.14);
        Triple<char, bool, int> t2('A', true, 42);
        
        t1.display();
        t2.display();
        
        // 测试矩阵
        std::cout << "\nTesting Matrix:" << std::endl;
        Matrix<int, 3, 3> matrix;
        
        // 填充矩阵
        for (size_t i = 0; i < 3; ++i) {
            for (size_t j = 0; j < 3; ++j) {
                matrix(i, j) = i * 3 + j + 1;
            }
        }
        
        matrix.display();
        
        // 测试映射
        std::cout << "\nTesting SimpleMap:" << std::endl;
        SimpleMap<std::string, int> map;
        
        map.insert("apple", 5);
        map.insert("banana", 3);
        map.insert("cherry", 8);
        
        map.display();
        
        std::cout << "apple: " << map["apple"] << std::endl;
        std::cout << "Contains orange: " << map.contains("orange") << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 第4天：类模板进阶

#### 题目8：类模板特化
**难度**：★★★★☆

编写程序实现类模板特化：
1. 全特化
2. 偏特化
3. 特化的使用场景

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>

// 通用类模板
template<typename T>
class Container {
private:
    T value;

public:
    Container(T v) : value(v) {}
    
    void display() const {
        std::cout << "Generic container: " << value << std::endl;
    }
    
    T getValue() const {
        return value;
    }
};

// 全特化：int类型
template<>
class Container<int> {
private:
    int value;

public:
    Container(int v) : value(v) {}
    
    void display() const {
        std::cout << "Integer container: " << value << std::endl;
    }
    
    int getValue() const {
        return value;
    }
    
    bool isEven() const {
        return value % 2 == 0;
    }
    
    bool isOdd() const {
        return value % 2 != 0;
    }
};

// 全特化：string类型
template<>
class Container<std::string> {
private:
    std::string value;

public:
    Container(const std::string& v) : value(v) {}
    
    void display() const {
        std::cout << "String container: " << value << std::endl;
    }
    
    std::string getValue() const {
        return value;
    }
    
    size_t length() const {
        return value.length();
    }
    
    bool isEmpty() const {
        return value.empty();
    }
};

// 通用模板：数组类
template<typename T, size_t N>
class Array {
private:
    T data[N];

public:
    Array() {
        for (size_t i = 0; i < N; ++i) {
            data[i] = T{};
        }
    }
    
    T& operator[](size_t index) {
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return N;
    }
    
    void display() const {
        std::cout << "Array: ";
        for (size_t i = 0; i < N; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

// 偏特化：指针类型
template<typename T, size_t N>
class Array<T*, N> {
private:
    T* data[N];

public:
    Array() {
        for (size_t i = 0; i < N; ++i) {
            data[i] = nullptr;
        }
    }
    
    ~Array() {
        for (size_t i = 0; i < N; ++i) {
            delete data[i];
        }
    }
    
    T*& operator[](size_t index) {
        return data[index];
    }
    
    T* const& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return N;
    }
    
    void display() const {
        std::cout << "Pointer Array: ";
        for (size_t i = 0; i < N; ++i) {
            if (data[i] != nullptr) {
                std::cout << *data[i] << " ";
            } else {
                std::cout << "null ";
            }
        }
        std::cout << std::endl;
    }
};

// 偏特化：相同类型
template<typename T>
class Pair<T, T> {
private:
    T first;
    T second;

public:
    Pair(T f, T s) : first(f), second(s) {}
    
    T getFirst() const { return first; }
    T getSecond() const { return second; }
    
    void display() const {
        std::cout << "Same type pair: (" << first << ", " << second << ")" << std::endl;
    }
    
    bool isEqual() const {
        return first == second;
    }
    
    T getSum() const {
        return first + second;
    }
};

int main() {
    // 测试全特化
    std::cout << "Testing full specialization:" << std::endl;
    Container<double> c1(3.14);
    Container<int> c2(42);
    Container<std::string> c3("Hello");
    
    c1.display();
    c2.display();
    c3.display();
    
    std::cout << "c2 is even: " << c2.isEven() << std::endl;
    std::cout << "c3 length: " << c3.length() << std::endl;
    
    // 测试偏特化
    std::cout << "\nTesting partial specialization:" << std::endl;
    Array<int, 5> arr1;
    for (size_t i = 0; i < 5; ++i) {
        arr1[i] = i + 1;
    }
    arr1.display();
    
    Array<int*, 3> arr2;
    for (size_t i = 0; i < 3; ++i) {
        arr2[i] = new int(i + 1);
    }
    arr2.display();
    
    // 测试相同类型偏特化
    std::cout << "\nTesting same type specialization:" << std::endl;
    Pair<int, int> p1(10, 20);
    Pair<std::string, std::string> p2("Hello", "World");
    
    p1.display();
    p2.display();
    
    std::cout << "p1 is equal: " << p1.isEqual() << std::endl;
    std::cout << "p1 sum: " << p1.getSum() << std::endl;
    
    return 0;
}
```

### 第5天：模板参数推导

#### 题目9：模板参数包
**难度**：★★★★☆

编写程序使用模板参数包实现以下功能：
1. 可变参数函数
2. 可变参数类
3. 参数包展开

**要求**：
```cpp
#include <iostream>
#include <vector>
#include <string>

// 可变参数函数：打印所有参数
template<typename... Args>
void print(Args... args) {
    ((std::cout << args << " "), ...);
    std::cout << std::endl;
}

// 可变参数函数：计算参数个数
template<typename... Args>
size_t count(Args... args) {
    return sizeof...(args);
}

// 可变参数函数：计算和
template<typename... Args>
auto sum(Args... args) -> decltype((args + ...)) {
    return (args + ...);
}

// 可变参数函数：计算最大值
template<typename... Args>
auto maximum(Args... args) -> decltype((args, ...)) {
    return ((args > ...) ? ... : args);
}

// 可变参数类：元组
template<typename... Types>
class Tuple;

template<>
class Tuple<> {
public:
    void display() const {
        std::cout << "Empty tuple" << std::endl;
    }
};

template<typename T, typename... Rest>
class Tuple<T, Rest...> {
private:
    T first;
    Tuple<Rest...> rest;

public:
    Tuple(T f, Rest... r) : first(f), rest(r...) {}
    
    T getFirst() const {
        return first;
    }
    
    template<size_t N>
    auto get() const -> decltype(rest.template get<N-1>()) {
        return rest.template get<N-1>();
    }
    
    template<>
    auto get<0>() const -> T {
        return first;
    }
    
    void display() const {
        std::cout << "(" << first;
        rest.display();
        std::cout << ")";
    }
};

// 可变参数函数：创建元组
template<typename... Args>
auto makeTuple(Args... args) {
    return Tuple<Args...>(args...);
}

// 可变参数函数：参数包展开
template<typename... Args>
void expand(Args... args) {
    std::cout << "Expanding parameters:" << std::endl;
    (std::cout << ... << args) << std::endl;
}

// 可变参数函数：条件打印
template<typename... Args>
void printIf(bool condition, Args... args) {
    if (condition) {
        print(args...);
    }
}

int main() {
    // 测试可变参数函数
    std::cout << "Testing variadic functions:" << std::endl;
    print(1, 2, 3, 4, 5);
    print("Hello", "World", 42, 3.14);
    
    std::cout << "Count: " << count(1, 2, 3, 4, 5) << std::endl;
    std::cout << "Sum: " << sum(1, 2, 3, 4, 5) << std::endl;
    std::cout << "Max: " << maximum(1, 5, 3, 9, 2) << std::endl;
    
    // 测试元组
    std::cout << "\nTesting Tuple:" << std::endl;
    auto t1 = makeTuple(1, 2.5, std::string("Hello"));
    t1.display();
    std::cout << std::endl;
    
    // 测试参数包展开
    std::cout << "\nTesting parameter pack expansion:" << std::endl;
    expand(1, 2, 3);
    
    // 测试条件打印
    std::cout << "\nTesting conditional printing:" << std::endl;
    printIf(true, "This will be printed");
    printIf(false, "This will not be printed");
    
    return 0;
}
```

### 第6天：模板特化

#### 题目10：模板元编程基础
**难度**：★★★★☆

编写程序实现模板元编程：
1. 编译期计算
2. 类型萃取
3. SFINAE技术

**要求**：
```cpp
#include <iostream>
#include <type_traits>

// 编译期计算：阶乘
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// 编译期计算：斐波那契数列
template<int N>
struct Fibonacci {
    static const int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template<>
struct Fibonacci<0> {
    static const int value = 0;
};

template<>
struct Fibonacci<1> {
    static const int value = 1;
};

// 类型萃取：判断是否为指针
template<typename T>
struct IsPointer {
    static const bool value = false;
};

template<typename T>
struct IsPointer<T*> {
    static const bool value = true;
};

// 类型萃取：判断是否为引用
template<typename T>
struct IsReference {
    static const bool value = false;
};

template<typename T>
struct IsReference<T&> {
    static const bool value = true;
};

// 类型萃取：获取底层类型
template<typename T>
struct RemovePointer {
    using type = T;
};

template<typename T>
struct RemovePointer<T*> {
    using type = T;
};

// SFINAE：根据类型选择函数
template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
process(T value) {
    std::cout << "Processing integer: " << value << std::endl;
}

template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type
process(T value) {
    std::cout << "Processing floating point: " << value << std::endl;
}

template<typename T>
typename std::enable_if<std::is_same<T, std::string>::value, void>::type
process(T value) {
    std::cout << "Processing string: " << value << std::endl;
}

// SFINAE：检测成员函数
template<typename T>
class HasDisplay {
private:
    template<typename U>
    static auto test(int) -> decltype(std::declval<U>().display(), std::true_type{});
    
    template<typename U>
    static std::false_type test(...);

public:
    static const bool value = decltype(test<T>(0))::value;
};

// 使用SFINAE的函数
template<typename T>
typename std::enable_if<HasDisplay<T>::value, void>::type
callDisplay(T obj) {
    obj.display();
}

template<typename T>
typename std::enable_if<!HasDisplay<T>::value, void>::type
callDisplay(T obj) {
    std::cout << "Object does not have display method" << std::endl;
}

// 测试类
class TestClass {
public:
    void display() const {
        std::cout << "TestClass display method" << std::endl;
    }
};

class TestClass2 {
public:
    void show() const {
        std::cout << "TestClass2 show method" << std::endl;
    }
};

int main() {
    // 测试编译期计算
    std::cout << "Compile-time calculations:" << std::endl;
    std::cout << "Factorial of 5: " << Factorial<5>::value << std::endl;
    std::cout << "Factorial of 10: " << Factorial<10>::value << std::endl;
    std::cout << "Fibonacci(10): " << Fibonacci<10>::value << std::endl;
    
    // 测试类型萃取
    std::cout << "\nType traits:" << std::endl;
    std::cout << "Is int* a pointer: " << IsPointer<int*>::value << std::endl;
    std::cout << "Is int a pointer: " << IsPointer<int>::value << std::endl;
    std::cout << "Is int& a reference: " << IsReference<int&>::value << std::endl;
    std::cout << "Is int a reference: " << IsReference<int>::value << std::endl;
    
    // 测试类型转换
    std::cout << "\nType transformations:" << std::endl;
    std::cout << "Remove pointer from int*: " << typeid(RemovePointer<int*>::type).name() << std::endl;
    std::cout << "Remove pointer from int: " << typeid(RemovePointer<int>::type).name() << std::endl;
    
    // 测试SFINAE
    std::cout << "\nSFINAE testing:" << std::endl;
    process(42);
    process(3.14);
    process(std::string("Hello"));
    
    // 测试成员函数检测
    std::cout << "\nMember function detection:" << std::endl;
    TestClass obj1;
    TestClass2 obj2;
    
    callDisplay(obj1);
    callDisplay(obj2);
    
    return 0;
}
```

### 第7天：综合练习

#### 项目1：简单容器类
**难度**：★★★★☆

实现一个简单的动态数组类模板，包含以下功能：
1. 动态内存分配
2. 元素访问和修改
3. 大小管理
4. 拷贝构造和赋值操作

**要求**：
```cpp
#include <iostream>
#include <stdexcept>
#include <algorithm>

template<typename T>
class DynamicArray {
private:
    T* data;
    size_t size;
    size_t capacity;
    
public:
    // 构造函数
    DynamicArray() : data(nullptr), size(0), capacity(0) {}
    
    DynamicArray(size_t initialCapacity) : size(0), capacity(initialCapacity) {
        data = new T[capacity];
    }
    
    // 析构函数
    ~DynamicArray() {
        delete[] data;
    }
    
    // 拷贝构造函数
    DynamicArray(const DynamicArray& other) : size(other.size), capacity(other.capacity) {
        data = new T[capacity];
        for (size_t i = 0; i < size; ++i) {
            data[i] = other.data[i];
        }
    }
    
    // 赋值操作符
    DynamicArray& operator=(const DynamicArray& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            capacity = other.capacity;
            data = new T[capacity];
            for (size_t i = 0; i < size; ++i) {
                data[i] = other.data[i];
            }
        }
        return *this;
    }
    
    // 移动构造函数
    DynamicArray(DynamicArray&& other) noexcept : data(other.data), size(other.size), capacity(other.capacity) {
        other.data = nullptr;
        other.size = 0;
        other.capacity = 0;
    }
    
    // 移动赋值操作符
    DynamicArray& operator=(DynamicArray&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            capacity = other.capacity;
            other.data = nullptr;
            other.size = 0;
            other.capacity = 0;
        }
        return *this;
    }
    
    // 基本操作
    void push_back(const T& element) {
        if (size >= capacity) {
            reserve(capacity == 0 ? 1 : capacity * 2);
        }
        data[size++] = element;
    }
    
    void pop_back() {
        if (size > 0) {
            --size;
        }
    }
    
    T& operator[](size_t index) {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    // 容量管理
    size_t getSize() const { return size; }
    size_t getCapacity() const { return capacity; }
    bool empty() const { return size == 0; }
    
    void reserve(size_t newCapacity) {
        if (newCapacity > capacity) {
            T* newData = new T[newCapacity];
            for (size_t i = 0; i < size; ++i) {
                newData[i] = data[i];
            }
            delete[] data;
            data = newData;
            capacity = newCapacity;
        }
    }
    
    void resize(size_t newSize) {
        if (newSize > capacity) {
            reserve(newSize);
        }
        size = newSize;
    }
    
    // 迭代器支持
    T* begin() { return data; }
    T* end() { return data + size; }
    const T* begin() const { return data; }
    const T* end() const { return data + size; }
    
    // 显示信息
    void display() const {
        std::cout << "Size: " << size << ", Capacity: " << capacity << std::endl;
        std::cout << "Elements: ";
        for (size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    try {
        // 测试int类型
        DynamicArray<int> intArray;
        
        for (int i = 1; i <= 10; ++i) {
            intArray.push_back(i * i);
        }
        
        std::cout << "Integer Array:" << std::endl;
        intArray.display();
        
        // 测试拷贝
        DynamicArray<int> intArray2 = intArray;
        std::cout << "\nCopied Array:" << std::endl;
        intArray2.display();
        
        // 测试string类型
        DynamicArray<std::string> stringArray;
        stringArray.push_back("Hello");
        stringArray.push_back("World");
        stringArray.push_back("C++");
        
        std::cout << "\nString Array:" << std::endl;
        stringArray.display();
        
        // 测试范围for循环
        std::cout << "\nUsing range-based for loop:" << std::endl;
        for (const auto& str : stringArray) {
            std::cout << str << " ";
        }
        std::cout << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

## 检查点

### 第2周结束时的能力要求
- [ ] 能够编写函数模板
- [ ] 理解模板参数推导机制
- [ ] 能够编写类模板
- [ ] 掌握模板特化的使用
- [ ] 理解模板元编程基础
- [ ] 能够设计和使用模板类
- [ ] 完成项目1的主要功能
- [ ] 理解模板的编译机制

## 评分标准

### 题目1-3：函数模板基础（30分）
- 基本函数模板（10分）
- 多参数函数模板（10分）
- 模板参数推导（10分）

### 题目4-5：函数模板进阶（30分）
- 模板特化（15分）
- 模板重载（15分）

### 题目6-7：类模板基础（30分）
- 基本类模板（15分）
- 多参数类模板（15分）

### 题目8：类模板特化（20分）
- 全特化和偏特化（20分）

### 题目9：模板参数包（20分）
- 可变参数函数和类（20分）

### 题目10：模板元编程（20分）
- 编译期计算和类型萃取（20分）

### 项目1：简单容器类（50分）
- 实现基本功能（20分）
- 异常安全（15分）
- 代码质量（15分）

**总分：200分**
**及格分数：120分（60%）**

---

**学习时间**：第2周  
**预计完成时间**：2024-01-29



