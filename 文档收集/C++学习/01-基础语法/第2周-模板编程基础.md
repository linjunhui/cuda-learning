# 第2周：模板编程基础

## 学习目标

掌握C++模板编程的基本概念，包括函数模板、类模板、模板特化和模板参数推导。

## 学习内容

### 1. 函数模板

#### 1.1 基本函数模板
```cpp
// 基本函数模板
template<typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

// 使用示例
int main() {
    std::cout << maximum(10, 20) << std::endl;           // int版本
    std::cout << maximum(3.14, 2.71) << std::endl;       // double版本
    std::cout << maximum('A', 'B') << std::endl;         // char版本
    
    return 0;
}
```

#### 1.2 多参数模板
```cpp
// 多参数函数模板
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

// 使用示例
int main() {
    auto result1 = add(10, 3.14);    // int + double
    auto result2 = add(3.14, 10);    // double + int
    std::cout << result1 << " " << result2 << std::endl;
    
    return 0;
}
```

#### 1.3 模板参数推导
```cpp
// 自动推导参数类型
template<typename T>
void printArray(T arr[], int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

// 显式指定类型
template<typename T>
void printValue(T value) {
    std::cout << "Value: " << value << std::endl;
}

int main() {
    int intArray[] = {1, 2, 3, 4, 5};
    double doubleArray[] = {1.1, 2.2, 3.3};
    
    printArray(intArray, 5);         // 自动推导T为int
    printArray(doubleArray, 3);      // 自动推导T为double
    
    printValue<int>(42);             // 显式指定类型
    printValue(3.14);                // 自动推导类型
    
    return 0;
}
```

#### 1.4 模板特化
```cpp
// 通用模板
template<typename T>
void printType(T value) {
    std::cout << "Generic type: " << value << std::endl;
}

// 特化版本
template<>
void printType<std::string>(std::string value) {
    std::cout << "String type: " << value << std::endl;
}

template<>
void printType<int>(int value) {
    std::cout << "Integer type: " << value << std::endl;
}

int main() {
    printType(42);                   // 调用int特化版本
    printType(3.14);                 // 调用通用版本
    printType(std::string("hello")); // 调用string特化版本
    
    return 0;
}
```

### 2. 类模板

#### 2.1 基本类模板
```cpp
// 基本类模板
template<typename T>
class Stack {
private:
    std::vector<T> elements;

public:
    // 构造函数
    Stack() = default;
    
    // 成员函数
    void push(const T& element) {
        elements.push_back(element);
    }
    
    void pop() {
        if (!elements.empty()) {
            elements.pop_back();
        }
    }
    
    T top() const {
        if (!elements.empty()) {
            return elements.back();
        }
        throw std::runtime_error("Stack is empty");
    }
    
    bool empty() const {
        return elements.empty();
    }
    
    size_t size() const {
        return elements.size();
    }
};

// 使用示例
int main() {
    Stack<int> intStack;
    intStack.push(1);
    intStack.push(2);
    intStack.push(3);
    
    while (!intStack.empty()) {
        std::cout << intStack.top() << " ";
        intStack.pop();
    }
    std::cout << std::endl;
    
    return 0;
}
```

#### 2.2 多参数类模板
```cpp
// 多参数类模板
template<typename T, typename U>
class Pair {
private:
    T first;
    U second;

public:
    Pair(T f, U s) : first(f), second(s) {}
    
    T getFirst() const { return first; }
    U getSecond() const { return second; }
    
    void setFirst(T f) { first = f; }
    void setSecond(U s) { second = s; }
    
    void display() const {
        std::cout << "(" << first << ", " << second << ")" << std::endl;
    }
};

// 使用示例
int main() {
    Pair<int, std::string> p1(1, "hello");
    Pair<double, char> p2(3.14, 'A');
    
    p1.display();
    p2.display();
    
    return 0;
}
```

#### 2.3 类模板特化
```cpp
// 通用类模板
template<typename T>
class Array {
private:
    T* data;
    size_t size;

public:
    Array(size_t s) : size(s) {
        data = new T[size];
    }
    
    ~Array() {
        delete[] data;
    }
    
    T& operator[](size_t index) {
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        return data[index];
    }
    
    size_t getSize() const {
        return size;
    }
};

// 特化版本 - bool类型优化
template<>
class Array<bool> {
private:
    unsigned char* data;
    size_t size;

public:
    Array(size_t s) : size(s) {
        data = new unsigned char[(size + 7) / 8];
    }
    
    ~Array() {
        delete[] data;
    }
    
    bool operator[](size_t index) const {
        return (data[index / 8] & (1 << (index % 8))) != 0;
    }
    
    void set(size_t index, bool value) {
        if (value) {
            data[index / 8] |= (1 << (index % 8));
        } else {
            data[index / 8] &= ~(1 << (index % 8));
        }
    }
    
    size_t getSize() const {
        return size;
    }
};
```

### 3. 模板参数推导

#### 3.1 自动推导
```cpp
// C++17自动推导
template<typename T>
class Container {
private:
    T value;

public:
    Container(T v) : value(v) {}
    
    T getValue() const { return value; }
};

// 使用示例
int main() {
    Container c1(42);        // 自动推导为Container<int>
    Container c2(3.14);      // 自动推导为Container<double>
    Container c3("hello");   // 自动推导为Container<const char*>
    
    std::cout << c1.getValue() << std::endl;
    std::cout << c2.getValue() << std::endl;
    std::cout << c3.getValue() << std::endl;
    
    return 0;
}
```

#### 3.2 模板参数包
```cpp
// 可变参数模板
template<typename... Args>
void print(Args... args) {
    ((std::cout << args << " "), ...);
    std::cout << std::endl;
}

// 使用示例
int main() {
    print(1, 2, 3, 4, 5);
    print("hello", 42, 3.14);
    print('A', 'B', 'C');
    
    return 0;
}
```

#### 3.3 模板元编程基础
```cpp
// 编译期计算
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// 类型萃取
template<typename T>
struct IsPointer {
    static const bool value = false;
};

template<typename T>
struct IsPointer<T*> {
    static const bool value = true;
};

// 使用示例
int main() {
    std::cout << "Factorial of 5: " << Factorial<5>::value << std::endl;
    std::cout << "int* is pointer: " << IsPointer<int*>::value << std::endl;
    std::cout << "int is pointer: " << IsPointer<int>::value << std::endl;
    
    return 0;
}
```

### 4. 模板特化

#### 4.1 全特化
```cpp
// 通用模板
template<typename T>
class TypeInfo {
public:
    static std::string getTypeName() {
        return "Unknown";
    }
};

// 全特化
template<>
class TypeInfo<int> {
public:
    static std::string getTypeName() {
        return "int";
    }
};

template<>
class TypeInfo<double> {
public:
    static std::string getTypeName() {
        return "double";
    }
};

template<>
class TypeInfo<std::string> {
public:
    static std::string getTypeName() {
        return "std::string";
    }
};
```

#### 4.2 偏特化
```cpp
// 通用模板
template<typename T, typename U>
class Pair {
public:
    static std::string getTypeInfo() {
        return "Generic Pair";
    }
};

// 偏特化 - 相同类型
template<typename T>
class Pair<T, T> {
public:
    static std::string getTypeInfo() {
        return "Same Type Pair";
    }
};

// 偏特化 - 指针类型
template<typename T, typename U>
class Pair<T*, U*> {
public:
    static std::string getTypeInfo() {
        return "Pointer Pair";
    }
};
```

## 实践练习

### 练习1：函数模板练习
编写以下函数模板：
1. `swap` - 交换两个变量的值
2. `find` - 在数组中查找元素
3. `sort` - 对数组进行排序（冒泡排序）
4. `max` - 返回多个参数中的最大值

### 练习2：类模板练习
设计以下类模板：
1. `Vector` - 简单的动态数组类
2. `Queue` - 队列类
3. `Matrix` - 矩阵类
4. `SmartPointer` - 简单的智能指针类

### 练习3：模板特化练习
为以下场景编写特化版本：
1. 字符串类型的特殊处理
2. 指针类型的优化
3. 数值类型的特殊计算
4. 容器类型的特化

## 每日学习任务

### 第1天：函数模板基础
- 学习函数模板的基本语法
- 理解模板参数推导
- 练习编写简单的函数模板

### 第2天：函数模板进阶
- 学习多参数模板
- 掌握模板特化
- 理解模板重载

### 第3天：类模板基础
- 学习类模板的基本语法
- 理解类模板的实例化
- 练习编写简单的类模板

### 第4天：类模板进阶
- 学习多参数类模板
- 掌握类模板特化
- 理解模板继承

### 第5天：模板参数推导
- 学习自动类型推导
- 掌握模板参数包
- 理解SFINAE概念

### 第6天：模板特化
- 学习全特化和偏特化
- 掌握特化的使用场景
- 练习编写特化版本

### 第7天：综合练习
- 完成所有实践练习
- 开始项目1：简单容器类
- 应用模板知识

## 项目1：简单容器类

### 项目要求
实现一个简单的动态数组类模板，包含以下功能：

```cpp
template<typename T>
class DynamicArray {
private:
    T* data;
    size_t size;
    size_t capacity;

public:
    // 构造函数和析构函数
    DynamicArray();
    DynamicArray(size_t initialCapacity);
    ~DynamicArray();
    
    // 拷贝构造函数和赋值操作符
    DynamicArray(const DynamicArray& other);
    DynamicArray& operator=(const DynamicArray& other);
    
    // 移动构造函数和移动赋值操作符
    DynamicArray(DynamicArray&& other) noexcept;
    DynamicArray& operator=(DynamicArray&& other) noexcept;
    
    // 基本操作
    void push_back(const T& element);
    void pop_back();
    T& operator[](size_t index);
    const T& operator[](size_t index) const;
    
    // 容量管理
    size_t size() const;
    size_t capacity() const;
    bool empty() const;
    void reserve(size_t newCapacity);
    void resize(size_t newSize);
    
    // 迭代器支持
    T* begin();
    T* end();
    const T* begin() const;
    const T* end() const;
};
```

### 实现要点
1. 使用模板实现泛型
2. 实现拷贝语义和移动语义
3. 提供迭代器支持
4. 实现容量管理和内存优化
5. 异常安全保证

## 检查点

### 第2周结束时的能力要求
- [ ] 能够编写函数模板
- [ ] 理解模板参数推导机制
- [ ] 能够编写类模板
- [ ] 掌握模板特化的使用
- [ ] 理解模板元编程基础
- [ ] 能够设计和使用模板类
- [ ] 完成项目1的主要功能
- [ ] 理解模板的编译机制

## 常见问题解答

### Q: 模板什么时候实例化？
A: 模板在第一次使用时实例化。编译器根据模板参数生成具体的代码。

### Q: 如何避免模板代码膨胀？
A: 使用显式实例化、模板特化、或者将实现移到源文件中。

### Q: 模板参数可以是哪些类型？
A: 模板参数可以是类型、非类型参数（如整数、指针）、模板参数包等。

### Q: 如何调试模板代码？
A: 使用编译器错误信息、静态断言、类型萃取等技术来调试模板代码。

### Q: 模板特化和重载的区别？
A: 特化是针对特定类型的特殊实现，重载是函数名相同但参数不同的多个函数。

---

**学习时间**：第2周  
**预计完成时间**：2024-01-29
