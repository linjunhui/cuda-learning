# 第4周：内存管理和异常处理 - 训练题目

## 学习目标
通过实践练习掌握C++内存管理技术，包括智能指针、RAII原则、异常处理机制和资源管理最佳实践。

## 每日训练题目

### 第1天：智能指针基础

#### 题目1：unique_ptr使用
**难度**：★☆☆☆☆

编写程序使用unique_ptr管理资源：
1. 管理动态数组
2. 管理自定义对象
3. 转移所有权

**要求**：
```cpp
#include <memory>
#include <iostream>

class Resource {
public:
    Resource(const std::string& name) : name(name) {
        std::cout << "Resource " << name << " created" << std::endl;
    }
    
    ~Resource() {
        std::cout << "Resource " << name << " destroyed" << std::endl;
    }
    
    void use() {
        std::cout << "Using resource " << name << std::endl;
    }
    
private:
    std::string name;
};

int main() {
    // 创建unique_ptr
    std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>("Resource1");
    ptr1->use();
    
    // 转移所有权
    std::unique_ptr<Resource> ptr2 = std::move(ptr1);
    
    if (ptr1 == nullptr) {
        std::cout << "ptr1 is now empty" << std::endl;
    }
    
    ptr2->use();
    
    return 0;
}
```

#### 题目2：shared_ptr和weak_ptr
**难度**：★★☆☆☆

编写程序使用shared_ptr和weak_ptr：
1. 共享所有权
2. 避免循环引用
3. 弱引用使用

**要求**：
```cpp
#include <memory>
#include <iostream>

class Node {
public:
    std::string name;
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> parent;
    
    Node(const std::string& n) : name(n) {
        std::cout << "Node " << name << " created" << std::endl;
    }
    
    ~Node() {
        std::cout << "Node " << name << " destroyed" << std::endl;
    }
    
    void setParent(std::shared_ptr<Node> p) {
        parent = p;
    }
    
    void printParent() {
        if (auto p = parent.lock()) {
            std::cout << "Parent: " << p->name << std::endl;
        } else {
            std::cout << "Parent is no longer available" << std::endl;
        }
    }
};

int main() {
    auto node1 = std::make_shared<Node>("Node1");
    auto node2 = std::make_shared<Node>("Node2");
    
    node1->next = node2;
    node2->setParent(node1);
    
    node2->printParent();
    
    node1.reset();
    node2->printParent();
    
    return 0;
}
```

### 第2天：RAII原则

#### 题目3：RAII类设计
**难度**：★★☆☆☆

设计RAII类管理资源：
1. 文件句柄管理
2. 数据库连接管理
3. 锁管理

**要求**：
```cpp
#include <iostream>
#include <memory>
#include <fstream>

class FileHandle {
private:
    std::string filename;
    std::ofstream file;
    
public:
    FileHandle(const std::string& name) : filename(name) {
        file.open(filename);
        if (file.is_open()) {
            std::cout << "File " << filename << " opened" << std::endl;
        }
    }
    
    ~FileHandle() {
        if (file.is_open()) {
            file.close();
            std::cout << "File " << filename << " closed" << std::endl;
        }
    }
    
    void write(const std::string& data) {
        if (file.is_open()) {
            file << data;
        }
    }
    
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
    
    FileHandle(FileHandle&& other) noexcept : filename(std::move(other.filename)), file(std::move(other.file)) {
        other.filename.clear();
    }
};

int main() {
    FileHandle file("test.txt");
    file.write("Hello, RAII!");
    
    return 0;
}
```

### 第3天：异常处理

#### 题目4：异常处理机制
**难度**：★★☆☆☆

编写程序实现异常处理：
1. 基本异常处理
2. 自定义异常类
3. 异常安全保证

**要求**：
```cpp
#include <iostream>
#include <stdexcept>
#include <string>

class BankException : public std::exception {
private:
    std::string message;
    
public:
    BankException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class InsufficientFundsException : public BankException {
public:
    InsufficientFundsException(double amount, double balance) 
        : BankException("Insufficient funds: requested " + std::to_string(amount) + 
                       ", available " + std::to_string(balance)) {}
};

class BankAccount {
private:
    std::string accountNumber;
    double balance;
    
public:
    BankAccount(const std::string& accNum, double initialBalance = 0.0) 
        : accountNumber(accNum), balance(initialBalance) {}
    
    void deposit(double amount) {
        if (amount <= 0) {
            throw std::invalid_argument("Amount must be positive");
        }
        balance += amount;
    }
    
    void withdraw(double amount) {
        if (amount <= 0) {
            throw std::invalid_argument("Amount must be positive");
        }
        if (amount > balance) {
            throw InsufficientFundsException(amount, balance);
        }
        balance -= amount;
    }
    
    double getBalance() const {
        return balance;
    }
};

int main() {
    BankAccount account("12345", 1000.0);
    
    try {
        account.deposit(500.0);
        account.withdraw(200.0);
        account.withdraw(2000.0);
    } catch (const InsufficientFundsException& e) {
        std::cerr << "Insufficient funds error: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 第4天：资源管理

#### 题目5：内存泄漏检测
**难度**：★★★☆☆

编写程序检测和避免内存泄漏：
1. 内存泄漏检测
2. 异常安全编程
3. 资源管理最佳实践

**要求**：
```cpp
#include <iostream>
#include <memory>
#include <vector>

class MemoryTracker {
private:
    static size_t allocated;
    static size_t deallocated;
    
public:
    static void* allocate(size_t size) {
        void* ptr = malloc(size);
        if (ptr) {
            allocated += size;
        }
        return ptr;
    }
    
    static void deallocate(void* ptr, size_t size) {
        if (ptr) {
            free(ptr);
            deallocated += size;
        }
    }
    
    static void report() {
        std::cout << "Memory report - Allocated: " << allocated 
                  << ", Deallocated: " << deallocated 
                  << ", Leaked: " << (allocated - deallocated) << std::endl;
    }
};

size_t MemoryTracker::allocated = 0;
size_t MemoryTracker::deallocated = 0;

class ManagedArray {
private:
    int* data;
    size_t size;
    
public:
    ManagedArray(size_t s) : size(s) {
        data = new int[size];
    }
    
    ~ManagedArray() {
        delete[] data;
    }
    
    ManagedArray(const ManagedArray&) = delete;
    ManagedArray& operator=(const ManagedArray&) = delete;
    
    ManagedArray(ManagedArray&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
    
    int& operator[](size_t index) {
        return data[index];
    }
    
    size_t getSize() const {
        return size;
    }
};

int main() {
    {
        ManagedArray arr(10);
        for (size_t i = 0; i < arr.getSize(); ++i) {
            arr[i] = static_cast<int>(i);
        }
        
        for (size_t i = 0; i < arr.getSize(); ++i) {
            std::cout << arr[i] << " ";
        }
        std::cout << std::endl;
    }
    
    MemoryTracker::report();
    
    return 0;
}
```

### 第5天：综合练习

#### 题目6：异常安全的容器
**难度**：★★★☆☆

实现异常安全的容器类：
1. 强异常安全保证
2. 移动语义支持
3. 资源管理

**要求**：
```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <stdexcept>

template<typename T>
class ExceptionSafeVector {
private:
    std::vector<T> data;
    
public:
    void insert(size_t pos, const T& value) {
        std::vector<T> temp = data;
        temp.insert(temp.begin() + pos, value);
        data = std::move(temp);
    }
    
    void push_back(const T& value) {
        data.push_back(value);
    }
    
    T& operator[](size_t index) {
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        return data[index];
    }
    
    size_t size() const {
        return data.size();
    }
    
    void display() const {
        for (const auto& element : data) {
            std::cout << element << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    ExceptionSafeVector<int> vec;
    
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.insert(1, 99);
    
    vec.display();
    
    return 0;
}
```

### 第6天：项目实践

#### 项目3：内存安全程序
**难度**：★★★★☆

实现一个内存安全的C++程序：
1. 使用智能指针管理内存
2. 实现RAII原则
3. 提供异常安全保证

**要求**：
```cpp
#include <memory>
#include <vector>
#include <string>
#include <stdexcept>

class MemorySafeString {
private:
    std::unique_ptr<char[]> data;
    size_t length;
    
public:
    MemorySafeString();
    MemorySafeString(const char* str);
    MemorySafeString(const std::string& str);
    
    MemorySafeString(const MemorySafeString& other);
    MemorySafeString& operator=(const MemorySafeString& other);
    
    MemorySafeString(MemorySafeString&& other) noexcept;
    MemorySafeString& operator=(MemorySafeString&& other) noexcept;
    
    char& operator[](size_t index);
    const char& operator[](size_t index) const;
    
    size_t length() const;
    const char* c_str() const;
    
    MemorySafeString operator+(const MemorySafeString& other) const;
    bool operator==(const MemorySafeString& other) const;
    
    void append(const MemorySafeString& other);
    void display() const;
};

int main() {
    MemorySafeString str1("Hello");
    MemorySafeString str2(" World");
    
    str1.append(str2);
    str1.display();
    
    return 0;
}
```

## 检查点

### 第4周结束时的能力要求
- [ ] 熟练使用智能指针
- [ ] 理解RAII原则和实现
- [ ] 掌握异常处理机制
- [ ] 能够编写异常安全的代码
- [ ] 理解资源管理最佳实践
- [ ] 能够检测和避免内存泄漏
- [ ] 完成项目3的主要功能
- [ ] 具备内存安全编程能力

## 评分标准

### 题目1-2：智能指针（30分）
- unique_ptr使用（15分）
- shared_ptr和weak_ptr（15分）

### 题目3：RAII原则（20分）
- RAII类设计（20分）

### 题目4：异常处理（20分）
- 异常处理机制（20分）

### 题目5：资源管理（20分）
- 内存泄漏检测（20分）

### 题目6：综合练习（20分）
- 异常安全的容器（20分）

### 项目3：内存安全程序（50分）
- 实现基本功能（20分）
- 异常安全（15分）
- 代码质量（15分）

**总分：160分**
**及格分数：96分（60%）**

---

**学习时间**：第4周  
**预计完成时间**：2024-02-12



