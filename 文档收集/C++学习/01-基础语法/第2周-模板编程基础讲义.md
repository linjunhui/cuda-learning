# 第2周：C++模板编程基础讲义

## 课程概述

### 学习目标
通过本课程的学习，学生将掌握C++模板编程的核心概念和实际应用，包括：
- 函数模板的设计与实现
- 类模板的构建与使用
- 模板特化技术
- 模板参数推导机制
- 模板元编程基础

### 课程结构
- **第1-2天**：函数模板基础与进阶
- **第3-4天**：类模板基础与进阶
- **第5天**：模板参数推导与参数包
- **第6天**：模板特化技术
- **第7天**：综合项目实践

---

## 第一部分：函数模板基础

### 1.1 模板的基本概念

#### 什么是模板？
模板是C++提供的一种泛型编程机制，允许我们编写与类型无关的代码。模板在编译时进行实例化，生成特定类型的代码。

#### 模板的优势
1. **代码复用**：一次编写，多种类型使用
2. **类型安全**：编译时类型检查
3. **性能优化**：编译时优化，无运行时开销
4. **灵活性**：支持用户自定义类型

### 1.2 函数模板语法

#### 基本语法结构
```cpp
template<typename T>
返回类型 函数名(参数列表) {
    // 函数体
}
```

#### 关键字说明
- `template`：模板声明关键字
- `typename`：类型参数声明（C++11后可用`class`替代）
- `T`：类型参数名（可以是任意标识符）

### 1.3 函数模板实例化

#### 隐式实例化
编译器根据函数调用自动推导类型：
```cpp
template<typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

// 使用示例
int result1 = maximum(10, 20);        // T推导为int
double result2 = maximum(3.14, 2.71); // T推导为double
```

#### 显式实例化
手动指定模板参数类型：
```cpp
int result = maximum<int>(10, 20);     // 显式指定T为int
double result = maximum<double>(3.14, 2.71); // 显式指定T为double
```

### 1.4 多参数函数模板

#### 多个类型参数
```cpp
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}
```

#### 参数推导规则
1. 每个模板参数独立推导
2. 推导失败时编译错误
3. 可以使用`decltype`推导返回类型

---

## 第二部分：函数模板进阶

### 2.1 模板特化

#### 全特化
为特定类型提供专门的实现：
```cpp
// 通用模板
template<typename T>
void printType(T value) {
    std::cout << "Generic type: " << value << std::endl;
}

// 全特化：int类型
template<>
void printType<int>(int value) {
    std::cout << "Integer type: " << value << std::endl;
}
```

#### 特化的使用场景
1. **性能优化**：为特定类型提供优化实现
2. **特殊处理**：处理特定类型的特殊情况
3. **接口适配**：适配特定类型的接口要求

### 2.2 模板重载

#### 重载规则
1. **非模板函数优先**：非模板函数比模板函数优先级高
2. **特化优于通用**：特化版本比通用模板优先级高
3. **参数匹配**：参数类型匹配度决定选择

#### 重载示例
```cpp
// 非模板函数
void print(int value) {
    std::cout << "Non-template function: " << value << std::endl;
}

// 函数模板
template<typename T>
void print(T value) {
    std::cout << "Template function: " << value << std::endl;
}

// 特化模板
template<>
void print<double>(double value) {
    std::cout << "Specialized template for double: " << value << std::endl;
}
```

---

## 第三部分：类模板基础

### 3.1 类模板语法

#### 基本语法
```cpp
template<typename T>
class 类名 {
    // 类成员
};
```

#### 成员函数定义
```cpp
template<typename T>
class Stack {
private:
    std::vector<T> elements;

public:
    void push(const T& element) {
        elements.push_back(element);
    }
    
    T top() const {
        return elements.back();
    }
};
```

### 3.2 类模板实例化

#### 实例化语法
```cpp
Stack<int> intStack;           // 创建int类型的栈
Stack<std::string> stringStack; // 创建string类型的栈
```

#### 注意事项
1. **显式实例化**：类模板必须显式指定类型参数
2. **成员函数延迟实例化**：只有使用的成员函数才会被实例化
3. **模板参数推导**：类模板不支持参数推导

### 3.3 多参数类模板

#### 多个类型参数
```cpp
template<typename T, typename U>
class Pair {
private:
    T first;
    U second;

public:
    Pair(T f, U s) : first(f), second(s) {}
    
    T getFirst() const { return first; }
    U getSecond() const { return second; }
};
```

#### 非类型模板参数
```cpp
template<typename T, size_t N>
class Array {
private:
    T data[N];

public:
    T& operator[](size_t index) {
        return data[index];
    }
    
    size_t size() const { return N; }
};
```

---

## 第四部分：类模板进阶

### 4.1 类模板特化

#### 全特化
```cpp
// 通用模板
template<typename T>
class Container {
private:
    T value;

public:
    Container(T v) : value(v) {}
    void display() const {
        std::cout << "Generic container: " << value << std::endl;
    }
};

// 全特化：int类型
template<>
class Container<int> {
private:
    int value;

public:
    Container(int v) : value(v) {}
    void display() const {
        std::cout << "Integer container: " << value << std::endl;
    }
    
    bool isEven() const {
        return value % 2 == 0;
    }
};
```

#### 偏特化
```cpp
// 通用模板
template<typename T, typename U>
class Pair {
    // 通用实现
};

// 偏特化：相同类型
template<typename T>
class Pair<T, T> {
    // 相同类型的特殊实现
};

// 偏特化：指针类型
template<typename T, typename U>
class Pair<T*, U*> {
    // 指针类型的特殊实现
};
```

### 4.2 模板友元

#### 友元函数模板
```cpp
template<typename T>
class MyClass {
private:
    T value;

public:
    template<typename U>
    friend void friendFunction(MyClass<U>& obj);
};
```

---

## 第五部分：模板参数推导与参数包

### 5.1 模板参数推导

#### 推导规则
1. **函数参数推导**：根据函数参数类型推导模板参数
2. **返回类型推导**：使用`auto`和`decltype`推导返回类型
3. **上下文推导**：根据使用上下文推导类型

#### 推导示例
```cpp
template<typename T>
void printType(T value) {
    std::cout << "Value: " << value << ", Type: " << typeid(T).name() << std::endl;
}

// 自动推导
printType(42);        // T推导为int
printType(3.14);      // T推导为double
printType("Hello");   // T推导为const char*
```

### 5.2 可变参数模板

#### 参数包语法
```cpp
template<typename... Args>
void print(Args... args) {
    ((std::cout << args << " "), ...);
    std::cout << std::endl;
}
```

#### 参数包展开
```cpp
// 折叠表达式（C++17）
template<typename... Args>
auto sum(Args... args) -> decltype((args + ...)) {
    return (args + ...);
}

// 递归展开
template<typename T>
void print(T value) {
    std::cout << value << std::endl;
}

template<typename T, typename... Args>
void print(T value, Args... args) {
    std::cout << value << " ";
    print(args...);
}
```

### 5.3 可变参数类模板

#### 元组实现
```cpp
template<typename... Types>
class Tuple;

template<>
class Tuple<> {
    // 空元组
};

template<typename T, typename... Rest>
class Tuple<T, Rest...> {
private:
    T first;
    Tuple<Rest...> rest;

public:
    Tuple(T f, Rest... r) : first(f), rest(r...) {}
    
    T getFirst() const { return first; }
    
    template<size_t N>
    auto get() const -> decltype(rest.template get<N-1>()) {
        return rest.template get<N-1>();
    }
    
    template<>
    auto get<0>() const -> T {
        return first;
    }
};
```

---

## 第六部分：模板特化技术

### 6.1 模板元编程基础

#### 编译期计算
```cpp
// 阶乘计算
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// 使用
const int result = Factorial<5>::value; // 编译期计算120
```

#### 类型萃取
```cpp
// 判断是否为指针
template<typename T>
struct IsPointer {
    static const bool value = false;
};

template<typename T>
struct IsPointer<T*> {
    static const bool value = true;
};

// 获取底层类型
template<typename T>
struct RemovePointer {
    using type = T;
};

template<typename T>
struct RemovePointer<T*> {
    using type = T;
};
```

### 6.2 SFINAE技术

#### SFINAE原理
SFINAE（Substitution Failure Is Not An Error）是C++模板元编程的重要技术，当模板参数替换失败时，编译器不会报错，而是选择其他可用的模板。

#### SFINAE应用
```cpp
// 根据类型选择函数
template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
process(T value) {
    std::cout << "Processing integer: " << value << std::endl;
}

template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type
process(T value) {
    std::cout << "Processing floating point: " << value << std::endl;
}
```

#### 成员函数检测
```cpp
template<typename T>
class HasDisplay {
private:
    template<typename U>
    static auto test(int) -> decltype(std::declval<U>().display(), std::true_type{});
    
    template<typename U>
    static std::false_type test(...);

public:
    static const bool value = decltype(test<T>(0))::value;
};
```

---

## 第七部分：综合项目实践

### 7.1 动态数组类模板设计

#### 设计目标
实现一个功能完整的动态数组类模板，支持：
- 动态内存管理
- 元素访问和修改
- 大小和容量管理
- 拷贝语义和移动语义
- 异常安全

#### 核心实现要点

##### 1. 内存管理
```cpp
template<typename T>
class DynamicArray {
private:
    T* data;
    size_t size;
    size_t capacity;
    
public:
    DynamicArray() : data(nullptr), size(0), capacity(0) {}
    
    ~DynamicArray() {
        delete[] data;
    }
    
    void reserve(size_t newCapacity) {
        if (newCapacity > capacity) {
            T* newData = new T[newCapacity];
            for (size_t i = 0; i < size; ++i) {
                newData[i] = data[i];
            }
            delete[] data;
            data = newData;
            capacity = newCapacity;
        }
    }
};
```

##### 2. 拷贝语义
```cpp
// 拷贝构造函数
DynamicArray(const DynamicArray& other) : size(other.size), capacity(other.capacity) {
    data = new T[capacity];
    for (size_t i = 0; i < size; ++i) {
        data[i] = other.data[i];
    }
}

// 赋值操作符
DynamicArray& operator=(const DynamicArray& other) {
    if (this != &other) {
        delete[] data;
        size = other.size;
        capacity = other.capacity;
        data = new T[capacity];
        for (size_t i = 0; i < size; ++i) {
            data[i] = other.data[i];
        }
    }
    return *this;
}
```

##### 3. 移动语义
```cpp
// 移动构造函数
DynamicArray(DynamicArray&& other) noexcept 
    : data(other.data), size(other.size), capacity(other.capacity) {
    other.data = nullptr;
    other.size = 0;
    other.capacity = 0;
}

// 移动赋值操作符
DynamicArray& operator=(DynamicArray&& other) noexcept {
    if (this != &other) {
        delete[] data;
        data = other.data;
        size = other.size;
        capacity = other.capacity;
        other.data = nullptr;
        other.size = 0;
        other.capacity = 0;
    }
    return *this;
}
```

### 7.2 项目实现要点

#### 异常安全
1. **基本异常安全**：保证对象处于有效状态
2. **强异常安全**：操作要么成功，要么保持原状态
3. **无异常安全**：操作不会抛出异常

#### 性能优化
1. **内存预分配**：避免频繁的内存分配
2. **移动语义**：减少不必要的拷贝
3. **内联函数**：提高小函数性能

---

## 学习要点总结

### 核心概念
1. **模板是编译时机制**：模板在编译时实例化，生成特定类型的代码
2. **类型安全**：模板提供编译时类型检查，确保类型安全
3. **代码复用**：一次编写，多种类型使用
4. **性能优化**：编译时优化，无运行时开销

### 重要技术
1. **模板特化**：为特定类型提供专门实现
2. **SFINAE**：模板元编程的核心技术
3. **可变参数模板**：支持任意数量参数的模板
4. **模板元编程**：在编译时进行计算和类型操作

### 最佳实践
1. **合理使用特化**：只在必要时使用特化
2. **异常安全**：确保模板类的异常安全性
3. **性能考虑**：注意模板实例化的性能影响
4. **代码可读性**：保持模板代码的可读性和可维护性

### 常见陷阱
1. **模板参数推导失败**：注意推导规则和限制
2. **链接错误**：模板定义必须在头文件中
3. **编译时间**：复杂模板可能增加编译时间
4. **错误信息**：模板错误信息可能难以理解

---

## 课后练习建议

### 基础练习
1. 实现基本的函数模板（交换、最大值、最小值）
2. 编写简单的类模板（栈、队列、对）
3. 练习模板参数推导

### 进阶练习
1. 实现模板特化
2. 编写可变参数模板
3. 设计模板元编程示例

### 项目实践
1. 完成动态数组类模板
2. 实现简单的智能指针模板
3. 设计通用的容器类模板

---

## 参考资料

### 推荐书籍
1. 《C++ Templates: The Complete Guide》- David Vandevoorde
2. 《Effective C++》- Scott Meyers
3. 《Modern C++ Design》- Andrei Alexandrescu

### 在线资源
1. C++ Reference: https://en.cppreference.com/
2. C++ Core Guidelines: https://isocpp.github.io/CppCoreGuidelines/
3. Template Metaprogramming: https://en.wikipedia.org/wiki/Template_metaprogramming

---

**课程结束**

通过本课程的学习，您应该已经掌握了C++模板编程的基础知识和实践技能。模板是C++中非常强大的特性，掌握它将大大提高您的编程效率和代码质量。继续练习和实践，您将能够熟练运用模板技术解决复杂的编程问题。
