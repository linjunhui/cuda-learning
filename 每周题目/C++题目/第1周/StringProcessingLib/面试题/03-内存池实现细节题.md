# 内存池实现细节面试题

## 题目1：实现 allocate() 函数
**难度：⭐⭐⭐**

### 问题描述
请为 `FixedSizePool` 实现 `allocate(size_t size)` 函数，要求：
1. 从空闲链表中分配一个块
2. 处理池已满的情况
3. 返回用户可用的数据指针
4. 更新相关统计信息

### 参考答案要点
```cpp
void* FixedSizePool::allocate(size_t size) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 检查请求大小是否超过块大小
    if (size > block_size) {
        return nullptr; // 或抛出异常
    }
    
    // 检查是否有空闲块
    if (free_list == nullptr) {
        return nullptr; // 池已满
    }
    
    // 从空闲链表头部取出一个块
    BlockHeader* header = free_list;
    free_list = header->next;
    
    // 标记为已分配
    header->mark_allocated();
    
    // 更新统计信息
    use_count++;
    total_allocations++;
    
    // 返回用户数据指针
    return header->get_user_ptr();
}
```

### 评分标准
- 正确实现分配逻辑（2分）
- 处理边界情况（1分）
- 线程安全（1分）
- 更新统计信息（1分）

---

## 题目2：实现 deallocate() 函数
**难度：⭐⭐⭐**

### 问题描述
请实现 `deallocate(void* ptr)` 函数，要求：
1. 验证指针的有效性
2. 将块重新加入空闲链表
3. 处理无效指针和重复释放
4. 更新统计信息

### 参考答案要点
```cpp
bool FixedSizePool::deallocate(void* ptr) {
    if (ptr == nullptr) {
        return false;
    }
    
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 获取块头部
    BlockHeader* header = get_header_from_user_ptr(ptr);
    
    // 验证指针有效性
    if (!validate_block_header(header)) {
        return false; // 无效指针
    }
    
    // 检查是否在内存池范围内
    char* start = static_cast<char*>(memory_block);
    char* end = start + block_count * block_size;
    if (reinterpret_cast<char*>(header) < start || 
        reinterpret_cast<char*>(header) >= end) {
        return false; // 不属于本池
    }
    
    // 检查是否已经释放
    if (header->is_free) {
        return false; // 重复释放
    }
    
    // 重置块状态
    header->reset();
    
    // 加入空闲链表（头插法）
    header->next = free_list;
    free_list = header;
    
    // 更新统计信息
    use_count--;
    total_deallocations++;
    
    return true;
}
```

### 评分标准
- 正确实现释放逻辑（2分）
- 验证指针有效性（2分）
- 处理重复释放（1分）

---

## 题目3：指针验证的边界检查
**难度：⭐⭐⭐⭐**

### 问题描述
在 `deallocate()` 中需要验证指针是否属于当前内存池。请实现一个函数来检查：
1. 指针是否在内存池的有效范围内
2. 指针是否对齐到块边界
3. 如何高效地进行这些检查？

### 参考答案要点
```cpp
bool FixedSizePool::is_valid_pointer(void* ptr) const {
    if (ptr == nullptr || memory_block == nullptr) {
        return false;
    }
    
    // 获取块头部
    BlockHeader* header = get_header_from_user_ptr(ptr);
    
    // 检查是否在内存池范围内
    char* pool_start = static_cast<char*>(memory_block);
    char* pool_end = pool_start + block_count * block_size;
    char* header_ptr = reinterpret_cast<char*>(header);
    
    if (header_ptr < pool_start || header_ptr >= pool_end) {
        return false;
    }
    
    // 检查是否对齐到块边界
    size_t offset = header_ptr - pool_start;
    if (offset % block_size != 0) {
        return false;
    }
    
    // 检查块头部有效性
    if (!validate_block_header(header)) {
        return false;
    }
    
    return true;
}
```

### 评分标准
- 实现范围检查（2分）
- 实现对齐检查（2分）
- 考虑性能优化（1分）

---

## 题目4：从用户指针到块头部的转换
**难度：⭐⭐⭐**

### 问题描述
内存池返回给用户的是数据区域的指针，但释放时需要找到对应的 `BlockHeader`。请解释：
1. 为什么需要这个转换？
2. `get_header_from_user_ptr()` 是如何工作的？
3. 这种设计的内存布局是什么样的？

### 参考答案要点
1. **需要转换的原因**：
   - 用户指针指向数据区域
   - 需要访问 BlockHeader 来管理块状态
   - 需要将块重新加入空闲链表

2. **转换原理**：
   ```cpp
   inline BlockHeader* get_header_from_user_ptr(void* user_ptr) noexcept {
       return reinterpret_cast<BlockHeader*>(user_ptr) - 1;
   }
   ```
   - 用户指针实际上指向 `BlockHeader + 1` 的位置
   - 通过指针算术，向前移动一个 `BlockHeader` 的大小

3. **内存布局**：
   ```
   +------------------+
   | BlockHeader      | <- header 指向这里
   +------------------+
   | User Data        | <- user_ptr 指向这里
   +------------------+
   ```

### 评分标准
- 说明转换的必要性（1分）
- 解释转换原理（2分）
- 描述内存布局（2分）

---

## 题目5：线程安全的实现
**难度：⭐⭐⭐⭐**

### 问题描述
当前实现使用了 `std::mutex` 来保证线程安全。请回答：
1. 为什么需要互斥锁？
2. 锁的粒度应该如何控制？
3. 有没有更高效的线程安全方案？

### 参考答案要点
1. **需要互斥锁的原因**：
   - free_list 是共享资源
   - 多个线程可能同时分配/释放
   - 需要保证操作的原子性

2. **锁粒度控制**：
   - 只保护关键路径（分配和释放）
   - 避免在持有锁时进行耗时操作
   - 可以考虑读写锁，如果读操作多

3. **更高效的方案**：
   - **无锁编程**：使用原子操作和 CAS
   - **线程本地存储**：每个线程有自己的空闲块缓存
   - **分段锁**：将内存池分成多个段，每个段有独立的锁

### 评分标准
- 说明需要锁的原因（1分）
- 说明锁粒度控制（2分）
- 提出优化方案（2分）

---

## 题目6：内存对齐的计算
**难度：⭐⭐⭐⭐**

### 问题描述
在 `calculate_aligned_block_size()` 函数中，使用了位运算来计算对齐。请解释：
1. 为什么使用 `(total_size + alignment - 1) & ~(alignment - 1)`？
2. 这个公式的数学原理是什么？
3. 如果 alignment 不是 2 的幂次，应该如何处理？

### 参考答案要点
1. **公式原理**：
   - `alignment - 1` 得到掩码
   - `~(alignment - 1)` 得到对齐掩码
   - `total_size + alignment - 1` 先向上取整
   - `&` 操作清空低位，实现对齐

2. **数学原理**：
   - 假设 alignment = 8（2^3）
   - `alignment - 1 = 7 = 0b111`
   - `~(alignment - 1) = 0xFFFFFFF8`（清空低3位）
   - 结果会被对齐到 8 的倍数

3. **非2的幂次处理**：
   ```cpp
   size_t aligned_size = ((total_size + alignment - 1) / alignment) * alignment;
   ```
   - 使用除法向上取整
   - 性能略低，但更通用

### 评分标准
- 解释位运算公式（2分）
- 说明数学原理（2分）
- 处理非2的幂次情况（1分）
